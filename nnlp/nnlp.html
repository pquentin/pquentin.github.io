<!DOCTYPE html><html>
<head>
<title>A Primer on Neural Network Modelsfor Natural Language Processing</title>
<!--Generated on Sat Oct 10 10:33:19 2015 by LaTeXML (version 0.8.1) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="ltx-listings.css" type="text/css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">A Primer on Neural Network Models
<br class="ltx_break">for Natural Language Processing</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Yoav Goldberg 
<br class="ltx_break"><span class="ltx_text" style="font-size:90%;">Draft as of October 10, 2015.</span>
</span></span>
</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
    
<p class="ltx_p">Over the past few years, neural networks have re-emerged as powerful
machine-learning models, yielding state-of-the-art results in fields such as image
recognition and speech processing. More recently, neural network models
started to be applied also to textual natural language signals, again with very
promising results. This tutorial surveys neural network models from the
perspective of natural language processing research, in an attempt to bring
natural-language researchers up to speed with the neural techniques. The
tutorial covers input encoding for natural language tasks, feed-forward
networks, convolutional networks, recurrent networks and recursive networks,
as well as the computation graph abstraction for
automatic gradient computation.</p>
  
</div>
<div id="p1" class="ltx_para">
<p class="ltx_p">

<span class="ltx_inline-block ltx_parbox ltx_align_middle" style="width:390.3pt;border:1px solid black;">
<span class="ltx_p"><span class="ltx_text" style="font-size:90%;">The most up-to-date version of this manuscript is available at
<a href="http://www.cs.biu.ac.il/~yogo/nnlp.pdf" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://www.cs.biu.ac.il/~yogo/nnlp.pdf</span></a>. Major updates will be published on
arxiv periodically.</span></span>
<span class="ltx_p"><span class="ltx_text" style="font-size:90%;">I welcome any comments you may have regarding the content and
presentation. If you spot a missing reference or have relevant work you’d
like to see mentioned, do let me know.</span></span>
<span class="ltx_p"><span class="ltx_text ltx_font_typewriter" style="font-size:90%;">first.last@gmail</span></span>
</span>
</p>
</div>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p class="ltx_p">For a long time, core NLP techniques were dominated by machine-learning
approaches that used linear models such as support vector machines or logistic
regression, trained over very high dimensional yet very sparse feature vectors.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p class="ltx_p">Recently, the field has seen some success in switching from such linear models
over sparse inputs to non-linear neural-network models over dense inputs. While
most of the neural network techniques are easy to apply, sometimes as almost
drop-in replacements of the old linear classifiers, there is in many cases a
strong barrier of entry. In this tutorial I attempt to provide NLP
practitioners (as well as newcomers) with the basic background, jargon, tools
and methodology that will allow them to understand the principles behind the
neural network models and apply them to their own work. This tutorial is
expected to be self-contained, while presenting the different approaches under a
unified notation and framework. It repeats a lot of material which is available
elsewhere. It also points to external sources for more advanced topics when
appropriate.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p class="ltx_p">This primer is not intended as a comprehensive resource for those that will go
on and develop the next advances in neural-network machinery (though it may
serve as a good entry point). Rather, it is aimed at those readers who are
interested in taking the existing, useful technology and applying it in useful
and creative ways to their favourite NLP problems. For more in-depth, general
discussion of neural networks, the theory behind them, advanced optimization
methods and other advanced topics, the reader is referred to other existing
resources. In particular, the book by Bengio et al <span class="ltx_ERROR undefined">\citeyear</span>bengio2015deep is highly
recommended.</p>
</div>
<section id="S1.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Scope</h5>

<div id="S1.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">The focus is on applications of neural networks to language
processing tasks. However, some subareas of language processing with neural
networks were decidedly left out of scope of this tutorial.
These include the vast literature of language modeling and acoustic modeling,
the use of neural networks for machine translation, and multi-modal applications
combining language and other signals such as images and videos
(e.g. caption generation). Caching methods for efficient runtime performance,
methods for efficient training with
large output vocabularies and attention models are also not discussed.
Word embeddings are discussed only to the extent that is needed to understand in order
to use them as inputs for other models. Other unsupervised approaches, including
autoencoders and recursive autoencoders, also fall out of scope.
While some
applications of neural networks for language modeling and machine translation are
mentioned in the text, their treatment is by no means comprehensive.</p>
</div>
</section>
<section id="S1.SS0.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">A Note on Terminology</h5>

<div id="S1.SS0.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">The word “feature” is used to refer to a concrete, linguistic input such
as a word, a suffix, or a part-of-speech tag. For example, in a first-order
part-of-speech tagger, the features might be “current word, previous word, next
word, previous part of speech”. The term “input vector” is used to refer to
the actual input that is fed to the neural-network classifier. Similarly,
“input vector entry” refers to a specific value of the input. This is in contrast to
a lot of the neural networks literature in which the word “feature” is overloaded
between the two uses, and is used primarily to refer to an input-vector entry.</p>
</div>
</section>
<section id="S1.SS0.SSS0.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Mathematical Notation</h5>

<div id="S1.SS0.SSS0.Px3.p1" class="ltx_para">
<p class="ltx_p">I use bold upper case letters to represent
matrices (<math id="S1.SS0.SSS0.Px3.p1.m1" class="ltx_Math" alttext="\mathbf{X}" display="inline"><mi>𝐗</mi></math>, <math id="S1.SS0.SSS0.Px3.p1.m2" class="ltx_Math" alttext="\mathbf{Y}" display="inline"><mi>𝐘</mi></math>, <math id="S1.SS0.SSS0.Px3.p1.m3" class="ltx_Math" alttext="\mathbf{Z}" display="inline"><mi>𝐙</mi></math>), and bold lower-case letters to
represent vectors (<math id="S1.SS0.SSS0.Px3.p1.m4" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math>). When there
are series of related matrices and vectors (for example, where each matrix
corresponds to a different layer in the network), superscript indices are used
(<math id="S1.SS0.SSS0.Px3.p1.m5" class="ltx_Math" alttext="\mathbf{W^{1}}" display="inline"><msup><mi>𝐖</mi><mn>𝟏</mn></msup></math>, <math id="S1.SS0.SSS0.Px3.p1.m6" class="ltx_Math" alttext="\mathbf{W^{2}}" display="inline"><msup><mi>𝐖</mi><mn>𝟐</mn></msup></math>). For the rare cases in which we want indicate the power of a
matrix or a vector, a pair of brackets is added around the item to be
exponentiated: <math id="S1.SS0.SSS0.Px3.p1.m7" class="ltx_Math" alttext="(\mathbf{W})^{2},(\mathbf{W^{3}})^{2}" display="inline"><mrow><msup id="XM17"><mrow><mo stretchy="false">(</mo><mi id="XM15">𝐖</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></msup><mo>,</mo><msup id="XM18"><mrow><mo stretchy="false">(</mo><msup id="XM16"><mi>𝐖</mi><mn>𝟑</mn></msup><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></math>.
Unless otherwise stated, vectors are assumed to be row vectors.
We use <math id="S1.SS0.SSS0.Px3.p1.m8" class="ltx_Math" alttext="[\mathbf{v_{1}};\mathbf{v_{2}}]" display="inline"><mrow><mo stretchy="false">[</mo><msub id="XM19"><mi>𝐯</mi><mn>𝟏</mn></msub><mo>;</mo><msub id="XM20"><mi>𝐯</mi><mn>𝟐</mn></msub><mo stretchy="false">]</mo></mrow></math> to denote vector concatenation.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2 </span>Neural Network Architectures</h2>

<div id="S2.p1" class="ltx_para">
<p class="ltx_p">Neural networks are powerful learning models.
We will discuss two kinds of neural network architectures, that can be mixed and
matched – feed-forward networks and Recurrent / Recursive networks.
Feed-forward networks include networks with fully connected layers, such as the
multi-layer perceptron, as well as networks with convolutional and pooling
layers. All of the networks act as classifiers, but each with different
strengths.</p>
</div>
<div id="S2.p2" class="ltx_para">
<p class="ltx_p">Fully connected feed-forward neural networks (Section <a href="#S4" title="4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>) are non-linear learners that
can, for the most part, be used as a drop-in replacement wherever a linear
learner is used. This includes binary and multiclass classification problems,
as well as more complex structured prediction problems (Section
<a href="#S8" title="8 Structured Output Prediction ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>). The non-linearity of the
network, as well as the ability to easily integrate pre-trained word embeddings,
often lead to superior classification accuracy. A series of works
<cite class="ltx_cite">[]</cite> managed to obtain improved syntactic parsing
results by simply replacing the linear model of a parser with a fully connected
feed-forward network. Straight-forward applications of a feed-forward network as a
classifier replacement (usually coupled with the use of pre-trained word
vectors) provide
benefits also for CCG supertagging <cite class="ltx_cite">[]</cite>, dialog state tracking <cite class="ltx_cite">[]</cite>, pre-ordering
for statistical machine translation <cite class="ltx_cite">[]</cite> and language
modeling <cite class="ltx_cite">[]</cite>. Iyyer et al
<span class="ltx_ERROR undefined">\citeyear</span>iyyer2015deep demonstrate that multi-layer feed-forward networks can
provide competitive results on sentiment classification and factoid question
answering.</p>
</div>
<div id="S2.p3" class="ltx_para">
<p class="ltx_p">Networks with convolutional and pooling layers (Section <a href="#S9" title="9 Convolutional Layers ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>) are useful for classification tasks in which
we expect to find strong local clues regarding class membership, but these clues
can appear in different places in the input. For example, in a document
classification task, a single key phrase (or an ngram) can help in determining the
topic of the document <cite class="ltx_cite">[]</cite>. We would like to learn that certain sequences of words
are good indicators of the topic, and do not necessarily care where they appear
in the document. Convolutional and pooling layers allow the model to learn to
find such local indicators, regardless of their position. Convolutional and
pooling architecture show promising results on many tasks, including document classification
<cite class="ltx_cite">[]</cite>, short-text categorization <cite class="ltx_cite">[]</cite>,
sentiment classification <cite class="ltx_cite">[]</cite>,
relation type classification between entities
<cite class="ltx_cite">[]</cite>, event detection
<cite class="ltx_cite">[]</cite>, paraphrase identification <cite class="ltx_cite">[]</cite>
semantic role labeling <cite class="ltx_cite">[]</cite>, question answering
<cite class="ltx_cite">[]</cite>, predicting box-office revenues of movies based on
critic reviews <cite class="ltx_cite">[]</cite> modeling text interestingness
<cite class="ltx_cite">[]</cite>, and modeling the relation between character-sequences
and part-of-speech tags <cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S2.p4" class="ltx_para">
<p class="ltx_p">In natural language we often work with structured data of arbitrary sizes,
such as sequences and trees. We would like to be able to capture regularities
in such structures, or to model similarities between such structures. In many
cases, this means encoding the structure as a fixed width vector, which we can
then pass on to another statistical learner for further processing. While
convolutional and pooling architectures allow us to encode arbitrary large items
as fixed size vectors capturing their most salient features, they do so by sacrificing
most of the structural information. Recurrent (Section <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>) and
recursive (Section <a href="#S12" title="12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>) architectures, on
the other hand, allow us to work with sequences and trees while preserving a lot
of the structural information. Recurrent networks <cite class="ltx_cite">[]</cite> are designed to model
sequences, while recursive networks <cite class="ltx_cite">[]</cite> are generalizations of recurrent networks
that can handle trees. We will also discuss an extension of recurrent networks that
allow them to model stacks
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S2.p5" class="ltx_para">
<p class="ltx_p">Recurrent models have been shown to produce very
strong results for language modeling, including
<cite class="ltx_cite">[]</cite>;
as well as for sequence tagging
<cite class="ltx_cite">[]</cite>, machine translation
<cite class="ltx_cite">[]</cite>,
dependency parsing <cite class="ltx_cite">[]</cite>,
sentiment analysis <cite class="ltx_cite">[]</cite>, noisy text normalization
<cite class="ltx_cite">[]</cite>, dialog state tracking
<cite class="ltx_cite">[]</cite>, response generation <cite class="ltx_cite">[]</cite>, and
modeling the relation between character sequences and part-of-speech
tags <cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S2.p6" class="ltx_para">
<p class="ltx_p">Recursive models were shown to produce state-of-the-art or near state-of-the-art results for
constituency
<cite class="ltx_cite">[]</cite> and dependency <cite class="ltx_cite">[]</cite>
parse re-ranking, discourse parsing <cite class="ltx_cite">[]</cite>, semantic relation classification
<cite class="ltx_cite">[]</cite>,
political ideology detection based on parse trees <cite class="ltx_cite">[]</cite>,
sentiment classification <cite class="ltx_cite">[]</cite>,
target-dependent sentiment classification <cite class="ltx_cite">[]</cite> and
question answering <cite class="ltx_cite">[]</cite>.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span>Feature Representation</h2>

<div id="S3.p1" class="ltx_para">
<p class="ltx_p">Before discussing the network structure in more depth, it is important to pay
attention to how features are represented.
For now, we can think of a feed-forward neural network as a function <math id="S3.p1.m1" class="ltx_Math" alttext="NN(\mathbf{x})" display="inline"><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM21">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow></math> that
takes as input a <math id="S3.p1.m2" class="ltx_Math" alttext="d_{in}" display="inline"><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></math> dimensional vector <math id="S3.p1.m3" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> and produces a <math id="S3.p1.m4" class="ltx_Math" alttext="d_{out}" display="inline"><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math>
dimensional output vector. The function is often used as a <em class="ltx_emph">classifier</em>,
assigning the input <math id="S3.p1.m5" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> a degree of membership in one or more of <math id="S3.p1.m6" class="ltx_Math" alttext="d_{out}" display="inline"><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math>
classes. The function can be complex, and is almost always
non-linear. Common structures of this function will be discussed in Section
<a href="#S4" title="4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>. Here, we focus on the input, <math id="S3.p1.m7" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>.
When dealing with natural language, the
input <math id="S3.p1.m8" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> encodes features such as words, part-of-speech tags or other
linguistic information. Perhaps the biggest jump when
moving from sparse-input linear models to neural-network based models is to stop
representing each feature as a unique dimension (the so called one-hot
representation) and representing them instead as dense vectors. That is,
each core feature is <em class="ltx_emph">embedded</em> into a <math id="S3.p1.m9" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> dimensional
space, and
represented as a vector in that space.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup>Different feature types may be embedded into different spaces.
For example, one may represent word features using 100 dimensions, and
part-of-speech features using 20 dimensions.</span></span></span>
The embeddings (the vector
representation of each core feature) can then be trained like the other parameter
of the function <math id="S3.p1.m10" class="ltx_Math" alttext="NN" display="inline"><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi></mrow></math>. Figure <a href="#S3.F1" title="Figure 1 ‣ 3 Feature Representation ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> shows the two approaches
to feature representation.</p>
</div>
<figure id="S3.F1" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.7]feats.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 1: </span><span class="ltx_text ltx_font_bold">Sparse vs. dense feature representations</span>.
Two encodings of the information: <em class="ltx_emph">current word is “dog”; previous word is “the”; previous pos-tag is “DET”</em>.
(a) Sparse feature vector.
Each dimension represents a feature. Feature combinations receive their own
dimensions. Feature values are binary. Dimensionality is very high.
(b) Dense, embeddings-based feature vector. Each core feature is represented as a
vector. Each feature corresponds to several input vector entries. No explicit
encoding of feature combinations. Dimensionality is low. The feature-to-vector
mappings come from an embedding table.</figcaption>
</figure>
<div id="S3.p2" class="ltx_para">
<p class="ltx_p">The feature embeddings (the values of the vector entries for each feature) are treated as <em class="ltx_emph">model
parameters</em> that need to be trained together with the other components of the
network. Methods of training (or obtaining) the feature embeddings will be
discussed later. For now, consider the feature embeddings as given.</p>
</div>
<div id="S3.p3" class="ltx_para">
<p class="ltx_p">The general structure for an NLP classification system based on a feed-forward neural network is thus:</p>
<ol id="I1" class="ltx_enumerate">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">1.</span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p">Extract a set of core linguistic features <math id="I1.i1.p1.m1" class="ltx_Math" alttext="f_{1},\dots,f_{k}" display="inline"><mrow><msub id="XM22"><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM23">…</mi><mo>,</mo><msub id="XM24"><mi>f</mi><mi>k</mi></msub></mrow></math> that are relevant
for predicting the output class.
</p>
</div>
</li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">2.</span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p">For each feature <math id="I1.i2.p1.m1" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> of interest, retrieve the corresponding vector <math id="I1.i2.p1.m2" class="ltx_Math" alttext="v(f_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM25"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
</li>
<li id="I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">3.</span> 
<div id="I1.i3.p1" class="ltx_para">
<p class="ltx_p">Combine the vectors (either by concatenation, summation or a
combination of both) into an input vector <math id="I1.i3.p1.m1" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>.</p>
</div>
</li>
<li id="I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_enumerate">4.</span> 
<div id="I1.i4.p1" class="ltx_para">
<p class="ltx_p">Feed <math id="I1.i4.p1.m1" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> into a non-linear classifier (feed-forward neural network).</p>
</div>
</li>
</ol>
</div>
<div id="S3.p4" class="ltx_para">
<p class="ltx_p">The biggest change in the input, then, is the move from sparse representations in which each
feature is its own dimension, to a dense representation in which each feature
is mapped to a vector. Another difference is that we extract only <em class="ltx_emph">core
features</em> and not feature combinations. We will elaborate on both these changes
briefly.</p>
</div>
<section id="S3.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Dense Vectors vs. One-hot Representations</h5>

<div id="S3.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">What are the benefits of representing our features as vectors instead of as
unique IDs? Should we always represent features as dense vectors?
Let’s consider the two kinds of representations:</p>
<dl id="I2" class="ltx_description">
<dt id="I2.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_description">
              <span class="ltx_text ltx_font_bold">One Hot</span>
            </span></dt>
<dd class="ltx_item">
<div id="I2.ix1.p1" class="ltx_para">
<p class="ltx_p">Each feature is its own dimension.</p>
<ul id="I2.I1" class="ltx_itemize">
<li id="I2.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">
                    <span class="ltx_text ltx_font_bold">–</span>
                  </span> 
<div id="I2.I1.i1.p1" class="ltx_para">
<p class="ltx_p">Dimensionality of one-hot vector is same as number of distinct
features.</p>
</div>
</li>
<li id="I2.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">
                    <span class="ltx_text ltx_font_bold">–</span>
                  </span> 
<div id="I2.I1.i2.p1" class="ltx_para">
<p class="ltx_p">Features are completely independent from one another. The
feature “word is ‘dog’ ” is as dis-similar to “word is
‘thinking’ ”
than it is to “word is ‘cat’ ”.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt id="I2.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_description">
              <span class="ltx_text ltx_font_bold">Dense</span>
            </span></dt>
<dd class="ltx_item">
<div id="I2.ix2.p1" class="ltx_para">
<p class="ltx_p">Each feature is a <math id="I2.ix2.p1.m1" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector.</p>
<ul id="I2.I2" class="ltx_itemize">
<li id="I2.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">
                    <span class="ltx_text ltx_font_bold">–</span>
                  </span> 
<div id="I2.I2.i1.p1" class="ltx_para">
<p class="ltx_p">Dimensionality of vector is <math id="I2.I2.i1.p1.m1" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>.</p>
</div>
</li>
<li id="I2.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_itemize">
                    <span class="ltx_text ltx_font_bold">–</span>
                  </span> 
<div id="I2.I2.i2.p1" class="ltx_para">
<p class="ltx_p">Similar features will have similar vectors –
information is shared between similar features.</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div id="S3.SS0.SSS0.Px1.p2" class="ltx_para">
<p class="ltx_p">One benefit of using dense and low-dimensional vectors is computational: the
majority of neural network toolkits do not play well with
very high-dimensional, sparse vectors. However, this is just a technical
obstacle, which can be resolved with some engineering effort.</p>
</div>
<div id="S3.SS0.SSS0.Px1.p3" class="ltx_para">
<p class="ltx_p">The main benefit of the dense representations is in generalization power: if we
believe some features may provide similar clues, it is worthwhile to provide a
representation that is able to capture these similarities.
For example, assume we have observed the word ‘dog’ many times during
training, but only observed the word ‘cat’ a handful of times, or not at all.
If each of the words is associated with its own dimension, occurrences of
‘dog’ will not tell us anything about the occurrences of ‘cat’. However, in
the dense vectors representation the learned vector for ‘dog’ may be similar
to the learned vector from ‘cat’, allowing the model to share statistical
strength between the two events. This argument assumes that “good” vectors are
somehow given to us. Section <a href="#S5" title="5 Word Embeddings ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> describes ways of
obtaining such vector representations.</p>
</div>
<div id="S3.SS0.SSS0.Px1.p4" class="ltx_para">
<p class="ltx_p">In cases where we have relatively few distinct features in the category, and we
believe there are no correlations between the different features, we may use the
one-hot representation. However, if we believe there are going to be correlations
between the different features in the group (for example, for part-of-speech
tags, we may believe that the different verb inflections <span class="ltx_text ltx_font_typewriter">VB</span> and
<span class="ltx_text ltx_font_typewriter">VBZ</span> may
behave similarly as far as our task is concerned) it may be worthwhile to let
the network figure out the correlations and gain some statistical strength by
sharing the parameters.
It may be the case that under some circumstances, when
the feature space is relatively small and the training data is plentiful, or
when we do not wish to share statistical information between distinct words, there
are gains to be made from using the one-hot representations. However, this is
still an open research question, and there are no strong evidence to either side.
The majority of work (pioneered by
<cite class="ltx_cite">[]</cite>)
advocate the use of dense, trainable embedding vectors for all features.
For work using neural network architecture with sparse vector encodings see
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S3.SS0.SSS0.Px1.p5" class="ltx_para">
<p class="ltx_p">Finally, it is important to note that representing features as dense vectors
is an integral part of the neural network framework, and that consequentially
the differences between using sparse and dense feature representations are
subtler than they may appear at first. In fact, using sparse, one-hot vectors
as input when training a neural network amounts to dedicating the first layer
of the network to learning a dense embedding vector for each feature
based on the training data. We touch on this in Section <a href="#S4.SS4" title="4.4 Embedding Layers ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.4</span></a>.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Variable Number of Features: Continuous Bag of Words</h5>

<div id="S3.SS0.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">Feed-forward networks assume a fixed dimensional input.
This can easily accommodate the case of a feature-extraction function that extracts a fixed
number of features: each feature is represented as a vector, and the vectors are
concatenated. This way, each region of the resulting input vector corresponds to a
different feature. However, in some cases the number of features is not known in
advance (for example, in document classification it is common that each word in
the sentence is a feature).
We thus need to represent an unbounded number of features using a fixed size
vector.
One way of achieving this is through a so-called <em class="ltx_emph">continuous bag of words</em>
(CBOW) representation <cite class="ltx_cite">[]</cite>. The CBOW is very similar to the traditional bag-of-words
representation in which we discard order information, and works by either summing or
averaging the
embedding vectors of the corresponding features:<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup>Note that if the
<math id="S3.SS0.SSS0.Px2.p1.m1" class="ltx_Math" alttext="v(f_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM26"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>s were one-hot vectors rather than dense feature representations, the
<math id="S3.SS0.SSS0.Px2.p1.m2" class="ltx_Math" alttext="CBOW" display="inline"><mrow><mi>C</mi><mo>⁢</mo><mi>B</mi><mo>⁢</mo><mi>O</mi><mo>⁢</mo><mi>W</mi></mrow></math> and <math id="S3.SS0.SSS0.Px2.p1.m3" class="ltx_Math" alttext="WCBOW" display="inline"><mrow><mi>W</mi><mo>⁢</mo><mi>C</mi><mo>⁢</mo><mi>B</mi><mo>⁢</mo><mi>O</mi><mo>⁢</mo><mi>W</mi></mrow></math> equations above would reduce to the traditional (weighted) bag-of-words
representations, which is in turn equivalent to a sparse feature-vector
representation in which
each binary indicator feature corresponds to a unique “word”.</span></span></span></p>
</div>
<div id="S3.SS0.SSS0.Px2.p2" class="ltx_para">
<table id="S3.Ex1" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S3.Ex1.m1" class="ltx_Math" alttext="CBOW(f_{1},...,f_{k})=\frac{1}{k}\sum_{i=1}^{k}v(f_{i})" display="block"><mrow><mrow><mi>C</mi><mo>⁢</mo><mi>B</mi><mo>⁢</mo><mi>O</mi><mo>⁢</mo><mi>W</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM27"><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM28">…</mi><mo>,</mo><msub id="XM29"><mi>f</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mi>k</mi></mfrac><mo>⁢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM30"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S3.SS0.SSS0.Px2.p3" class="ltx_para">
<p class="ltx_p">A simple variation on the CBOW representation is weighted CBOW, in which different vectors receive different weights:</p>
</div>
<div id="S3.SS0.SSS0.Px2.p4" class="ltx_para">
<table id="S3.Ex2" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S3.Ex2.m1" class="ltx_Math" alttext="WCBOW(f_{1},...,f_{k})=\frac{1}{\sum_{i=1}^{k}a_{i}}\sum_{i=1}^{k}a_{i}v(f_{i})" display="block"><mrow><mrow><mi>W</mi><mo>⁢</mo><mi>C</mi><mo>⁢</mo><mi>B</mi><mo>⁢</mo><mi>O</mi><mo>⁢</mo><mi>W</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM31"><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM32">…</mi><mo>,</mo><msub id="XM33"><mi>f</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow></mfrac><mo>⁢</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>⁢</mo><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM34"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S3.SS0.SSS0.Px2.p5" class="ltx_para">
<p class="ltx_p">Here, each feature <math id="S3.SS0.SSS0.Px2.p5.m1" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> has an associated weight <math id="S3.SS0.SSS0.Px2.p5.m2" class="ltx_Math" alttext="a_{i}" display="inline"><msub><mi>a</mi><mi>i</mi></msub></math>, indicating the relative
importance of the feature. For example, in a document classification task, a
feature <math id="S3.SS0.SSS0.Px2.p5.m3" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> may correspond to a word in the document, and the associated
weight <math id="S3.SS0.SSS0.Px2.p5.m4" class="ltx_Math" alttext="a_{i}" display="inline"><msub><mi>a</mi><mi>i</mi></msub></math> could be the word’s TF-IDF score.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Distance and Position Features</h5>

<div id="S3.SS0.SSS0.Px3.p1" class="ltx_para">
<p class="ltx_p">The linear distance in between two words in a
sentence may serve as an informative feature. For example, in an event
extraction task<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup>The event extraction task involves identification of
events from a predefined set of event types. For example identification of
“purchase” events or “terror-attack” events. Each event type can be
triggered by various triggering words (commonly verbs), and has several slots
(arguments)
that needs to be filled (i.e. who purchased? what was purchased? at what
amount?).</span></span></span>
we may be given a trigger word and a candidate argument word, and asked to
predict if the argument word is indeed an argument of the trigger. The distance (or relative position)
between the trigger and the argument is a strong signal for this prediction task. In the
“traditional” NLP setup, distances are usually encoded by binning the
distances into several groups (i.e. 1, 2, 3, 4, 5–10, 10+) and associating each bin
with a one-hot vector. In a neural architecture, where the input vector is not composed of binary indicator features, it may seem natural to allocate a single
input vector entry to the distance feature, where the numeric value of that entry is the distance. However,
this approach is not taken in practice. Instead,
distance features are encoded
similarly to the other feature types: each bin is associated with a
<math id="S3.SS0.SSS0.Px3.p1.m1" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector, and these distance-embedding vectors are then trained as
regular parameters in the
network <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Feature Combinations</h5>

<div id="S3.SS0.SSS0.Px4.p1" class="ltx_para">
<p class="ltx_p">Note that the feature extraction stage in the
neural-network settings deals only with extraction of <em class="ltx_emph">core</em> features.
This is in contrast to the traditional linear-model-based NLP systems in which the
feature designer had to manually specify not only the core features of interests but
also interactions between them (e.g., introducing not only a feature stating
“word is X” and a feature
stating “tag is Y” but also combined feature stating “word is X and tag is Y” or
sometimes even “word is X, tag is Y and previous word is Z”). The combination
features are crucial in linear models because they introduce more
dimensions to the input, transforming it into a space where the data-points are
closer to being linearly separable. On the other hand, the space of possible
combinations is very large, and the feature designer has to spend a lot of time
coming up with an effective set of feature combinations.
One of the
promises of the non-linear neural network models is that one needs to define
only the core features. The non-linearity of the classifier, as defined by the
network structure, is expected to take care of finding the indicative feature
combinations, alleviating the need for feature combination engineering.</p>
</div>
<div id="S3.SS0.SSS0.Px4.p2" class="ltx_para">
<p class="ltx_p">Kernel methods <cite class="ltx_cite">[]</cite>, and in particular polynomial
kernels <cite class="ltx_cite">[]</cite>, also allow the
feature designer to specify only core features, leaving the feature combination
aspect to the learning algorithm. In contrast to neural-network models, kernels
methods are convex, admitting exact solutions to the optimization problem.
However, the classification efficiency in kernel methods scales linearly with the size
of the training data, making them too slow for most practical purposes, and not
suitable for training with large datasets.
On the other hand, neural network
classification efficiency scales linearly with the size of the network,
regardless of the training data size.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px5" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Dimensionality</h5>

<div id="S3.SS0.SSS0.Px5.p1" class="ltx_para">
<p class="ltx_p">How many dimensions should we allocate for each
feature? Unfortunately, there are no theoretical bounds or even established best-practices
in this space.
Clearly, the dimensionality should grow with the number of the members in the class
(you probably want to assign more dimensions to word embeddings than to
part-of-speech embeddings) but how much is enough? In current research, the
dimensionality of word-embedding vectors range between about 50 to a few hundreds,
and, in some extreme cases, thousands. Since the dimensionality of the vectors
has a direct effect on memory requirements and processing time, a good rule of
thumb would be to experiment with a few different sizes, and choose a good
trade-off between speed and task accuracy.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px6" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Vector Sharing</h5>

<div id="S3.SS0.SSS0.Px6.p1" class="ltx_para">
<p class="ltx_p">Consider a case where you have a few features that
share the same vocabulary. For example, when assigning a part-of-speech to a
given word, we may have a set of features considering the
previous word, and a set of features considering the next word. When building
the input to the classifier, we will concatenate the vector representation of
the previous word to the vector representation of the next word. The classifier
will then be able to distinguish the two different indicators, and treat them
differently. But should the two features share the same vectors? Should the
vector for “dog:previous-word” be the same as the vector of “dog:next-word”?
Or should we assign them two distinct vectors?
This, again, is mostly an empirical question. If you believe words behave
differently when they appear in different positions (e.g., word X behaves like
word Y when in the previous position, but X behaves like Z when in the next
position) then it may be a good idea to use two different vocabularies and
assign a different set of vectors for each feature type. However, if you believe
the words behave similarly in both locations, then something may be gained by
using a shared vocabulary for both feature types.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px7" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Network’s Output</h5>

<div id="S3.SS0.SSS0.Px7.p1" class="ltx_para">
<p class="ltx_p">For multi-class classification problems with <math id="S3.SS0.SSS0.Px7.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>
classes, the
network’s output is a <math id="S3.SS0.SSS0.Px7.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-dimensional vector in which every dimension represents
the strength of a particular output class. That is, the output remains as in the
traditional linear models – scalar scores to items in a discrete set. However,
as we will see in Section
<a href="#S4" title="4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>, there is a <math id="S3.SS0.SSS0.Px7.p1.m3" class="ltx_Math" alttext="d\times k" display="inline"><mrow><mi>d</mi><mo>×</mo><mi>k</mi></mrow></math> matrix associated with the
output layer. The columns of this matrix can be thought of as <math id="S3.SS0.SSS0.Px7.p1.m4" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> dimensional
embeddings of the output classes. The vector similarities between the vector
representations of the <math id="S3.SS0.SSS0.Px7.p1.m5" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> classes indicate the model’s learned similarities between the
output classes.</p>
</div>
</section>
<section id="S3.SS0.SSS0.Px8" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Historical Note</h5>

<div id="S3.SS0.SSS0.Px8.p1" class="ltx_para">
<p class="ltx_p">Representing words as dense vectors for input to a
neural network was introduced by Bengio et al <cite class="ltx_cite">[]</cite> in the
context of neural language modeling. It was introduced to NLP tasks in the
pioneering work of Collobert, Weston and colleagues
<span class="ltx_ERROR undefined">\citeyear</span>collobert2008unified,collobert2011natural. Using embeddings for
representing not only words but arbitrary features was popularized following Chen and Manning <span class="ltx_ERROR undefined">\citeyear</span>chen2014fast.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4 </span>Feed-forward Neural Networks</h2>

<section id="S4.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">A Brain-inspired metaphor</h5>

<div id="S4.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">As the name suggest, neural-networks are
inspired by the brain’s computation mechanism, which consists of computation
units called neurons. In the metaphor, a neuron is a computational unit that has
scalar inputs and outputs. Each input has an associated weight. The neuron
multiplies each input by its weight, and then sums<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">4</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">4</sup>While summing is the
most common operation, other functions, such as a max, are also possible</span></span></span> them,
applies a non-linear function to the result, and passes it to its output.
The neurons are connected to each other, forming a network: the output of a
neuron may feed into the inputs of one or more neurons. Such networks were shown to
be very capable computational devices. If the weights are set correctly, a neural network
with enough neurons and a non-linear activation function can approximate a very wide range of mathematical functions (we will be more precise
about this later).</p>
</div>
<figure id="S4.F2" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">{neuralnetwork}</span>
<p class="ltx_p ltx_align_center">[height=4,style=rotate=90,layertitleheight=5.5em,toprow=true]




<span class="ltx_ERROR undefined">\inputlayer</span>[count=4, bias=false, title=Input layer, text=<math id="S4.F2.m1" class="ltx_Math" alttext="x_{\hiddenlayer}" display="inline"><msub><mi>x</mi><merror class="ltx_ERROR undefined undefined"><mtext>\hiddenlayer</mtext></merror></msub></math>[count=6, bias=false, title=Hidden layer, text=<math id="S4.F2.m2" class="ltx_Math" alttext="\int" display="inline"><mo largeop="true" symmetric="true">∫</mo></math><span class="ltx_ERROR undefined">\hiddenlayer</span>[count=5, bias=false, title=Hidden layer, text=<math id="S4.F2.m3" class="ltx_Math" alttext="\int" display="inline"><mo largeop="true" symmetric="true">∫</mo></math><span class="ltx_ERROR undefined">\outputlayer</span>[count=3, title=Output layer, text=<math id="S4.F2.m4" class="ltx_Math" alttext="y_{\linklayers}" display="inline"><msub><mi>y</mi><merror class="ltx_ERROR undefined undefined"><mtext>\linklayers</mtext></merror></msub></math></p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Feed-forward neural network with two hidden layers.</figcaption>
</figure>
<div id="S4.SS0.SSS0.Px1.p2" class="ltx_para">
<p class="ltx_p">A typical feed-forward neural network may be drawn as in Figure <a href="#S4.F2" title="Figure 2 ‣ A Brain-inspired metaphor ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>.
Each circle is a neuron, with incoming arrows being the neuron’s inputs and
outgoing arrows being the neuron’s outputs. Each arrow carries a weight,
reflecting its importance (not shown).
Neurons are arranged in layers,
reflecting the flow of information. The bottom layer has no incoming arrows,
and is the input to the network. The top-most layer has no outgoing arrows, and
is the output of the network. The other layers are considered “hidden”.
The sigmoid shape inside the neurons in the
middle layers represent a non-linear function (typically a <math id="S4.SS0.SSS0.Px1.p2.m1" class="ltx_Math" alttext="1/(1+e^{-x}" display="inline"><mrow><mn>1</mn><mo>/</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mrow></math>)) that
is applied to the neuron’s value before passing it to the output.
In the figure, each neuron is connected to all of the neurons in the next layer
– this is called a <em class="ltx_emph">fully-connected layer</em> or an <em class="ltx_emph">affine layer</em>.</p>
</div>
<div id="S4.SS0.SSS0.Px1.p3" class="ltx_para">
<p class="ltx_p">While the brain metaphor is sexy and
intriguing, it is also distracting and cumbersome to manipulate mathematically.
We therefore switch to using more concise mathematic notation.
The values of each row of neurons in the network can be thought of as a vector. In Figure
<a href="#S4.F2" title="Figure 2 ‣ A Brain-inspired metaphor ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> the input layer is a <math id="S4.SS0.SSS0.Px1.p3.m1" class="ltx_Math" alttext="4" display="inline"><mn>4</mn></math> dimensional vector (<math id="S4.SS0.SSS0.Px1.p3.m2" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>), and the
layer above it is a <math id="S4.SS0.SSS0.Px1.p3.m3" class="ltx_Math" alttext="6" display="inline"><mn>6</mn></math> dimensional vector (<math id="S4.SS0.SSS0.Px1.p3.m4" class="ltx_Math" alttext="\mathbf{h^{1}}" display="inline"><msup><mi>𝐡</mi><mn>𝟏</mn></msup></math>).
The fully connected layer can be
thought of as a linear transformation from <math id="S4.SS0.SSS0.Px1.p3.m5" class="ltx_Math" alttext="4" display="inline"><mn>4</mn></math> dimensions to <math id="S4.SS0.SSS0.Px1.p3.m6" class="ltx_Math" alttext="6" display="inline"><mn>6</mn></math> dimensions.
A fully-connected layer implements a vector-matrix multiplication, <math id="S4.SS0.SSS0.Px1.p3.m7" class="ltx_Math" alttext="\mathbf{h}=\mathbf{x}\mathbf{W}" display="inline"><mrow><mi>𝐡</mi><mo>=</mo><mi>𝐱𝐖</mi></mrow></math> where
the weight of the connection from the <math id="S4.SS0.SSS0.Px1.p3.m8" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>th neuron in the input row to the <math id="S4.SS0.SSS0.Px1.p3.m9" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>th
neuron in the output row is <math id="S4.SS0.SSS0.Px1.p3.m10" class="ltx_Math" alttext="W_{ij}" display="inline"><msub><mi>W</mi><mrow><mi>i</mi><mo>⁢</mo><mi>j</mi></mrow></msub></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">5</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">5</sup>To see why this is the case,
denote the weight of the <math id="S4.SS0.SSS0.Px1.p3.m11" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>th input of the <math id="S4.SS0.SSS0.Px1.p3.m12" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>th neuron in <math id="S4.SS0.SSS0.Px1.p3.m13" class="ltx_Math" alttext="\mathbf{h}" display="inline"><mi>𝐡</mi></math> as <math id="S4.SS0.SSS0.Px1.p3.m14" class="ltx_Math" alttext="w_{ij}" display="inline"><msub><mi>w</mi><mrow><mi>i</mi><mo>⁢</mo><mi>j</mi></mrow></msub></math>.
The value of <math id="S4.SS0.SSS0.Px1.p3.m15" class="ltx_Math" alttext="h_{j}" display="inline"><msub><mi>h</mi><mi>j</mi></msub></math> is then <math id="S4.SS0.SSS0.Px1.p3.m16" class="ltx_Math" alttext="h_{j}=\sum_{i=1}^{4}x_{i}\cdot w_{ij}" display="inline"><mrow><msub><mi>h</mi><mi>j</mi></msub><mo>=</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></msubsup><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>⁢</mo><mi>j</mi></mrow></msub></mrow></mrow></mrow></math>.</span></span></span> The values of
<math id="S4.SS0.SSS0.Px1.p3.m17" class="ltx_Math" alttext="\mathbf{h}" display="inline"><mi>𝐡</mi></math> are then transformed by a non-linear function <math id="S4.SS0.SSS0.Px1.p3.m18" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> that is applied to
each value before being passed on to the next input. The whole computation from
input to output can be written as: <math id="S4.SS0.SSS0.Px1.p3.m19" class="ltx_Math" alttext="(g(\mathbf{x}\mathbf{W^{1}}))\mathbf{W^{2}}" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM36"><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup id="XM35"><mi>𝐱𝐖</mi><mn>𝟏</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow></math> where <math id="S4.SS0.SSS0.Px1.p3.m20" class="ltx_Math" alttext="\mathbf{W^{1}}" display="inline"><msup><mi>𝐖</mi><mn>𝟏</mn></msup></math>
are the weights of the first layer and <math id="S4.SS0.SSS0.Px1.p3.m21" class="ltx_Math" alttext="\mathbf{W^{2}}" display="inline"><msup><mi>𝐖</mi><mn>𝟐</mn></msup></math> are the weights of the second
one.</p>
</div>
</section>
<section id="S4.SS0.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">In Mathematical Notation</h5>

<div id="S4.SS0.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">From this point on, we will abandon the brain metaphor and describe networks exclusively
in terms of vector-matrix operations.</p>
</div>
<div id="S4.SS0.SSS0.Px2.p2" class="ltx_para ltx_noindent">
<p class="ltx_p">The simplest neural network is the perceptron, which is a linear function of its inputs:</p>
</div>
<div id="S4.SS0.SSS0.Px2.p3" class="ltx_para">
<table id="S4.Ex3" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex3.m1" class="ltx_Math" alttext="NN_{Perceptron}(\mathbf{x})=\mathbf{x}\mathbf{W}+\mathbf{b}" display="block"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>P</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>p</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM37">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>𝐱𝐖</mi><mo>+</mo><mi>𝐛</mi></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<table id="S4.Ex4" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex4.m1" class="ltx_Math" alttext="\mathbf{x}\in\mathbb{R}^{d_{in}},\;\;\mathbf{W}\in\mathbb{R}^{d_{in}\times d_{%
out}},\;\;\mathbf{b}\in\mathbb{R}^{d_{out}}" display="block"><mrow><mrow id="XM40"><mi>𝐱</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></msup></mrow><mo rspace="8.1pt">,</mo><mrow><mrow id="XM38"><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></msup></mrow><mo rspace="8.1pt">,</mo><mrow id="XM39"><mi>𝐛</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></msup></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS0.SSS0.Px2.p4" class="ltx_para ltx_noindent">
<p class="ltx_p"><math id="S4.SS0.SSS0.Px2.p4.m1" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math> is the weight matrix, and <math id="S4.SS0.SSS0.Px2.p4.m2" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math> is a bias term.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">6</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">6</sup>The
network in figure <a href="#S4.F2" title="Figure 2 ‣ A Brain-inspired metaphor ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> does not include bias terms. A bias term can be
added to a layer by adding to it an additional neuron that does not have any incoming connections,
whose value is always <math id="S4.SS0.SSS0.Px2.p4.m3" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>.</span></span></span>
In order to go beyond linear functions, we introduce a non-linear hidden layer (the network in Figure <a href="#S4.F2" title="Figure 2 ‣ A Brain-inspired metaphor ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> has two such layers),
resulting in the 1-layer Multi Layer Perceptron (MLP1).
A one-layer feed-forward neural network has the form:</p>
</div>
<div id="S4.SS0.SSS0.Px2.p5" class="ltx_para">
<table id="S4.Ex5" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex5.m1" class="ltx_Math" alttext="NN_{MLP1}(\mathbf{x})=g(\mathbf{x}\mathbf{W^{1}}+\mathbf{b^{1}})\mathbf{W^{2}}%
+\mathbf{b^{2}}" display="block"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM42">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM43"><msup><mi>𝐱𝐖</mi><mn>𝟏</mn></msup><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟐</mn></msup></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<table id="S4.Ex6" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex6.m1" class="ltx_Math" alttext="\mathbf{x}\in\mathbb{R}^{d_{in}},\;\;\mathbf{W^{1}}\in\mathbb{R}^{d_{in}\times
d%
_{1}},\;\;\mathbf{b^{1}}\in\mathbb{R}^{d_{1}},\;\;\mathbf{W^{2}}\in\mathbb{R}^%
{d_{1}\times d_{2}},\;\;\mathbf{b^{2}}\in\mathbb{R}^{d_{2}}" display="block"><mrow><mrow id="XM50"><mi>𝐱</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></msup></mrow><mo rspace="8.1pt">,</mo><mrow><mrow id="XM48"><msup><mi>𝐖</mi><mn>𝟏</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></msup></mrow><mo rspace="8.1pt">,</mo><mrow><mrow id="XM46"><msup><mi>𝐛</mi><mn>𝟏</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mn>1</mn></msub></msup></mrow><mo rspace="8.1pt">,</mo><mrow><mrow id="XM44"><msup><mi>𝐖</mi><mn>𝟐</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mn>1</mn></msub><mo>×</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></msup></mrow><mo rspace="8.1pt">,</mo><mrow id="XM45"><msup><mi>𝐛</mi><mn>𝟐</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mn>2</mn></msub></msup></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS0.SSS0.Px2.p6" class="ltx_para">
<p class="ltx_p">Here <math id="S4.SS0.SSS0.Px2.p6.m1" class="ltx_Math" alttext="\mathbf{W^{1}}" display="inline"><msup><mi>𝐖</mi><mn>𝟏</mn></msup></math> and <math id="S4.SS0.SSS0.Px2.p6.m2" class="ltx_Math" alttext="\mathbf{b^{1}}" display="inline"><msup><mi>𝐛</mi><mn>𝟏</mn></msup></math> are a matrix and a bias term for the first linear
transformation of the input, <math id="S4.SS0.SSS0.Px2.p6.m3" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> is a non-linear function that is applied element-wise
(also called a <em class="ltx_emph">non-linearity</em> or an <em class="ltx_emph">activation function</em>), and
<math id="S4.SS0.SSS0.Px2.p6.m4" class="ltx_Math" alttext="\mathbf{W^{2}}" display="inline"><msup><mi>𝐖</mi><mn>𝟐</mn></msup></math> and <math id="S4.SS0.SSS0.Px2.p6.m5" class="ltx_Math" alttext="\mathbf{b^{2}}" display="inline"><msup><mi>𝐛</mi><mn>𝟐</mn></msup></math> are the matrix and bias term for a second linear transform.</p>
</div>
<div id="S4.SS0.SSS0.Px2.p7" class="ltx_para">
<p class="ltx_p">Breaking it down, <math id="S4.SS0.SSS0.Px2.p7.m1" class="ltx_Math" alttext="\mathbf{x}\mathbf{W^{1}}+\mathbf{b^{1}}" display="inline"><mrow><msup><mi>𝐱𝐖</mi><mn>𝟏</mn></msup><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow></math> is a linear transformation of the input <math id="S4.SS0.SSS0.Px2.p7.m2" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>
from <math id="S4.SS0.SSS0.Px2.p7.m3" class="ltx_Math" alttext="d_{in}" display="inline"><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></math> dimensions to <math id="S4.SS0.SSS0.Px2.p7.m4" class="ltx_Math" alttext="d_{1}" display="inline"><msub><mi>d</mi><mn>1</mn></msub></math> dimensions. <math id="S4.SS0.SSS0.Px2.p7.m5" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> is then applied to each of the
<math id="S4.SS0.SSS0.Px2.p7.m6" class="ltx_Math" alttext="d_{1}" display="inline"><msub><mi>d</mi><mn>1</mn></msub></math> dimensions, and the matrix <math id="S4.SS0.SSS0.Px2.p7.m7" class="ltx_Math" alttext="\mathbf{W^{2}}" display="inline"><msup><mi>𝐖</mi><mn>𝟐</mn></msup></math> together with bias vector <math id="S4.SS0.SSS0.Px2.p7.m8" class="ltx_Math" alttext="\mathbf{b}^{2}" display="inline"><msup><mi>𝐛</mi><mn>2</mn></msup></math> are then
used to transform the result into the <math id="S4.SS0.SSS0.Px2.p7.m9" class="ltx_Math" alttext="d_{2}" display="inline"><msub><mi>d</mi><mn>2</mn></msub></math> dimensional output vector.
The non-linear activation function <math id="S4.SS0.SSS0.Px2.p7.m10" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> has a crucial role in the network’s
ability to represent complex functions. Without the non-linearity in <math id="S4.SS0.SSS0.Px2.p7.m11" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math>, the
neural network can only represent linear transformations of the
input.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">7</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">7</sup>To see why, consider that a sequence of linear transformations
is still a linear transformation.</span></span></span></p>
</div>
<div id="S4.SS0.SSS0.Px2.p8" class="ltx_para">
<p class="ltx_p">We can add additional linear-transformations and non-linearities, resulting in a
2-layer MLP (the network in Figure <a href="#S4.F2" title="Figure 2 ‣ A Brain-inspired metaphor ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> is of this form):</p>
</div>
<div id="S4.SS0.SSS0.Px2.p9" class="ltx_para">
<table id="S4.Ex7" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex7.m1" class="ltx_Math" alttext="NN_{MLP2}(\mathbf{x})=(g^{2}(g^{1}(\mathbf{x}\mathbf{W^{1}}+\mathbf{b^{1}})%
\mathbf{W^{2}}+\mathbf{b^{2}}))\mathbf{W^{3}}" display="block"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>2</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM52">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM59"><msup><mi>g</mi><mn>2</mn></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM58"><mrow><msup><mi>g</mi><mn>1</mn></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM57"><msup><mi>𝐱𝐖</mi><mn>𝟏</mn></msup><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟐</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟑</mn></msup></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS0.SSS0.Px2.p10" class="ltx_para ltx_noindent">
<p class="ltx_p">It is perhaps clearer to write deeper networks like this using intermediary
variables:</p>
</div>
<div id="S4.SS0.SSS0.Px2.p11" class="ltx_para">
<table id="S13.EGx1" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex8" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex8.m1" class="ltx_Math" alttext="\displaystyle NN_{MLP2}(\mathbf{x})=" display="inline"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>2</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM61">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex8.m2" class="ltx_Math" alttext="\displaystyle\mathbf{y}" display="inline"><mi>𝐲</mi></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex9" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex9.m1" class="ltx_Math" alttext="\displaystyle\mathbf{h^{1}}=" display="inline"><mrow><msup><mi>𝐡</mi><mn>𝟏</mn></msup><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex9.m2" class="ltx_Math" alttext="\displaystyle g^{1}(\mathbf{x}\mathbf{W^{1}}+\mathbf{b^{1}})" display="inline"><mrow><msup><mi>g</mi><mn>1</mn></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM63"><msup><mi>𝐱𝐖</mi><mn>𝟏</mn></msup><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex10" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex10.m1" class="ltx_Math" alttext="\displaystyle\mathbf{h^{2}}=" display="inline"><mrow><msup><mi>𝐡</mi><mn>𝟐</mn></msup><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex10.m2" class="ltx_Math" alttext="\displaystyle g^{2}(\mathbf{h^{1}}\mathbf{W^{2}}+\mathbf{b^{2}})" display="inline"><mrow><msup><mi>g</mi><mn>2</mn></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM65"><mrow><msup><mi>𝐡</mi><mn>𝟏</mn></msup><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟐</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex11" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex11.m1" class="ltx_Math" alttext="\displaystyle\mathbf{y}=" display="inline"><mrow><mi>𝐲</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex11.m2" class="ltx_Math" alttext="\displaystyle\mathbf{h^{2}}\mathbf{W^{3}}" display="inline"><mrow><msup><mi>𝐡</mi><mn>𝟐</mn></msup><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟑</mn></msup></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS0.SSS0.Px2.p12" class="ltx_para">
<p class="ltx_p">The vector resulting from each linear transform is referred to as a <em class="ltx_emph">layer</em>.
The outer-most linear transform results in the <em class="ltx_emph">output layer</em> and the other
linear transforms result in <em class="ltx_emph">hidden layers</em>. Each hidden layer is followed
by a non-linear activation.
In some cases, such as in the last layer of our example,
the bias vectors are forced to 0 (“dropped”).</p>
</div>
<div id="S4.SS0.SSS0.Px2.p13" class="ltx_para">
<p class="ltx_p">Layers resulting from linear transformations are often referred to as <em class="ltx_emph">fully
connected</em>, or <em class="ltx_emph">affine</em>.
Other types of architectures exist.
In particular, image
recognition problems benefit from <em class="ltx_emph">convolutional</em> and <em class="ltx_emph">pooling</em> layers.
Such layers have uses also in language processing, and will be discussed in
Section <a href="#S9" title="9 Convolutional Layers ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>. Networks with more than one hidden layer are said to
be <em class="ltx_emph">deep</em> networks, hence the name <em class="ltx_emph">deep learning</em>.</p>
</div>
<div id="S4.SS0.SSS0.Px2.p14" class="ltx_para">
<p class="ltx_p">When describing a neural network, one should specify the <em class="ltx_emph">dimensions</em> of
the layers and the input. A layer will expect a <math id="S4.SS0.SSS0.Px2.p14.m1" class="ltx_Math" alttext="d_{in}" display="inline"><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></math> dimensional vector as
its input, and transform it into a <math id="S4.SS0.SSS0.Px2.p14.m2" class="ltx_Math" alttext="d_{out}" display="inline"><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math> dimensional vector. The
dimensionality of the layer is taken to be the dimensionality of its output.
For a fully connected layer <math id="S4.SS0.SSS0.Px2.p14.m3" class="ltx_Math" alttext="l(\mathbf{x})=\mathbf{x}\mathbf{W}+\mathbf{b}" display="inline"><mrow><mrow><mi>l</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM66">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>𝐱𝐖</mi><mo>+</mo><mi>𝐛</mi></mrow></mrow></math> with input
dimensionality <math id="S4.SS0.SSS0.Px2.p14.m4" class="ltx_Math" alttext="d_{in}" display="inline"><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></math> and output dimensionality <math id="S4.SS0.SSS0.Px2.p14.m5" class="ltx_Math" alttext="d_{out}" display="inline"><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math>, the dimensions of
<math id="S4.SS0.SSS0.Px2.p14.m6" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> is <math id="S4.SS0.SSS0.Px2.p14.m7" class="ltx_Math" alttext="1\times d_{in}" display="inline"><mrow><mn>1</mn><mo>×</mo><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></mrow></math>, of <math id="S4.SS0.SSS0.Px2.p14.m8" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math> is <math id="S4.SS0.SSS0.Px2.p14.m9" class="ltx_Math" alttext="d_{in}\times d_{out}" display="inline"><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></math> and of <math id="S4.SS0.SSS0.Px2.p14.m10" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math>
is <math id="S4.SS0.SSS0.Px2.p14.m11" class="ltx_Math" alttext="1\times d_{out}" display="inline"><mrow><mn>1</mn><mo>×</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></math>.</p>
</div>
<div id="S4.SS0.SSS0.Px2.p15" class="ltx_para">
<p class="ltx_p">The output of the network is a <math id="S4.SS0.SSS0.Px2.p15.m1" class="ltx_Math" alttext="d_{out}" display="inline"><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math> dimensional vector. In case <math id="S4.SS0.SSS0.Px2.p15.m2" class="ltx_Math" alttext="d_{out}=1" display="inline"><mrow><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow></math>, the network’s output is a scalar. Such networks can be used for regression
(or scoring)
by considering the value of the output, or for binary
classification by consulting the sign of the output. Networks with <math id="S4.SS0.SSS0.Px2.p15.m3" class="ltx_Math" alttext="d_{out}=k&gt;1" display="inline"><mrow><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>=</mo><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow></math> can be used for <math id="S4.SS0.SSS0.Px2.p15.m4" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-class classification, by associating each dimension
with a class, and looking for the dimension with maximal value. Similarly, if
the output vector entries are positive and sum to one, the output can be
interpreted as a distribution over class assignments (such output
normalization is typically achieved by applying a softmax transformation on
the output layer, see Section <a href="#S4.SS3" title="4.3 Output Transformations ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.3</span></a>).</p>
</div>
<div id="S4.SS0.SSS0.Px2.p16" class="ltx_para">
<p class="ltx_p">The matrices and the bias terms that define the linear transformations are the
<em class="ltx_emph">parameters</em> of the network. It is common to refer to the collection of all
parameters as <math id="S4.SS0.SSS0.Px2.p16.m1" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>. Together with the input, the parameters
determine the network’s output. The training algorithm is responsible for
setting their values such that the network’s predictions are correct.
Training is discussed in Section <a href="#S6" title="6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.</p>
</div>
</section>
<section id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.1 </span>Representation Power</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p class="ltx_p">In terms of representation power, it was shown
by <cite class="ltx_cite">[]</cite> that MLP1 is a universal
approximator – it can approximate with any desired non-zero amount of error a
family of functions<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">8</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">8</sup>Specifically, a feed-forward network with linear
output layer and at least one hidden layer with a “squashing” activation function
can approximate any Borel measurable function from one finite dimensional space to another.</span></span></span>
that include all continuous functions on a closed and bounded
subset of <math id="S4.SS1.p1.m1" class="ltx_Math" alttext="\mathbb{R}^{n}" display="inline"><msup><mi>ℝ</mi><mi>n</mi></msup></math>, and any function mapping from any finite dimensional
discrete space to another. This may suggest there is no reason to go
beyond MLP1 to more complex architectures. However, the theoretical result does not state
how large the hidden layer should be, nor does it say anything about the
learnability of the neural network (it states that a representation exists, but
does not say how easy or hard it is to set the parameters based on training data
and a specific learning algorithm). It also does not guarantee that a
training algorithm will find the <em class="ltx_emph">correct</em> function generating our training data.
Since in practice we train neural networks on relatively small amounts of data,
using a combination of the backpropagation algorithm and variants of stochastic gradient descent,
and use hidden layers of relatively modest sizes (up to several thousands), there is
benefit to be had in trying out more complex architectures than MLP1.
In many
cases, however, MLP1 does indeed provide very strong results.
For further discussion on the representation power of feed-forward neural
networks, see <cite class="ltx_cite">[, Section 6.5]</cite>.</p>
</div>
</section>
<section id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.2 </span>Common Non-linearities</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p class="ltx_p">The non-linearity <math id="S4.SS2.p1.m1" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> can take many forms. There is currently no good theory as
to which non-linearity to apply in which conditions, and choosing the correct
non-linearity for a given task is for the most part an empirical question. I
will now go over the common non-linearities from the literature: the sigmoid,
tanh, hard tanh and the rectified linear unit (ReLU). Some NLP researchers also
experimented with other forms of non-linearities such as cube and tanh-cube.</p>
</div>
<section id="S4.SS2.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Sigmoid</h5>

<div id="S4.SS2.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">The sigmoid activation function <math id="S4.SS2.SSS0.Px1.p1.m1" class="ltx_Math" alttext="\sigma(x)=1/(1+e^{-x})" display="inline"><mrow><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM67">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>/</mo><mrow><mo stretchy="false">(</mo><mrow id="XM68"><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math> is an
S-shaped function, transforming each value <math id="S4.SS2.SSS0.Px1.p1.m2" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> into the range <math id="S4.SS2.SSS0.Px1.p1.m3" class="ltx_Math" alttext="[0,1]" display="inline"><mrow><mo stretchy="false">[</mo><mn id="XM69">0</mn><mo>,</mo><mn id="XM70">1</mn><mo stretchy="false">]</mo></mrow></math>.</p>
</div>
</section>
<section id="S4.SS2.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Hyperbolic tangent (tanh)</h5>

<div id="S4.SS2.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">The hyperbolic tangent <math id="S4.SS2.SSS0.Px2.p1.m1" class="ltx_Math" alttext="tanh(x)=\frac{e^{2x}-1}{e^{2x}+1}" display="inline"><mrow><mrow><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM71">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mrow><mn>2</mn><mo>⁢</mo><mi>x</mi></mrow></msup><mo>-</mo><mn>1</mn></mrow><mrow><msup><mi>e</mi><mrow><mn>2</mn><mo>⁢</mo><mi>x</mi></mrow></msup><mo>+</mo><mn>1</mn></mrow></mfrac></mrow></math> activation
function is an S-shaped function, transforming the values <math id="S4.SS2.SSS0.Px2.p1.m2" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> into the range <math id="S4.SS2.SSS0.Px2.p1.m3" class="ltx_Math" alttext="[-1,1]" display="inline"><mrow><mo stretchy="false">[</mo><mrow id="XM72"><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mn id="XM73">1</mn><mo stretchy="false">]</mo></mrow></math>.</p>
</div>
</section>
<section id="S4.SS2.SSS0.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Hard tanh</h5>

<div id="S4.SS2.SSS0.Px3.p1" class="ltx_para">
<p class="ltx_p">The hard-tanh activation function is an approximation of
the <math id="S4.SS2.SSS0.Px3.p1.m1" class="ltx_Math" alttext="tanh" display="inline"><mrow><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi></mrow></math> function which is faster to compute and take derivatives of:</p>
<table id="S13.EGx2" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex12" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex12.m1" class="ltx_Math" alttext="\displaystyle hardtanh(x)=\begin{cases}-1&amp;x&lt;-1\\
1&amp;x&gt;1\\
x&amp;\text{otherwise}\end{cases}" display="inline"><mrow><mrow><mi>h</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM75">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable><mtr><mtd columnalign="left"><mrow id="XM5"><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign="left"><mrow id="XM6"><mi>x</mi><mo>&lt;</mo><mrow><mo>-</mo><mn>1</mn></mrow></mrow></mtd></mtr><mtr><mtd columnalign="left"><mn id="XM7">1</mn></mtd><mtd columnalign="left"><mrow id="XM8"><mi>x</mi><mo>&gt;</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mi id="XM9">x</mi></mtd><mtd columnalign="left"><mtext id="XM10">otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</section>
<section id="S4.SS2.SSS0.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Rectifier (ReLU)</h5>

<div id="S4.SS2.SSS0.Px4.p1" class="ltx_para">
<p class="ltx_p">The Rectifier activation function <cite class="ltx_cite">[]</cite>, also known as
the rectified linear unit is a very simple activation function that is easy to
work with and was shown many times to produce excellent results.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">9</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">9</sup>The technical
advantages of the ReLU over the sigmoid and tanh activation functions is that it
does not involve expensive-to-compute functions, and more importantly that it
does not saturate. The sigmoid and tanh activation are capped at <math id="S4.SS2.SSS0.Px4.p1.m1" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>, and
the gradients at this region of the functions are near zero, driving the entire
gradient near zero. The ReLU activation does not have this problem, making it
especially suitable for networks with multiple layers, which are
susceptible to the vanishing gradients problem when trained with the saturating
units.</span></span></span>
The ReLU unit
clips each value <math id="S4.SS2.SSS0.Px4.p1.m2" class="ltx_Math" alttext="x&lt;0" display="inline"><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></math> at 0. Despite its simplicity, it performs well for many
tasks, especially when combined with the dropout regularization technique
(see Section <a href="#S6.SS4" title="6.4 Regularization ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.4</span></a>).</p>
</div>
<div id="S4.SS2.SSS0.Px4.p2" class="ltx_para">
<table id="S13.EGx3" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex13" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex13.m1" class="ltx_Math" alttext="\displaystyle ReLU(x)=\max(0,x)=\begin{cases}0&amp;x&lt;0\\
x&amp;\text{otherwise}\end{cases}" display="inline"><mrow><mrow><mi>R</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>U</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM80">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM81">max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn id="XM82">0</mn><mo>,</mo><mi id="XM83">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable><mtr><mtd columnalign="left"><mn id="XM11">0</mn></mtd><mtd columnalign="left"><mrow id="XM12"><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mi id="XM13">x</mi></mtd><mtd columnalign="left"><mtext id="XM14">otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS2.SSS0.Px4.p3" class="ltx_para">
<p class="ltx_p">As a rule of thumb, ReLU units work better than tanh, and tanh works better than
sigmoid.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">10</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">10</sup>
In addition to these activation functions, recent works from the NLP community
experiment with and reported success with other forms of non-linearities.
The <span class="ltx_text ltx_font_bold">Cube</span> activation function, <math id="S4.SS2.SSS0.Px4.p3.m1" class="ltx_Math" alttext="g(x)=(x)^{3}" display="inline"><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM84">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><mi id="XM85">x</mi><mo stretchy="false">)</mo></mrow><mn>3</mn></msup></mrow></math>, was suggested by
<cite class="ltx_cite">[]</cite>, who found it to be more effective than other non-linearities
in a feed-forward network that was used to predict the actions in a greedy
transition-based dependency parser.
The <span class="ltx_text ltx_font_bold">tanh cube</span> activation function <math id="S4.SS2.SSS0.Px4.p3.m2" class="ltx_Math" alttext="g(x)=\tanh((x)^{3}+x)" display="inline"><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM86">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM88">tanh</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow id="XM89"><msup><mrow><mo stretchy="false">(</mo><mi id="XM87">x</mi><mo stretchy="false">)</mo></mrow><mn>3</mn></msup><mo>+</mo><mi>x</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math> was proposed by <cite class="ltx_cite">[]</cite>,
who found it to be more effective than other non-linearities
in a feed-forward network that was used as a component in a
structured-prediction graph-based dependency parser.
The cube and tanh-cube activation functions are motivated by the desire
to better capture interactions between different features.
While these activation functions are reported to improve performance in certain
situations, their general applicability is still to be determined.</span></span></span></p>
</div>
</section>
</section>
<section id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.3 </span>Output Transformations</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p class="ltx_p">In many cases, the output layer vector is also transformed.
A common transformation is the <em class="ltx_emph">softmax</em>:</p>
</div>
<div id="S4.SS3.p2" class="ltx_para">
<table id="S13.EGx4" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex14" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex14.m1" class="ltx_Math" alttext="\displaystyle\mathbf{x}=" display="inline"><mrow><mi>𝐱</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex14.m2" class="ltx_Math" alttext="\displaystyle x_{1},\ldots,x_{k}" display="inline"><mrow><msub id="XM93"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM94">…</mi><mo>,</mo><msub id="XM95"><mi>x</mi><mi>k</mi></msub></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex15" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex15.m1" class="ltx_Math" alttext="\displaystyle softmax(x_{i})=" display="inline"><mrow><mrow><mi>s</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM97"><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex15.m2" class="ltx_Math" alttext="\displaystyle\frac{e^{x_{i}}}{\sum_{j=1}^{k}e^{x_{j}}}" display="inline"><mstyle displaystyle="true"><mfrac><msup><mi>e</mi><msub><mi>x</mi><mi>i</mi></msub></msup><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msup><mi>e</mi><msub><mi>x</mi><mi>j</mi></msub></msup></mrow></mfrac></mstyle></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS3.p3" class="ltx_para">
<p class="ltx_p">The result is a vector of non-negative real numbers that sum to one, making it a
discrete probability distribution over <math id="S4.SS3.p3.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> possible outcomes.</p>
</div>
<div id="S4.SS3.p4" class="ltx_para">
<p class="ltx_p">The <math id="S4.SS3.p4.m1" class="ltx_Math" alttext="softmax" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi></mrow></math> output transformation is used when we are
interested in modeling a probability distribution over the possible output
classes. To be effective, it should be used in conjunction with a probabilistic
training objective such as cross-entropy (see Section <a href="#S4.SS5.SSS0.Px4" title="Categorical cross-entropy loss ‣ 4.5 Loss Functions ‣ 4 Feed-forward Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.5</span></a> below).</p>
</div>
<div id="S4.SS3.p5" class="ltx_para">
<p class="ltx_p">When the softmax transformation is applied to the output of a network without a
hidden layer, the result is the well known multinomial logistic regression
model, also known as a maximum-entropy classifier.</p>
</div>
</section>
<section id="S4.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.4 </span>Embedding Layers</h3>

<div id="S4.SS4.p1" class="ltx_para">
<p class="ltx_p">Up until now, the discussion ignored the source of <math id="S4.SS4.p1.m1" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>, treating it as an arbitrary
vector. In an NLP application, <math id="S4.SS4.p1.m2" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> is usually composed of various embeddings
vectors.
We can be explicit about the source of <math id="S4.SS4.p1.m3" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>, and include it in the network’s definition.
We introduce <math id="S4.SS4.p1.m4" class="ltx_Math" alttext="c(\cdot)" display="inline"><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo id="XM98">⋅</mo><mo stretchy="false">)</mo></mrow></mrow></math>, a function from core features to an input vector.</p>
</div>
<div id="S4.SS4.p2" class="ltx_para">
<p class="ltx_p">It is common for <math id="S4.SS4.p2.m1" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> to extract the embedding vector associated with each feature, and concatenate them:</p>
</div>
<div id="S4.SS4.p3" class="ltx_para">
<table id="S13.EGx5" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex16" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex16.m1" class="ltx_Math" alttext="\displaystyle\mathbf{x}=c(f_{1},f_{2},f_{3})=" display="inline"><mrow><mi>𝐱</mi><mo>=</mo><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM108"><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub id="XM109"><mi>f</mi><mn>2</mn></msub><mo>,</mo><msub id="XM110"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex16.m2" class="ltx_Math" alttext="\displaystyle[v(f_{1});v(f_{2});v(f_{3})]" display="inline"><mrow><mo stretchy="false">[</mo><mrow id="XM114"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM111"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM115"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM112"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM116"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM113"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">]</mo></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex17" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex17.m1" class="ltx_Math" alttext="\displaystyle NN_{MLP1}(\mathbf{x})=" display="inline"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM128">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex17.m2" class="ltx_Math" alttext="\displaystyle NN_{MLP1}(c(f_{1},f_{2},f_{3}))" display="inline"><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM138"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM135"><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub id="XM136"><mi>f</mi><mn>2</mn></msub><mo>,</mo><msub id="XM137"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex18" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex18.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex18.m2" class="ltx_Math" alttext="\displaystyle NN_{MLP1}([v(f_{1});v(f_{2});v(f_{3})])" display="inline"><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">[</mo><mrow id="XM185"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM182"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM186"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM183"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM187"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM184"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">]</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex19" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex19.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex19.m2" class="ltx_Math" alttext="\displaystyle(g([v(f_{1});v(f_{2});v(f_{3})]\mathbf{W^{1}}+\mathbf{b^{1}}))%
\mathbf{W^{2}}+\mathbf{b^{2}}" display="inline"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM264"><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM263"><mrow><mrow><mo stretchy="false">[</mo><mrow id="XM260"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM257"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM261"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM258"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM262"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM259"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟏</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟐</mn></msup></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS4.p4" class="ltx_para">
<p class="ltx_p">Another common choice is for <math id="S4.SS4.p4.m1" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> to sum the embedding vectors (this assumes the
embedding vectors all share the same dimensionality):</p>
</div>
<div id="S4.SS4.p5" class="ltx_para">
<table id="S13.EGx6" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex20" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex20.m1" class="ltx_Math" alttext="\displaystyle\mathbf{x}=c(f_{1},f_{2},f_{3})=" display="inline"><mrow><mi>𝐱</mi><mo>=</mo><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM271"><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub id="XM272"><mi>f</mi><mn>2</mn></msub><mo>,</mo><msub id="XM273"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex20.m2" class="ltx_Math" alttext="\displaystyle v(f_{1})+v(f_{2})+v(f_{3})" display="inline"><mrow><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM274"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM275"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM276"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex21" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex21.m1" class="ltx_Math" alttext="\displaystyle NN_{MLP1}(\mathbf{x})=" display="inline"><mrow><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM288">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex21.m2" class="ltx_Math" alttext="\displaystyle NN_{MLP1}(c(f_{1},f_{2},f_{3}))" display="inline"><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM298"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM295"><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub id="XM296"><mi>f</mi><mn>2</mn></msub><mo>,</mo><msub id="XM297"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex22" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex22.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex22.m2" class="ltx_Math" alttext="\displaystyle NN_{MLP1}(v(f_{1})+v(f_{2})+v(f_{3}))" display="inline"><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM314"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM311"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM312"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM313"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S4.Ex23" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S4.Ex23.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S4.Ex23.m2" class="ltx_Math" alttext="\displaystyle(g((v(f_{1})+v(f_{2})+v(f_{3}))\mathbf{W^{1}}+\mathbf{b^{1}}))%
\mathbf{W^{2}}+\mathbf{b^{2}}" display="inline"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM366"><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM365"><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM364"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM361"><mi>f</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM362"><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM363"><mi>f</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟏</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟐</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟐</mn></msup></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS4.p6" class="ltx_para">
<p class="ltx_p">The form of <math id="S4.SS4.p6.m1" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> is an essential part of the network’s design.
In many papers, it is common to refer to <math id="S4.SS4.p6.m2" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> as part of the network,
and likewise treat the word embeddings <math id="S4.SS4.p6.m3" class="ltx_Math" alttext="v(f_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM367"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> as resulting
from an “embedding layer” or “lookup layer”. Consider a vocabulary of <math id="S4.SS4.p6.m4" class="ltx_Math" alttext="|V|" display="inline"><mrow><mo stretchy="false">|</mo><mi id="XM368">V</mi><mo stretchy="false">|</mo></mrow></math>
words, each embedded as a <math id="S4.SS4.p6.m5" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> dimensional vector. The collection of vectors can
then be thought of as a <math id="S4.SS4.p6.m6" class="ltx_Math" alttext="|V|\times d" display="inline"><mrow><mrow><mo stretchy="false">|</mo><mi id="XM369">V</mi><mo stretchy="false">|</mo></mrow><mo>×</mo><mi>d</mi></mrow></math> embedding matrix <math id="S4.SS4.p6.m7" class="ltx_Math" alttext="\mathbf{E}" display="inline"><mi>𝐄</mi></math> in which each row
corresponds to an embedded feature.
Let <math id="S4.SS4.p6.m8" class="ltx_Math" alttext="\mathbf{f_{i}}" display="inline"><msub><mi>𝐟</mi><mi>𝐢</mi></msub></math> be a <math id="S4.SS4.p6.m9" class="ltx_Math" alttext="|V|" display="inline"><mrow><mo stretchy="false">|</mo><mi id="XM370">V</mi><mo stretchy="false">|</mo></mrow></math>-dimensional vector, which is all zeros except from one
index, corresponding to the value of the <math id="S4.SS4.p6.m10" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>th feature, in which the value is
<math id="S4.SS4.p6.m11" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math> (this is called a one-hot vector). The multiplication <math id="S4.SS4.p6.m12" class="ltx_Math" alttext="\mathbf{f_{i}}\mathbf{E}" display="inline"><mrow><msub><mi>𝐟</mi><mi>𝐢</mi></msub><mo>⁢</mo><mi>𝐄</mi></mrow></math> will then
“select” the corresponding row of <math id="S4.SS4.p6.m13" class="ltx_Math" alttext="\mathbf{E}" display="inline"><mi>𝐄</mi></math>. Thus, <math id="S4.SS4.p6.m14" class="ltx_Math" alttext="v(f_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM371"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> can be defined in
terms of <math id="S4.SS4.p6.m15" class="ltx_Math" alttext="\mathbf{E}" display="inline"><mi>𝐄</mi></math> and <math id="S4.SS4.p6.m16" class="ltx_Math" alttext="\mathbf{f_{i}}" display="inline"><msub><mi>𝐟</mi><mi>𝐢</mi></msub></math>:</p>
<table id="S4.Ex24" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex24.m1" class="ltx_Math" alttext="v(f_{i})=\mathbf{f_{i}}\mathbf{E}" display="block"><mrow><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM372"><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>𝐟</mi><mi>𝐢</mi></msub><mo>⁢</mo><mi>𝐄</mi></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS4.p7" class="ltx_para">
<p class="ltx_p">And similarly:</p>
</div>
<div id="S4.SS4.p8" class="ltx_para">
<table id="S4.Ex25" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex25.m1" class="ltx_Math" alttext="CBOW(f_{1},...,f_{k})=\sum_{i=1}^{k}(\mathbf{f_{i}}\mathbf{E})=(\sum_{i=1}^{k}%
\mathbf{f_{i}})\mathbf{E}" display="block"><mrow><mrow><mi>C</mi><mo>⁢</mo><mi>B</mi><mo>⁢</mo><mi>O</mi><mo>⁢</mo><mi>W</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM373"><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM374">…</mi><mo>,</mo><msub id="XM375"><mi>f</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow><mo stretchy="false">(</mo><mrow id="XM376"><msub><mi>𝐟</mi><mi>𝐢</mi></msub><mo>⁢</mo><mi>𝐄</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM377"><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>𝐟</mi><mi>𝐢</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>𝐄</mi></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS4.p9" class="ltx_para">
<p class="ltx_p">The input to the network is then considered to be a collection of one-hot
vectors. While this is elegant and well defined mathematically, an efficient
implementation typically involves a hash-based data structure mapping features
to their corresponding embedding vectors, without going through the one-hot
representation.</p>
</div>
<div id="S4.SS4.p10" class="ltx_para">
<p class="ltx_p">In this tutorial, we take <math id="S4.SS4.p10.m1" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> to be separate from the
network architecture: the network’s inputs are always dense real-valued input
vectors, and <math id="S4.SS4.p10.m2" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math> is applied before the input is passed the network, similar to a
“feature function” in the familiar linear-models terminology. However, when
training a network, the input vector <math id="S4.SS4.p10.m3" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> does remember how it was
constructed, and can propagate error gradients back to its component embedding
vectors, as appropriate.</p>
</div>
<section id="S4.SS4.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">A note on notation</h5>

<div id="S4.SS4.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">When describing network layers that get
concatenated vectors <math id="S4.SS4.SSS0.Px1.p1.m1" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>, <math id="S4.SS4.SSS0.Px1.p1.m2" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math> and <math id="S4.SS4.SSS0.Px1.p1.m3" class="ltx_Math" alttext="\mathbf{z}" display="inline"><mi>𝐳</mi></math> as input, some authors
use explicit concatenation
(<math id="S4.SS4.SSS0.Px1.p1.m4" class="ltx_Math" alttext="[\mathbf{x};\mathbf{y};\mathbf{z}]\mathbf{W}+\mathbf{b}" display="inline"><mrow><mrow><mrow><mo stretchy="false">[</mo><mi id="XM378">𝐱</mi><mo>;</mo><mi id="XM379">𝐲</mi><mo>;</mo><mi id="XM380">𝐳</mi><mo stretchy="false">]</mo></mrow><mo>⁢</mo><mi>𝐖</mi></mrow><mo>+</mo><mi>𝐛</mi></mrow></math>) while others use an affine transformation
(<math id="S4.SS4.SSS0.Px1.p1.m5" class="ltx_Math" alttext="\mathbf{x}\mathbf{U}+\mathbf{y}\mathbf{V}+\mathbf{z}\mathbf{W}+\mathbf{b})" display="inline"><mrow><mi>𝐱𝐔</mi><mo>+</mo><mi>𝐲𝐕</mi><mo>+</mo><mi>𝐳𝐖</mi><mo>+</mo><mi>𝐛</mi><mo stretchy="false">)</mo></mrow></math>. If the weight matrices
<math id="S4.SS4.SSS0.Px1.p1.m6" class="ltx_Math" alttext="\mathbf{U}" display="inline"><mi>𝐔</mi></math>, <math id="S4.SS4.SSS0.Px1.p1.m7" class="ltx_Math" alttext="\mathbf{V}" display="inline"><mi>𝐕</mi></math>, <math id="S4.SS4.SSS0.Px1.p1.m8" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math> in the affine transformation are different than one
another, the two notations are equivalent.</p>
</div>
</section>
<section id="S4.SS4.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">A note on sparse vs. dense features</h5>

<div id="S4.SS4.SSS0.Px2.p1" class="ltx_para ltx_noindent">
<p class="ltx_p">Consider a network which uses
a “traditional” sparse representation for its input vectors,
and no embedding layer.
Assuming the set of all available features is <math id="S4.SS4.SSS0.Px2.p1.m1" class="ltx_Math" alttext="V" display="inline"><mi>V</mi></math> and we have <math id="S4.SS4.SSS0.Px2.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> “on”
features <math id="S4.SS4.SSS0.Px2.p1.m3" class="ltx_Math" alttext="f_{1},\ldots,f_{k}" display="inline"><mrow><msub id="XM381"><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM382">…</mi><mo>,</mo><msub id="XM383"><mi>f</mi><mi>k</mi></msub></mrow></math>, <math id="S4.SS4.SSS0.Px2.p1.m4" class="ltx_Math" alttext="f_{i}\in V" display="inline"><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>∈</mo><mi>V</mi></mrow></math>,
the network’s input is:</p>
<table id="S4.Ex26" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex26.m1" class="ltx_Math" alttext="\mathbf{x}=\sum_{i=1}^{k}\mathbf{f_{i}}\;\;\;\;\;\;\;\;\;\;\mathbf{x}\in%
\mathbb{N}_{+}^{|V|}" display="block"><mrow><mrow id="XM385"><mi>𝐱</mi><mo>=</mo><mrow><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>𝐟</mi><mi>𝐢</mi></msub></mrow></mrow><mo mathvariant="italic" separator="true">    </mo><mrow id="XM386"><mi>𝐱</mi><mo>∈</mo><msubsup><mi>ℕ</mi><mo>+</mo><mrow><mo stretchy="false">|</mo><mi id="XM384">V</mi><mo stretchy="false">|</mo></mrow></msubsup></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">and so the first layer (ignoring the non-linear activation) is:</p>
<table id="S4.Ex27" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex27.m1" class="ltx_Math" alttext="\mathbf{x}\mathbf{W}+\mathbf{b}=(\sum_{i=1}^{k}\mathbf{f_{i}})\mathbf{W}" display="block"><mrow><mrow><mi>𝐱𝐖</mi><mo>+</mo><mi>𝐛</mi></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM387"><munderover><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>𝐟</mi><mi>𝐢</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>𝐖</mi></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<table id="S4.Ex28" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S4.Ex28.m1" class="ltx_Math" alttext="\mathbf{W}\in\mathbb{R}^{|V|\times d},\;\;\;\mathbf{b}\in\mathbb{R}^{d}" display="block"><mrow><mrow id="XM389"><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mrow><mo stretchy="false">|</mo><mi id="XM388">V</mi><mo stretchy="false">|</mo></mrow><mo>×</mo><mi>d</mi></mrow></msup></mrow><mo rspace="10.9pt">,</mo><mrow id="XM390"><mi>𝐛</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS4.SSS0.Px2.p2" class="ltx_para">
<p class="ltx_p">This layer selects rows of <math id="S4.SS4.SSS0.Px2.p2.m1" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math> corresponding to the input features in
<math id="S4.SS4.SSS0.Px2.p2.m2" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> and sums them, then adding a bias term. This is very similar to
an embedding layer that produces a CBOW representation over the features,
where the matrix <math id="S4.SS4.SSS0.Px2.p2.m3" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math> acts as the embedding matrix. The main difference
is the introduction of the bias vector <math id="S4.SS4.SSS0.Px2.p2.m4" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math>, and the fact that the embedding
layer typically does not undergo a non-linear activation but rather passed on
directly to the first layer. Another difference is that this scenario forces
each feature to receive a separate vector (row in <math id="S4.SS4.SSS0.Px2.p2.m5" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math>) while the embedding
layer provides more flexibility, allowing for example for the features “next
word is dog” and “previous word is dog” to share the same vector. However,
these differences are small and subtle. When it comes to multi-layer
feed-forward networks, the difference between dense and sparse inputs
is smaller than it may seem at first sight.</p>
</div>
</section>
</section>
<section id="S4.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.5 </span>Loss Functions</h3>

<div id="S4.SS5.p1" class="ltx_para">
<p class="ltx_p">When training a neural network (more on training in Section <a href="#S6" title="6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> below),
much like when training a linear classifier,
one defines a loss function <math id="S4.SS5.p1.m1" class="ltx_Math" alttext="L(\mathbf{\hat{y}},\mathbf{y})" display="inline"><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM391"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM392">𝐲</mi><mo stretchy="false">)</mo></mrow></mrow></math>, stating the loss of
predicting <math id="S4.SS5.p1.m2" class="ltx_Math" alttext="\mathbf{\hat{y}}" display="inline"><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover></math> when the true output is <math id="S4.SS5.p1.m3" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math>. The training
objective is then to minimize the loss across the different training examples.
The loss <math id="S4.SS5.p1.m4" class="ltx_Math" alttext="L(\mathbf{\hat{y}},\mathbf{y})" display="inline"><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM393"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM394">𝐲</mi><mo stretchy="false">)</mo></mrow></mrow></math> assigns a numerical score (a scalar) for the
network’s output <math id="S4.SS5.p1.m5" class="ltx_Math" alttext="\mathbf{\hat{y}}" display="inline"><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover></math> given the true expected output
<math id="S4.SS5.p1.m6" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">11</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">11</sup>In our notation, both the model’s output and the expected
output are vectors, while in many cases it is more natural to think of the
expected output as a scalar (class assignment). In such cases, <math id="S4.SS5.p1.m7" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math> is simply
the corresponding one-hot vector.</span></span></span> The loss is always positive, and should be
zero only for cases where the network’s output is correct.
</p>
</div>
<div id="S4.SS5.p2" class="ltx_para">
<p class="ltx_p">The parameters of the network (the matrices <math id="S4.SS5.p2.m1" class="ltx_Math" alttext="\mathbf{W^{i}}" display="inline"><msup><mi>𝐖</mi><mi>𝐢</mi></msup></math>, the biases <math id="S4.SS5.p2.m2" class="ltx_Math" alttext="\mathbf{b^{i}}" display="inline"><msup><mi>𝐛</mi><mi>𝐢</mi></msup></math> and
commonly the embeddings <math id="S4.SS5.p2.m3" class="ltx_Math" alttext="\mathbf{E}" display="inline"><mi>𝐄</mi></math>) are then set in order to minimize the loss <math id="S4.SS5.p2.m4" class="ltx_Math" alttext="L" display="inline"><mi>L</mi></math>
over the training examples (usually, it is the sum of the losses over the
different training examples that is being minimized).</p>
</div>
<div id="S4.SS5.p3" class="ltx_para">
<p class="ltx_p">The loss can be an arbitrary function mapping two vectors to a scalar. For
practical purposes of optimization, we restrict ourselves to functions for which
we can easily compute gradients (or sub-gradients). In most cases, it is
sufficient and advisable to rely on a common loss function rather than defining
your own. For a detailed discussion on loss functions for neural networks see
<cite class="ltx_cite">[]</cite>.
We now discuss some loss functions that are commonly used in neural networks for
NLP.</p>
</div>
<section id="S4.SS5.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Hinge (binary)</h5>

<div id="S4.SS5.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">For binary classification problems, the network’s output is a single scalar
<math id="S4.SS5.SSS0.Px1.p1.m1" class="ltx_Math" alttext="\hat{y}" display="inline"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></math> and the intended output <math id="S4.SS5.SSS0.Px1.p1.m2" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> is in <math id="S4.SS5.SSS0.Px1.p1.m3" class="ltx_Math" alttext="\{+1,-1\}" display="inline"><mrow><mo stretchy="false">{</mo><mrow id="XM397"><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mrow id="XM398"><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow></math>. The classification rule
is <math id="S4.SS5.SSS0.Px1.p1.m4" class="ltx_Math" alttext="sign(\hat{y})" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM399"><mi>y</mi><mo stretchy="false">^</mo></mover><mo stretchy="false">)</mo></mrow></mrow></math>, and a classification is
considered correct if <math id="S4.SS5.SSS0.Px1.p1.m5" class="ltx_Math" alttext="y\cdot\hat{y}&gt;0" display="inline"><mrow><mrow><mi>y</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></mrow><mo>&gt;</mo><mn>0</mn></mrow></math>, meaning that <math id="S4.SS5.SSS0.Px1.p1.m6" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> and <math id="S4.SS5.SSS0.Px1.p1.m7" class="ltx_Math" alttext="\hat{y}" display="inline"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></math> share
the same sign.
The hinge loss, also known as margin loss or SVM loss, is defined as:</p>
<table id="S13.EGx7" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex29" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex29.m1" class="ltx_Math" alttext="\displaystyle L_{hinge(binary)}(\hat{y},y)=\max(0,1-y\cdot\hat{y})" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM406"><mi>b</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM407"><mi>y</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM408">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM409">max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn id="XM410">0</mn><mo>,</mo><mrow id="XM411"><mn>1</mn><mo>-</mo><mrow><mi>y</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px1.p2" class="ltx_para">
<p class="ltx_p">The loss is 0 when <math id="S4.SS5.SSS0.Px1.p2.m1" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> and <math id="S4.SS5.SSS0.Px1.p2.m2" class="ltx_Math" alttext="\hat{y}" display="inline"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></math> share the same sign and <math id="S4.SS5.SSS0.Px1.p2.m3" class="ltx_Math" alttext="|\hat{y}|\geq 1" display="inline"><mrow><mrow><mo stretchy="false">|</mo><mover accent="true" id="XM412"><mi>y</mi><mo stretchy="false">^</mo></mover><mo stretchy="false">|</mo></mrow><mo>≥</mo><mn>1</mn></mrow></math>.
Otherwise, the loss is linear. In other words, the binary hinge loss attempts to achieve a
correct classification, with a margin of at least 1.</p>
</div>
</section>
<section id="S4.SS5.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Hinge (multiclass)</h5>

<div id="S4.SS5.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">The hinge loss was extended to the multiclass setting by Crammer and Singer
<span class="ltx_ERROR undefined">\citeyear</span>crammer2002algorithmic.
Let <math id="S4.SS5.SSS0.Px2.p1.m1" class="ltx_Math" alttext="\mathbf{\hat{y}}=\hat{y}_{1},\ldots,\hat{y}_{n}" display="inline"><mrow><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>=</mo><mrow><msub id="XM413"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM414">…</mi><mo>,</mo><msub id="XM415"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>n</mi></msub></mrow></mrow></math> be the network’s output vector, and
<math id="S4.SS5.SSS0.Px2.p1.m2" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math> be the one-hot vector for the correct output class.</p>
</div>
<div id="S4.SS5.SSS0.Px2.p2" class="ltx_para">
<p class="ltx_p">The classification rule is defined as
selecting the class with the highest score:</p>
<table id="S13.EGx8" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex30" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex30.m1" class="ltx_Math" alttext="\displaystyle\text{prediction}=\arg\max_{i}\hat{y}_{i}" display="inline"><mrow><mtext>prediction</mtext><mo>=</mo><mrow><mi>arg</mi><mo>⁡</mo><mrow><munder><mi>max</mi><mi>i</mi></munder><mo>⁡</mo><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>i</mi></msub></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">,</p>
</div>
<div id="S4.SS5.SSS0.Px2.p3" class="ltx_para">
<p class="ltx_p">Denote by <math id="S4.SS5.SSS0.Px2.p3.m1" class="ltx_Math" alttext="t=\operatorname*{arg\,max}_{i}y_{i}" display="inline"><mrow><mi>t</mi><mo>=</mo><mrow><msub><mrow><mpadded width="+1.7pt"><mi>arg</mi></mpadded><mo>⁢</mo><mi>max</mi></mrow><mi>i</mi></msub><mo>⁡</mo><msub><mi>y</mi><mi>i</mi></msub></mrow></mrow></math> the correct
class, and by <math id="S4.SS5.SSS0.Px2.p3.m2" class="ltx_Math" alttext="k=\operatorname*{arg\,max}_{i\neq t}\hat{y}_{i}" display="inline"><mrow><mi>k</mi><mo>=</mo><mrow><msub><mrow><mpadded width="+1.7pt"><mi>arg</mi></mpadded><mo>⁢</mo><mi>max</mi></mrow><mrow><mi>i</mi><mo>≠</mo><mi>t</mi></mrow></msub><mo>⁡</mo><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>i</mi></msub></mrow></mrow></math> the highest scoring class such that <math id="S4.SS5.SSS0.Px2.p3.m3" class="ltx_Math" alttext="k\neq t" display="inline"><mrow><mi>k</mi><mo>≠</mo><mi>t</mi></mrow></math>.
The multiclass hinge loss is defined as:</p>
<table id="S13.EGx9" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex31" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex31.m1" class="ltx_Math" alttext="\displaystyle L_{hinge(multiclass)}(\mathbf{\hat{y}},\mathbf{y})=\max(0,1-(%
\hat{y}_{t}-\hat{y}_{k}))" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM423"><mi>m</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>s</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM424"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM425">𝐲</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM427">max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn id="XM428">0</mn><mo>,</mo><mrow id="XM429"><mn>1</mn><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow id="XM426"><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>t</mi></msub><mo>-</mo><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>k</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px2.p4" class="ltx_para ltx_noindent">
<p class="ltx_p">The multiclass hinge loss attempts to score the correct class above
all other classes with a margin of at least 1.</p>
</div>
<div id="S4.SS5.SSS0.Px2.p5" class="ltx_para">
<p class="ltx_p">Both the binary and multiclass hinge losses are intended to be used with a
linear output layer. The hinge losses are useful whenever we require a hard
decision rule, and do not attempt to model class membership probability.</p>
</div>
</section>
<section id="S4.SS5.SSS0.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Log loss</h5>

<div id="S4.SS5.SSS0.Px3.p1" class="ltx_para">
<p class="ltx_p">The log loss is a common variation of the hinge loss, which
can be seen as a “soft” version of the hinge loss with an infinite margin
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S4.SS5.SSS0.Px3.p2" class="ltx_para">
<table id="S13.EGx10" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex32" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex32.m1" class="ltx_Math" alttext="\displaystyle L_{log}(\mathbf{\hat{y}},\mathbf{y})=\log(1+exp(-(\hat{y}_{t}-%
\hat{y}_{k}))" display="inline"><mrow><msub><mi>L</mi><mrow><mi>l</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>g</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM438"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM439">𝐲</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>log</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>e</mi><mi>x</mi><mi>p</mi><mrow><mo stretchy="false">(</mo><mo>-</mo><mrow><mo stretchy="false">(</mo><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>t</mi></msub><mo>-</mo><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</section>
<section id="S4.SS5.SSS0.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Categorical cross-entropy loss</h5>

<div id="S4.SS5.SSS0.Px4.p1" class="ltx_para">
<p class="ltx_p">The categorical cross-entropy loss (also referred to as <em class="ltx_emph">negative log
likelihood</em>) is
used when a probabilistic interpretation of the scores is desired.</p>
</div>
<div id="S4.SS5.SSS0.Px4.p2" class="ltx_para">
<p class="ltx_p">Let <math id="S4.SS5.SSS0.Px4.p2.m1" class="ltx_Math" alttext="\mathbf{y}=y_{1},\ldots,y_{n}" display="inline"><mrow><mi>𝐲</mi><mo>=</mo><mrow><msub id="XM446"><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM447">…</mi><mo>,</mo><msub id="XM448"><mi>y</mi><mi>n</mi></msub></mrow></mrow></math> be a vector representing
the true multinomial distribution over the labels <math id="S4.SS5.SSS0.Px4.p2.m2" class="ltx_Math" alttext="1,\ldots,n" display="inline"><mrow><mn id="XM449">1</mn><mo>,</mo><mi mathvariant="normal" id="XM450">…</mi><mo>,</mo><mi id="XM451">n</mi></mrow></math>, and let
<math id="S4.SS5.SSS0.Px4.p2.m3" class="ltx_Math" alttext="\mathbf{\hat{y}}=\hat{y_{1}},\ldots,\hat{y_{n}}" display="inline"><mrow><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>=</mo><mrow><mover accent="true" id="XM452"><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">^</mo></mover><mo>,</mo><mi mathvariant="normal" id="XM453">…</mi><mo>,</mo><mover accent="true" id="XM454"><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">^</mo></mover></mrow></mrow></math> be the network’s output, which was
transformed by the <math id="S4.SS5.SSS0.Px4.p2.m4" class="ltx_Math" alttext="softmax" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi></mrow></math> activation function, and represent the class
membership conditional distribution <math id="S4.SS5.SSS0.Px4.p2.m5" class="ltx_Math" alttext="\hat{y}_{i}=P(y=i|\mathbf{x})" display="inline"><mrow><msub><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>i</mi></msub><mo>=</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><mi>i</mi><mo stretchy="false">|</mo><mi>𝐱</mi><mo stretchy="false">)</mo></mrow></mrow></math>.
The categorical cross entropy loss measures the dissimilarity between the true label distribution
<math id="S4.SS5.SSS0.Px4.p2.m6" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math> and the predicted label distribution <math id="S4.SS5.SSS0.Px4.p2.m7" class="ltx_Math" alttext="\mathbf{\hat{y}}" display="inline"><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover></math>, and is defined as
cross entropy:</p>
</div>
<div id="S4.SS5.SSS0.Px4.p3" class="ltx_para">
<table id="S13.EGx11" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex33" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex33.m1" class="ltx_Math" alttext="\displaystyle L_{cross-entropy}(\mathbf{\hat{y}},\mathbf{y})=-\sum_{i}y_{i}%
\log(\hat{y}_{i})" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mrow><mi>c</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>s</mi></mrow><mo>-</mo><mrow><mi>e</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>p</mi><mo>⁢</mo><mi>y</mi></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM459"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM460">𝐲</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>-</mo><mrow><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mi>i</mi></munder></mstyle><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>⁢</mo><mrow><mi id="XM461">log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><msub id="XM462"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px4.p4" class="ltx_para">
<p class="ltx_p">For hard classification problems in which each training example has a single
correct class assignment, <math id="S4.SS5.SSS0.Px4.p4.m1" class="ltx_Math" alttext="\mathbf{y}" display="inline"><mi>𝐲</mi></math> is a one-hot vector representing the true
class. In such cases, the cross entropy can be simplified to:</p>
</div>
<div id="S4.SS5.SSS0.Px4.p5" class="ltx_para">
<table id="S13.EGx12" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex34" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex34.m1" class="ltx_Math" alttext="\displaystyle L_{cross-entropy(\text{hard classification})}(\mathbf{\hat{y}},%
\mathbf{y})=-\log(\hat{y}_{t})" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mrow><mi>c</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>s</mi></mrow><mo>-</mo><mrow><mi>e</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>p</mi><mo>⁢</mo><mi>y</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mtext id="XM468">hard classification</mtext><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM469"><mi>𝐲</mi><mo stretchy="false">^</mo></mover><mo>,</mo><mi id="XM470">𝐲</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>-</mo><mrow><mi id="XM471">log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><msub id="XM472"><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mi>t</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px4.p6" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S4.SS5.SSS0.Px4.p6.m1" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> is the correct class assignment. This attempts to set the
probability mass assigned to the correct class <math id="S4.SS5.SSS0.Px4.p6.m2" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> to 1. Because the scores
<math id="S4.SS5.SSS0.Px4.p6.m3" class="ltx_Math" alttext="\mathbf{\hat{y}}" display="inline"><mover accent="true"><mi>𝐲</mi><mo stretchy="false">^</mo></mover></math> have been transformed using the <math id="S4.SS5.SSS0.Px4.p6.m4" class="ltx_Math" alttext="softmax" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi></mrow></math> function and represent a
conditional distribution, increasing the mass assigned to the correct class
means decreasing the mass assigned to all the other classes.
</p>
</div>
<div id="S4.SS5.SSS0.Px4.p7" class="ltx_para">
<p class="ltx_p">The cross-entropy loss is very common in the neural networks literature, and
produces a multi-class classifier which does not only predict the one-best
class label but but also predicts a distribution over the possible labels. When
using the cross-entropy loss, it is assumed that the network’s output is transformed
using the <math id="S4.SS5.SSS0.Px4.p7.m1" class="ltx_Math" alttext="softmax" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi></mrow></math> transformation.</p>
</div>
</section>
<section id="S4.SS5.SSS0.Px5" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Ranking losses</h5>

<div id="S4.SS5.SSS0.Px5.p1" class="ltx_para">
<p class="ltx_p">In some settings, we are not given supervision in
term of labels, but rather as pairs of correct and incorrect items <math id="S4.SS5.SSS0.Px5.p1.m1" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> and
<math id="S4.SS5.SSS0.Px5.p1.m2" class="ltx_Math" alttext="\mathbf{x^{\prime}}" display="inline"><msup><mi>𝐱</mi><mo>′</mo></msup></math>, and our goal is to score correct items above incorrect ones. Such
training situations arise when we have only positive examples, and generate
negative examples by corrupting a positive example.
A useful loss in such scenarios is the margin-based ranking
loss, defined for a pair of correct and incorrect examples:</p>
</div>
<div id="S4.SS5.SSS0.Px5.p2" class="ltx_para">
<table id="S13.EGx13" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex35" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex35.m1" class="ltx_Math" alttext="\displaystyle L_{ranking(margin)}(\mathbf{x},\mathbf{x^{\prime}})=\max(0,1-(NN%
(\mathbf{x})-NN(\mathbf{x^{\prime}})))" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mi>r</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>k</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM482"><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM483">𝐱</mi><mo>,</mo><msup id="XM484"><mi>𝐱</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM488">max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn id="XM489">0</mn><mo>,</mo><mrow id="XM490"><mn>1</mn><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow id="XM487"><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM485">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup id="XM486"><mi>𝐱</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px5.p3" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S4.SS5.SSS0.Px5.p3.m1" class="ltx_Math" alttext="NN(\mathbf{x})" display="inline"><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM491">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow></math> is the score assigned by the network for input vector
<math id="S4.SS5.SSS0.Px5.p3.m2" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math>. The objective is to score (rank) correct inputs over incorrect ones with a
margin of at least 1.</p>
</div>
<div id="S4.SS5.SSS0.Px5.p4" class="ltx_para">
<p class="ltx_p">A common variation is to use the log version of the ranking loss:</p>
</div>
<div id="S4.SS5.SSS0.Px5.p5" class="ltx_para">
<table id="S13.EGx14" class="ltx_equationgroup ltx_eqn_align">

<tr id="S4.Ex36" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S4.Ex36.m1" class="ltx_Math" alttext="\displaystyle L_{ranking(log)}(\mathbf{x},\mathbf{x^{\prime}})=\log(1+exp(-(NN%
(\mathbf{x})-NN(\mathbf{x^{\prime}}))))" display="inline"><mrow><mrow><msub><mi>L</mi><mrow><mi>r</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>k</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM503"><mi>l</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM504">𝐱</mi><mo>,</mo><msup id="XM505"><mi>𝐱</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi id="XM512">log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow id="XM513"><mn>1</mn><mo>+</mo><mrow><mi>e</mi><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM511"><mo>-</mo><mrow><mo stretchy="false">(</mo><mrow id="XM510"><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM506">𝐱</mi><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup id="XM509"><mi>𝐱</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S4.SS5.SSS0.Px5.p6" class="ltx_para">
<p class="ltx_p">Examples using the ranking hinge loss in language tasks include training with the
auxiliary tasks used for deriving pre-trained word embeddings
(see section <a href="#S5" title="5 Word Embeddings ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>), in which we are given a correct word sequence and a
corrupted word sequence, and our goal is to score the correct sequence above
the corrupt one <cite class="ltx_cite">[]</cite>. Similarly, Van de Cruys <span class="ltx_ERROR undefined">\citeyear</span>vandecruys2014neural used the
ranking loss in a selectional-preferences task, in which the network was trained
to rank correct verb-object pairs above incorrect, automatically derived ones,
and <cite class="ltx_cite">[]</cite> trained a model to score correct
(head,relation,trail) triplets above corrupted ones in an information-extraction
setting. An example of using the ranking log loss can be found in
<cite class="ltx_cite">[]</cite>. A variation of the ranking log loss allowing for a
different margin for the negative and positive class is given in <cite class="ltx_cite">[]</cite>.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5 </span>Word Embeddings</h2>

<div id="S5.p1" class="ltx_para">
<p class="ltx_p">A main component of the neural-network approach is the use of embeddings – representing each feature as a vector in a low dimensional space.
But where do the vectors come from? This section will survey the common approaches.</p>
</div>
<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1 </span>Random Initialization</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p class="ltx_p">When enough supervised training data is available, one can just treat the feature
embeddings the same as the other model parameters: initialize the embedding
vectors to random values, and let the network-training procedure tune them into “good” vectors.</p>
</div>
<div id="S5.SS1.p2" class="ltx_para">
<p class="ltx_p">Some care has to be taken in the way the random initialization is performed. The
method used by the effective word2vec implementation
<cite class="ltx_cite">[]</cite> is to initialize the word
vectors to uniformly sampled random numbers in the range <math id="S5.SS1.p2.m1" class="ltx_Math" alttext="[-\frac{1}{2d},\frac{1}{2d}]" display="inline"><mrow><mo stretchy="false">[</mo><mrow id="XM514"><mo>-</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>⁢</mo><mi>d</mi></mrow></mfrac></mrow><mo>,</mo><mfrac id="XM515"><mn>1</mn><mrow><mn>2</mn><mo>⁢</mo><mi>d</mi></mrow></mfrac><mo stretchy="false">]</mo></mrow></math> where <math id="S5.SS1.p2.m2" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> is the number of dimensions. Another option is to use
<em class="ltx_emph">xavier initialization</em> (see Section <a href="#S6.SS3.SSS5.Px1" title="Initialization ‣ 6.3 Optimization Issues ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.3</span></a>) and initialize with
uniformly
sampled values from <math id="S5.SS1.p2.m3" class="ltx_Math" alttext="\left[-\frac{\sqrt{6}}{\sqrt{d}},\frac{\sqrt{6}}{\sqrt{d}}\right]" display="inline"><mrow><mo>[</mo><mrow id="XM516"><mo>-</mo><mfrac><msqrt><mn>6</mn></msqrt><msqrt><mi>d</mi></msqrt></mfrac></mrow><mo>,</mo><mfrac id="XM517"><msqrt><mn>6</mn></msqrt><msqrt><mi>d</mi></msqrt></mfrac><mo>]</mo></mrow></math>.</p>
</div>
<div id="S5.SS1.p3" class="ltx_para">
<p class="ltx_p">In practice, one will often use the random initialization approach to initialize
the embedding vectors of commonly occurring features, such as part-of-speech
tags or individual letters, while using some form of supervised or unsupervised
pre-training to initialize the potentially rare features, such as features for
individual words. The pre-trained vectors can then either be treated as fixed
during the network training process, or, more commonly, treated like the
randomly-initialized vectors and further tuned to the task at hand.</p>
</div>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2 </span>Supervised Task-specific Pre-training</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p class="ltx_p">If we are interested in task A, for which we only have a limited amount of
labeled data (for example, syntactic parsing), but there is an auxiliary task B
(say, part-of-speech tagging) for which we have much more labeled data, we may
want to pre-train our word vectors so that they perform well as predictors for task B, and
then use the trained vectors for training task A. In this way, we can utilize
the larger amounts of labeled data we have for task B. When training
task A we can either treat the pre-trained vectors as fixed, or tune them
further for task A.
Another option is to train jointly for both objectives, see Section <a href="#S7" title="7 Cascading and Multi-task Learning ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> for more details.</p>
</div>
</section>
<section id="S5.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.3 </span>Unsupervised Pre-training</h3>

<div id="S5.SS3.p1" class="ltx_para">
<p class="ltx_p">The common case is that we do not have an auxiliary task with large enough
amounts of annotated data (or maybe we want to help bootstrap the auxiliary task
training with better vectors). In such cases, we resort to “unsupervised”
methods, which can be trained on huge amounts of unannotated text.</p>
</div>
<div id="S5.SS3.p2" class="ltx_para">
<p class="ltx_p">The techniques for training the word vectors are essentially those of supervised
learning, but instead of supervision for the task that we care about, we instead
create practically unlimited number of supervised training instances from raw
text, hoping that the tasks that we created will match (or be close enough to) the
final task we care about.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">12</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">12</sup>The interpretation of creating auxiliary problems from
raw text is inspired by Ando and Zhang <cite class="ltx_cite">[]</cite>.</span></span></span>
</p>
</div>
<div id="S5.SS3.p3" class="ltx_para">
<p class="ltx_p">The key idea behind the unsupervised approaches is that one would like the
embedding vectors of “similar” words to have similar vectors. While word
similarity is hard to define and is usually very task-dependent, the current
approaches derive from the distributional hypothesis <cite class="ltx_cite">[]</cite>,
stating that <em class="ltx_emph">words are similar if they appear in similar contexts</em>. The different
methods all create supervised training instances in which the goal is to either
predict the word from its context, or predict the context from the word.</p>
</div>
<div id="S5.SS3.p4" class="ltx_para">
<p class="ltx_p">An important benefit of training word embeddings on large amounts of unannotated
data is that it provides vector representations for words that do not appear in
the supervised training set. Ideally, the representations for these words will
be similar to those of related words that do appear in the training set,
allowing the model to generalize better on unseen events. It is thus desired
that
the similarity between word vectors learned by the unsupervised algorithm
captures the same aspects of similarity that are useful for performing the
intended task of the network.</p>
</div>
<div id="S5.SS3.p5" class="ltx_para">
<p class="ltx_p">Common unsupervised word-embedding algorithms include <span class="ltx_text ltx_font_typewriter">word2vec</span>
<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">13</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">13</sup>While often treated as a single algorithm, <span class="ltx_text ltx_font_typewriter">word2vec</span> is
actually a software package including various training objectives, optimization
methods and other hyperparameters. See <cite class="ltx_cite">[]</cite> for a discussion.</span></span></span>
<cite class="ltx_cite">[]</cite>, <span class="ltx_text ltx_font_typewriter">GloVe</span> <cite class="ltx_cite">[]</cite> and the Collobert and Weston
<span class="ltx_ERROR undefined">\citeyear</span>collobert2008unified,collobert2011natural embeddings algorithm. These models are inspired by neural
networks and are based on stochastic gradient training. However, they are
deeply connected to another family of algorithms which evolved in the NLP and IR
communities, and that are based on matrix factorization (see <cite class="ltx_cite">[]</cite>
for a discussion).</p>
</div>
<div id="S5.SS3.p6" class="ltx_para">
<p class="ltx_p">Arguably, the choice of auxiliary problem (what is being predicted, based
on what kind of context) affects the resulting vectors much more than the learning
method that is being used to train them. We thus focus on the different
choices of auxiliary problems that are available, and only skim over the details
of the training methods. Several software packages for deriving word vectors
are available, including word2vec<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">14</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">14</sup><a href="https://code.google.com/p/word2vec/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">https://code.google.com/p/word2vec/</span></a></span></span></span> and Gensim<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">15</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">15</sup><a href="https://radimrehurek.com/gensim/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">https://radimrehurek.com/gensim/</span></a></span></span></span>
implementing the word2vec models with word-windows based contexts,
word2vecf<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">16</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">16</sup><a href="https://bitbucket.org/yoavgo/word2vecf" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">https://bitbucket.org/yoavgo/word2vecf</span></a></span></span></span> which is a modified version of word2vec allowing
the use of arbitrary contexts, and GloVe<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">17</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">17</sup><a href="http://nlp.stanford.edu/projects/glove/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://nlp.stanford.edu/projects/glove/</span></a></span></span></span> implementing the GloVe model.
Many pre-trained word vectors are also available for download on the web.</p>
</div>
<div id="S5.SS3.p7" class="ltx_para">
<p class="ltx_p">While beyond the scope of this tutorial, it is worth noting that the word
embeddings derived by unsupervised training algorithms have a wide range of
applications in NLP beyond using them for initializing the word-embeddings layer
of a neural-network model.</p>
</div>
</section>
<section id="S5.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.4 </span>Training Objectives</h3>

<div id="S5.SS4.p1" class="ltx_para">
<p class="ltx_p">Given a word <math id="S5.SS4.p1.m1" class="ltx_Math" alttext="w" display="inline"><mi>w</mi></math> and its context <math id="S5.SS4.p1.m2" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math>, different algorithms formulate different
auxiliary tasks. In all cases, each word is represented as a <math id="S5.SS4.p1.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional
vector which is initialized to a random value. Training the model to perform the
auxiliary tasks well will result in good word embeddings for relating the words
to the contexts, which in turn will result in the embedding vectors for similar
words to be similar to each other.</p>
</div>
<div id="S5.SS4.p2" class="ltx_para">
<p class="ltx_p">Language-modeling inspired approaches such as those taken by
<cite class="ltx_cite">[]</cite> as well as GloVe <cite class="ltx_cite">[]</cite>
use auxiliary tasks in which the goal
is to predict the word given its context. This is posed in a probabilistic
setup, trying to model the conditional probability <math id="S5.SS4.p2.m1" class="ltx_Math" alttext="P(w|c)" display="inline"><mrow><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">|</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
<div id="S5.SS4.p3" class="ltx_para">
<p class="ltx_p">Other approaches reduce the problem to that of binary classification.
In addition to the set <math id="S5.SS4.p3.m1" class="ltx_Math" alttext="D" display="inline"><mi>D</mi></math> of observed word-context pairs, a set
<math id="S5.SS4.p3.m2" class="ltx_Math" alttext="\bar{D}" display="inline"><mover accent="true"><mi>D</mi><mo stretchy="false">¯</mo></mover></math> is created from random words and context pairings.
The binary classification problem is then: does the given <math id="S5.SS4.p3.m3" class="ltx_Math" alttext="(w,c)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM518">w</mi><mo>,</mo><mi id="XM519">c</mi><mo stretchy="false">)</mo></mrow></math> pair come from
<math id="S5.SS4.p3.m4" class="ltx_Math" alttext="D" display="inline"><mi>D</mi></math> or not? The approaches differ in how the set <math id="S5.SS4.p3.m5" class="ltx_Math" alttext="\bar{D}" display="inline"><mover accent="true"><mi>D</mi><mo stretchy="false">¯</mo></mover></math> is constructed, what is the
structure of the classifier, and what is the objective being optimized.
Collobert and Weston <span class="ltx_ERROR undefined">\citeyear</span>collobert2008unified,collobert2011natural take a margin-based binary ranking
approach, training a feed-forward neural network to score correct <math id="S5.SS4.p3.m6" class="ltx_Math" alttext="(w,c)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM520">w</mi><mo>,</mo><mi id="XM521">c</mi><mo stretchy="false">)</mo></mrow></math> pairs
over incorrect ones.
Mikolov et al <span class="ltx_ERROR undefined">\citeyear</span>mikolov2013distributed,goldberg2014word2vec take instead a probabilistic version, training a
log-bilinear model to predict the probability <math id="S5.SS4.p3.m7" class="ltx_Math" alttext="P((w,c)\in D|w,c)" display="inline"><mrow><mi>P</mi><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi id="XM522">w</mi><mo>,</mo><mi id="XM523">c</mi><mo stretchy="false">)</mo></mrow><mo>∈</mo><mi>D</mi><mo stretchy="false">|</mo><mi id="XM524">w</mi><mo>,</mo><mi id="XM525">c</mi><mo stretchy="false">)</mo></mrow></mrow></math> that the pair come from the
corpus rather than the random sample.</p>
</div>
</section>
<section id="S5.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.5 </span>The Choice of Contexts</h3>

<div id="S5.SS5.p1" class="ltx_para">
<p class="ltx_p">In most cases, the contexts of a word are taken to be other words that appear in
its surrounding, either in a short window around it, or within the same
sentence, paragraph or document. In some cases the text is automatically parsed
by a syntactic parser, and the contexts are derived from the syntactic
neighbourhood induced by the automatic parse trees. Sometimes, the definitions
of words and context change to include also parts of words, such as prefixes or
suffixes.</p>
</div>
<div id="S5.SS5.p2" class="ltx_para">
<p class="ltx_p">Neural word embeddings originated from the world of language modeling, in which
a network is trained to predict the next word based on a sequence of preceding
words <cite class="ltx_cite">[]</cite>. There, the text is used to create auxiliary tasks in
which the aim is to predict a word based on a context the <math id="S5.SS5.p2.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> previous words.
While training for the language modeling auxiliary prediction problems indeed
produce useful embeddings, this approach is needlessly restricted by the
constraints of the language modeling task, in which one is allowed to look only
at the previous words.
If we do not care about language modeling but only about the resulting
embeddings, we may do better by ignoring this constraint and taking the context
to be a symmetric window around the focus word.</p>
</div>
<section id="S5.SS5.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.5.1 </span>Window Approach</h4>

<div id="S5.SS5.SSS1.p1" class="ltx_para">
<p class="ltx_p">The most common approach is a sliding window
approach, in which auxiliary tasks are created by looking at a sequence of
<math id="S5.SS5.SSS1.p1.m1" class="ltx_Math" alttext="2k+1" display="inline"><mrow><mrow><mn>2</mn><mo>⁢</mo><mi>k</mi></mrow><mo>+</mo><mn>1</mn></mrow></math> words. The middle word is callled the <em class="ltx_emph">focus word</em> and the <math id="S5.SS5.SSS1.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> words
to each side are the <em class="ltx_emph">contexts</em>. Then, either a single task is created in
which the goal is to predict the focus word based on all of the context words
(represented either using CBOW <cite class="ltx_cite">[]</cite> or vector concatenation
<cite class="ltx_cite">[]</cite>), or <math id="S5.SS5.SSS1.p1.m3" class="ltx_Math" alttext="2k" display="inline"><mrow><mn>2</mn><mo>⁢</mo><mi>k</mi></mrow></math> distinct tasks are created, each pairing the focus
word with a different context word. The <math id="S5.SS5.SSS1.p1.m4" class="ltx_Math" alttext="2k" display="inline"><mrow><mn>2</mn><mo>⁢</mo><mi>k</mi></mrow></math> tasks approach, popularized by
<cite class="ltx_cite">[]</cite> is referred to as a <em class="ltx_emph">skip-gram</em> model. Skip-gram
based approaches are shown to be robust and efficient to train
<cite class="ltx_cite">[]</cite>, and often produce state of the art results.</p>
</div>
<section id="S5.SS5.SSS1.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Effect of Window Size</h5>

<div id="S5.SS5.SSS1.Px1.p1" class="ltx_para">
<p class="ltx_p">The size of the sliding window has a strong
effect on the resulting vector similarities. Larger windows tend to produce more
topical similarities (i.e. “dog”, “bark” and “leash” will be grouped
together, as well as “walked”, “run” and “walking”), while smaller windows
tend to produce more functional and syntactic similarities (i.e. “Poodle”,
“Pitbull”, “Rottweiler”, or “walking”,“running”,“approaching”).</p>
</div>
</section>
<section id="S5.SS5.SSS1.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Positional Windows</h5>

<div id="S5.SS5.SSS1.Px2.p1" class="ltx_para">
<p class="ltx_p">When using the CBOW or skip-gram context
representations, all the different context words within the window are treated
equally. There is no distinction between context words that are close to the
focus words and those that are farther from it, and likewise there is no
distinction between context words that appear before the focus words to context
words that appear after it. Such information can easily be factored in by using
<em class="ltx_emph">positional contexts</em>: indicating for each context word also its relative
position to the focus words (i.e. instead of the context word being “the” it
becomes “the:+2”, indicating the word appears two positions to the right of
the focus word). The use of positional context together with smaller windows
tend to produce similarities that are more syntactic, with a strong tendency of
grouping together words that share a part of speech, as well as being
functionally similar in terms of their semantics. Positional vectors were shown
by <cite class="ltx_cite">[]</cite> to be more effective than window-based vectors when
used to initialize networks for part-of-speech tagging and syntactic dependency
parsing.</p>
</div>
</section>
<section id="S5.SS5.SSS1.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Variants</h5>

<div id="S5.SS5.SSS1.Px3.p1" class="ltx_para">
<p class="ltx_p">Many variants on the window approach are possible. One may
lemmatize words before learning, apply text normalization, filter too short or
too long sentences, or remove capitalization (see, e.g., the pre-processing
steps described in <cite class="ltx_cite">[]</cite>. One may sub-sample part of the corpus,
skipping with some probability the creation of tasks from windows that have too common or too rare
focus words. The window size may be dynamic, using a different window size at
each turn. One may weigh the different positions in the window differently,
focusing more on trying to predict correctly close word-context pairs than
further away ones. Each of these choices will effect the resulting vectors.
Some of these hyperparameters (and others) are discussed in <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
</section>
<section id="S5.SS5.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.5.2 </span>Sentences, Paragraphs or Documents</h4>

<div id="S5.SS5.SSS2.p1" class="ltx_para">
<p class="ltx_p">Using a skip-grams (or CBOW)
approach, one can consider the contexts of a word to be all the other words that
appear with it in the same sentence, paragraph or document. This is equivalent
to using very large window sizes, and is expected to result in word vectors that
capture topical similarity (words from the same topic, i.e. words that one would
expect to appear in the same document, are likely to receive similar vectors).</p>
</div>
</section>
<section id="S5.SS5.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.5.3 </span>Syntactic Window</h4>

<div id="S5.SS5.SSS3.p1" class="ltx_para">
<p class="ltx_p">Some work replace the linear context within a
sentence with a syntactic one <cite class="ltx_cite">[]</cite>.
The text is automatically parsed using a
dependency parser, and the context of a word is taken to be the words that are
in its proximity in the parse tree, together with the syntactic relation by
which they are connected. Such approaches produce highly <em class="ltx_emph">functional</em>
similarities, grouping together words than can fill the same role in a sentence
(e.g. colors, names of schools, verbs of movement). The grouping is also
syntactic, grouping together words that share an inflection <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S5.SS5.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.5.4 </span>Multilingual</h4>

<div id="S5.SS5.SSS4.p1" class="ltx_para">
<p class="ltx_p">Another option is using multilingual,
translation based contexts <cite class="ltx_cite">[]</cite>.
For example, given a large amount of
sentence-aligned parallel text, one can run a bilingual alignment model such as
the IBM model 1 or model 2 (i.e. using the GIZA++ software), and then use the
produced alignments to derive word contexts. Here, the context of a word
instance are the foreign language words that are aligned to it. Such alignments
tend to result in synonym words receiving similar vectors. Some authors work instead on
the sentence alignment level, without relying on word alignments. An appealing method
is to mix a monolingual window-based approach with a multilingual approach,
creating both kinds of auxiliary tasks. This is likely to produce vectors that
are similar to the window-based approach, but reducing the somewhat undesired
effect of the window-based approach in which antonyms (e.g. hot and cold, high
and low) tend to receive similar vectors <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S5.SS5.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.5.5 </span>Character-based and Sub-word Representations</h4>

<div id="S5.SS5.SSS5.p1" class="ltx_para">
<p class="ltx_p">An interesting line of work attempts to derive the vector representation of a
word from the characters that compose it. Such approaches are likely to be
particularly useful for tasks which are syntactic in nature, as the character
patterns within words are strongly related to their syntactic function. These
approaches also have the benefit of producing very small model sizes (only
one vector for each character in the alphabet together with a handful of small
matrices needs to be stored), and being able to provide an embedding vector for
every word that may be encountered.
dos Santos and Gatti <span class="ltx_ERROR undefined">\citeyear</span>dossantos2014deep and dos Santos and Zadrozny
<span class="ltx_ERROR undefined">\citeyear</span>santos2014learning model the embedding of a word using a
convolutional network (see Section <a href="#S9" title="9 Convolutional Layers ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>) over the characters.
Ling et al <span class="ltx_ERROR undefined">\citeyear</span>ling2015finding model the embedding of a word using the
concatenation of the final states of two RNN (LSTM) encoders (Section <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>), one
reading the characters from left to right, and the other from right to left.
Both produce very strong results for part-of-speech tagging. The work of
Ballesteros et al <span class="ltx_ERROR undefined">\citeyear</span>ballesteros2015improved show that the two-LSTMs encoding of
<cite class="ltx_cite">[]</cite> is beneficial also for representing words in dependency
parsing of morphologically rich languages.</p>
</div>
<div id="S5.SS5.SSS5.p2" class="ltx_para">
<p class="ltx_p">Deriving representations of words from the representations of their characters
is motivated by the <em class="ltx_emph">unknown words problem</em> – what do you do when you
encounter a word for which you do not have an embedding vector? Working on the
level of characters alleviates this problem to a large extent, as the vocabulary
of possible characters is much smaller than the vocabulary of possible words.
However, working on the character level is very challenging, as the relationship
between form (characters) and function (syntax, semantics) in language is quite
loose. Restricting oneself to stay on the character level may be an
unnecessarily hard constraint.
Some researchers propose a middle-ground, in which a word is represented as a
combination of a vector for the word itself with vectors of sub-word units that
comprise it. The sub-word embeddings then help in sharing information between
different words with similar forms, as well as allowing back-off to the subword
level when the word is not observed. At the same time, the models are not
forced to rely solely on form when enough observations of the word are available.
Botha and Blunsom <span class="ltx_ERROR undefined">\citeyear</span>botha2014compositional suggest to
model the embedding vector of a word as a sum of the word-specific vector if such vector
is available, with vectors
for the different morphological components that comprise it (the components are
derived using Morfessor <cite class="ltx_cite">[]</cite>, an unsupervised morphological
segmentation method). Gao et al <cite class="ltx_cite">[]</cite> suggest using as core
features not only the word form itself but also a unique feature (hence a unique
embedding vector) for each of the letter-trigrams in the word.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6 </span>Neural Network Training</h2>

<div id="S6.p1" class="ltx_para">
<p class="ltx_p">Neural network training is done by trying to minimize a loss function over a
training set, using a gradient-based method. Roughly speaking, all training
methods work by repeatedly computing an estimate of the error over the dataset, computing
the gradient with respect to the error, and then moving the parameters in the direction
of the gradient. Models differ in how the error estimate is computed, and how
“moving in the direction of the gradient” is defined. We describe the
basic algorithm, <em class="ltx_emph">stochastic gradient descent</em> (SGD),
and then briefly mention the other approaches with pointers for further reading.
Gradient calculation is central to the approach. Gradients can be efficiently
and automatically computed using reverse mode differentiation on a computation
graph – a general
algorithmic framework for automatically computing the gradient of any network
and loss function.</p>
</div>
<section id="S6.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.1 </span>Stochastic Gradient Training</h3>

<div id="S6.SS1.p1" class="ltx_para ltx_noindent">
<p class="ltx_p">The common approach for training neural networks is using the stochastic gradient
descent (SGD) algorithm <cite class="ltx_cite">[]</cite> or a
variant of it.
SGD is a general optimization algorithm. It receives a function <math id="S6.SS1.p1.m1" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math>
parameterized by <math id="S6.SS1.p1.m2" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>,
a loss function, and desired input and output pairs. It then attempts
to set the parameters <math id="S6.SS1.p1.m3" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> such that the loss of <math id="S6.SS1.p1.m4" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> with respect to the training examples is small.
The algorithm works as follows:</p>
</div>
<span class="ltx_ERROR undefined">{algorithm}</span>
<div id="S6.SS1.p2" class="ltx_para">
<p class="ltx_p">[h]
<span class="ltx_text ltx_caption">Online Stochastic Gradient Descent Training</span>

<span class="ltx_ERROR undefined">{algorithmic}</span>[1]
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Function <math id="S6.SS1.p2.m1" class="ltx_Math" alttext="f(\mathbf{x};\theta)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM526">𝐱</mi><mo>;</mo><mi id="XM527">θ</mi><mo stretchy="false">)</mo></mrow></mrow></math> parameterized with parameters
<math id="S6.SS1.p2.m2" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>.
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Training set of inputs <math id="S6.SS1.p2.m3" class="ltx_Math" alttext="\mathbf{x_{1}},\ldots,\mathbf{x_{n}}" display="inline"><mrow><msub id="XM528"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM529">…</mi><mo>,</mo><msub id="XM530"><mi>𝐱</mi><mi>𝐧</mi></msub></mrow></math> and outputs <math id="S6.SS1.p2.m4" class="ltx_Math" alttext="\mathbf{y_{1}},\ldots,\mathbf{y_{n}}" display="inline"><mrow><msub id="XM531"><mi>𝐲</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM532">…</mi><mo>,</mo><msub id="XM533"><mi>𝐲</mi><mi>𝐧</mi></msub></mrow></math>.
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Loss function <math id="S6.SS1.p2.m5" class="ltx_Math" alttext="L" display="inline"><mi>L</mi></math>.
<span class="ltx_ERROR undefined">\While</span>stopping criteria not met 
<span class="ltx_ERROR undefined">\State</span>Sample a training example <math id="S6.SS1.p2.m6" class="ltx_Math" alttext="\mathbf{x_{i}},\mathbf{y_{i}}" display="inline"><mrow><msub id="XM534"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>,</mo><msub id="XM535"><mi>𝐲</mi><mi>𝐢</mi></msub></mrow></math>
<span class="ltx_ERROR undefined">\State</span>Compute the loss <math id="S6.SS1.p2.m7" class="ltx_Math" alttext="L(f(\mathbf{x_{i}};\theta),\mathbf{y_{i}})" display="inline"><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM540"><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM539"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>;</mo><mi id="XM537">θ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM541"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> 
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS1.p2.m8" class="ltx_Math" alttext="\mathbf{\hat{g}}\leftarrow\text{ gradients of }L(f(\mathbf{x_{i}};\theta),%
\mathbf{y_{i}})\text{ w.r.t }\theta" display="inline"><mrow><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>←</mo><mrow><mtext> gradients of </mtext><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM546"><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM545"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>;</mo><mi id="XM543">θ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM547"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mtext> w.r.t </mtext><mo>⁢</mo><mi>θ</mi></mrow></mrow></math> 
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS1.p2.m9" class="ltx_Math" alttext="\theta\leftarrow\theta+\eta_{k}\mathbf{\hat{g}}" display="inline"><mrow><mi>θ</mi><mo>←</mo><mrow><mi>θ</mi><mo>+</mo><mrow><msub><mi>η</mi><mi>k</mi></msub><mo>⁢</mo><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></mrow></mrow></mrow></math> 
<span class="ltx_ERROR undefined">\EndWhile</span><span class="ltx_ERROR undefined">\State</span><span class="ltx_ERROR undefined">\Return</span><math id="S6.SS1.p2.m10" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math></p>
</div>
<div id="S6.SS1.p3" class="ltx_para">
<p class="ltx_p">The goal of the algorithm is to set the parameters <math id="S6.SS1.p3.m1" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> so as to minimize the
total loss <math id="S6.SS1.p3.m2" class="ltx_Math" alttext="\sum_{i=1}^{n}L(f(\mathbf{x_{i}};\theta),\mathbf{y_{i}})" display="inline"><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM552"><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM551"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>;</mo><mi id="XM549">θ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM553"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math> over the training set.
It works by repeatedly sampling a training example and computing the gradient
of the error on the example with respect to the parameters <math id="S6.SS1.p3.m3" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> (line
<a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a>) – the input and expected output are assumed to be
fixed, and the loss is treated as a function of the parameters <math id="S6.SS1.p3.m4" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>.
The parameters <math id="S6.SS1.p3.m5" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> are then updated in the direction of the gradient, scaled by
a learning rate <math id="S6.SS1.p3.m6" class="ltx_Math" alttext="\eta_{k}" display="inline"><msub><mi>η</mi><mi>k</mi></msub></math> (line <a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a>). For further discussion on setting the learning rate, see Section <a href="#S6.SS3" title="6.3 Optimization Issues ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.3</span></a>.</p>
</div>
<div id="S6.SS1.p4" class="ltx_para">
<p class="ltx_p">Note that the error calculated in line <a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a> is based on a single
training example, and is thus just a rough estimate of the corpus-wide loss that
we are aiming to minimize. The noise in the loss computation may result in
inaccurate gradients.
A common way of reducing this noise is to estimate the error and the gradients
based on a sample of <math id="S6.SS1.p4.m1" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math> examples. This gives rise to the <em class="ltx_emph">minibatch SGD</em> algorithm:</p>
</div>
<span class="ltx_ERROR undefined">{algorithm}</span>
<div id="S6.SS1.p5" class="ltx_para">
<p class="ltx_p">[h]
<span class="ltx_text ltx_caption">Minibatch Stochastic Gradient Descent Training</span>

<span class="ltx_ERROR undefined">{algorithmic}</span>[1]
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Function <math id="S6.SS1.p5.m1" class="ltx_Math" alttext="f(\mathbf{x};\theta)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM554">𝐱</mi><mo>;</mo><mi id="XM555">θ</mi><mo stretchy="false">)</mo></mrow></mrow></math> parameterized with parameters
<math id="S6.SS1.p5.m2" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>.
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Training set of inputs <math id="S6.SS1.p5.m3" class="ltx_Math" alttext="\mathbf{x_{1}},\ldots,\mathbf{x_{n}}" display="inline"><mrow><msub id="XM556"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM557">…</mi><mo>,</mo><msub id="XM558"><mi>𝐱</mi><mi>𝐧</mi></msub></mrow></math> and outputs <math id="S6.SS1.p5.m4" class="ltx_Math" alttext="\mathbf{y_{1}},\ldots,\mathbf{y_{n}}" display="inline"><mrow><msub id="XM559"><mi>𝐲</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM560">…</mi><mo>,</mo><msub id="XM561"><mi>𝐲</mi><mi>𝐧</mi></msub></mrow></math>.
<span class="ltx_ERROR undefined">\State</span><span class="ltx_text ltx_font_bold">Input:</span> Loss function <math id="S6.SS1.p5.m5" class="ltx_Math" alttext="L" display="inline"><mi>L</mi></math>.
<span class="ltx_ERROR undefined">\While</span>stopping criteria not met 
<span class="ltx_ERROR undefined">\State</span>Sample a minibatch of <math id="S6.SS1.p5.m6" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math> examples <math id="S6.SS1.p5.m7" class="ltx_Math" alttext="\{(\mathbf{x_{1}},\mathbf{y_{1}}),\ldots,(\mathbf{x_{m}},\mathbf{y_{m}})\}" display="inline"><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><msub id="XM571"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><msub id="XM572"><mi>𝐲</mi><mn>𝟏</mn></msub><mo stretchy="false">)</mo></mrow><mo>,</mo><mi mathvariant="normal" id="XM567">…</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><msub id="XM573"><mi>𝐱</mi><mi>𝐦</mi></msub><mo>,</mo><msub id="XM574"><mi>𝐲</mi><mi>𝐦</mi></msub><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow></math>
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS1.p5.m8" class="ltx_Math" alttext="\hat{\mathbf{g}}\leftarrow 0" display="inline"><mrow><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>←</mo><mn>0</mn></mrow></math> 
<span class="ltx_ERROR undefined">\For</span><math id="S6.SS1.p5.m9" class="ltx_Math" alttext="i=1\text{ to }m" display="inline"><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>⁢</mo><mtext> to </mtext><mo>⁢</mo><mi>m</mi></mrow></mrow></math>
<span class="ltx_ERROR undefined">\State</span>Compute the loss <math id="S6.SS1.p5.m10" class="ltx_Math" alttext="L(f(\mathbf{x_{i}};\theta),\mathbf{y_{i}})" display="inline"><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM581"><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM580"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>;</mo><mi id="XM578">θ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM582"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS1.p5.m11" class="ltx_Math" alttext="\mathbf{\hat{g}}\leftarrow\mathbf{\hat{g}}+\text{ gradients of }\frac{1}{m}L(f%
(\mathbf{x_{i}};\theta),\mathbf{y_{i}})\text{ w.r.t }\theta" display="inline"><mrow><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>←</mo><mrow><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>+</mo><mrow><mtext> gradients of </mtext><mo>⁢</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM587"><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM586"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>;</mo><mi id="XM584">θ</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM588"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mtext> w.r.t </mtext><mo>⁢</mo><mi>θ</mi></mrow></mrow></mrow></math> 
<span class="ltx_ERROR undefined">\EndFor</span>
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS1.p5.m12" class="ltx_Math" alttext="\theta\leftarrow\theta+\eta_{k}\mathbf{\hat{g}}" display="inline"><mrow><mi>θ</mi><mo>←</mo><mrow><mi>θ</mi><mo>+</mo><mrow><msub><mi>η</mi><mi>k</mi></msub><mo>⁢</mo><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></mrow></mrow></mrow></math>
<span class="ltx_ERROR undefined">\EndWhile</span><span class="ltx_ERROR undefined">\State</span><span class="ltx_ERROR undefined">\Return</span><math id="S6.SS1.p5.m13" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math></p>
</div>
<div id="S6.SS1.p6" class="ltx_para">
<p class="ltx_p">In lines <a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a> – <a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a> the algorithm estimates the
gradient of the corpus loss based on the minibatch.
After the loop, <math id="S6.SS1.p6.m1" class="ltx_Math" alttext="\mathbf{\hat{g}}" display="inline"><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></math> contains the gradient estimate, and the parameters
<math id="S6.SS1.p6.m2" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> are updated toward <math id="S6.SS1.p6.m3" class="ltx_Math" alttext="\mathbf{\hat{g}}" display="inline"><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></math>.
The minibatch size can vary in size from <math id="S6.SS1.p6.m4" class="ltx_Math" alttext="m=1" display="inline"><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow></math> to <math id="S6.SS1.p6.m5" class="ltx_Math" alttext="m=n" display="inline"><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow></math>. Higher values provide
better estimates of the corpus-wide gradients, while smaller values allow more
updates and in turn faster convergence.
Besides the improved accuracy of the gradients estimation,
the minibatch algorithm provides opportunities for improved training efficiency. For modest
sizes of <math id="S6.SS1.p6.m6" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math>, some computing architectures (i.e. GPUs) allow an efficient parallel implementation
of the computation in lines <a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a>–<a href="#S6.SS1" title="6.1 Stochastic Gradient Training ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.1</span></a>.
With a small enough learning rate, SGD is guaranteed to converge to a global optimum
if the function is convex. However, it can also be used to optimize non-convex
functions such as neural-network. While there are no longer guarantees of finding a global optimum, the algorithm
proved to be robust and performs well in practice.
</p>
</div>
<div id="S6.SS1.p7" class="ltx_para">
<p class="ltx_p">When training a neural network, the parameterized function <math id="S6.SS1.p7.m1" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> is the neural
network, and the parameters <math id="S6.SS1.p7.m2" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> are the layer-transfer matrices, bias terms, embedding
matrices and so on. The gradient computation is a key step in the SGD
algorithm, as well as in all other neural network training algorithms.
The question is, then, how to compute the gradients of the network’s error with
respect to the parameters.
Fortunately, there is an easy solution in the form of the <em class="ltx_emph">backpropagation
algorithm</em> <cite class="ltx_cite">[]</cite>. The backpropagation algorithm is a fancy name for
methodologically computing the derivatives of a complex expression using the chain-rule,
while caching intermediary results.
More generally, the backpropagation algorithm is a special case of the
reverse-mode automatic differentiation algorithm <cite class="ltx_cite">[, Section
7]</cite>, <cite class="ltx_cite">[]</cite>.The following section
describes reverse mode automatic differentiation in the context of the
<em class="ltx_emph">computation graph</em> abstraction.</p>
</div>
<section id="S6.SS1.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Beyond SGD</h5>

<div id="S6.SS1.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">While the SGD algorithm can and often does
produce good results, more advanced algorithms are also available.
The <em class="ltx_emph">SGD+Momentum</em> <cite class="ltx_cite">[]</cite> and <em class="ltx_emph">Nesterov Momentum</em> <cite class="ltx_cite">[]</cite>
algorithms are variants of SGD in which previous gradients are accumulated and
affect the current update. Adaptive learning rate algorithms including AdaGrad
<cite class="ltx_cite">[]</cite>, AdaDelta <cite class="ltx_cite">[]</cite>, RMSProp
<cite class="ltx_cite">[]</cite> and Adam <cite class="ltx_cite">[]</cite> are designed
to select the learning rate for each minibatch, sometimes on a per-coordinate
basis, potentially alleviating the need of fiddling with learning rate
scheduling. For details of these algorithms, see the original papers or
<cite class="ltx_cite">[, Sections 8.3, 8.4]</cite>. As many neural-network software
frameworks provide implementations of these algorithms, it is easy and sometimes
worthwhile to try out different variants.</p>
</div>
</section>
</section>
<section id="S6.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.2 </span>The Computation Graph Abstraction</h3>

<div id="S6.SS2.p1" class="ltx_para">
<p class="ltx_p">While one can compute the gradients of the various parameters of a network by
hand and implement them in code, this procedure is cumbersome and error prone.
For most purposes, it is preferable to use automatic tools for gradient
computation <cite class="ltx_cite">[]</cite>. The computation-graph abstraction allows
us to easily construct arbitrary networks, evaluate their predictions for given
inputs (forward pass), and compute gradients for their parameters with respect
to arbitrary scalar losses (backward pass).</p>
</div>
<div id="S6.SS2.p2" class="ltx_para">
<p class="ltx_p">A computation graph is a representation of an arbitrary mathematical computation as
a graph. It is a directed acyclic graph (DAG) in which nodes correspond to
mathematical operations or (bound) variables and edges correspond to the flow of
intermediary values between the nodes. The graph structure defines the order of
the computation in terms of the dependencies between the different components.
The graph is a DAG and not a tree, as the result of one operation can be the
input of several continuations. Consider for example a
graph for the computation of <math id="S6.SS2.p2.m1" class="ltx_Math" alttext="(a*b+1)*(a*b+2)" display="inline"><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM589"><mrow><mi>a</mi><mo>*</mo><mi>b</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>*</mo><mrow><mo stretchy="false">(</mo><mrow id="XM590"><mrow><mi>a</mi><mo>*</mo><mi>b</mi></mrow><mo>+</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></math>:</p>
<span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.2]ab1ab2.pdf</p>
</div>
<div id="S6.SS2.p3" class="ltx_para ltx_noindent">
<p class="ltx_p">The computation of <math id="S6.SS2.p3.m1" class="ltx_Math" alttext="a*b" display="inline"><mrow><mi>a</mi><mo>*</mo><mi>b</mi></mrow></math> is shared.
We restrict ourselves to the case where the computation graph is
connected.</p>
</div>
<figure id="S6.F3" class="ltx_figure"><span class="ltx_ERROR undefined">\includegraphics</span>
<p class="ltx_p">[width=]cg-composed.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 3: </span><span class="ltx_text ltx_font_bold">Computation Graph for MLP1.</span> (a) Graph with unbound input. (b) Graph with concrete input. (c) Graph with concrete input, expected output, and loss node.</figcaption>
</figure>
<div id="S6.SS2.p4" class="ltx_para">
<p class="ltx_p">Since a neural network is essentially a mathematical expression, it can be
represented as a computation graph.</p>
</div>
<div id="S6.SS2.p5" class="ltx_para">
<p class="ltx_p">For example, Figure <a href="#S6.F3" title="Figure 3 ‣ 6.2 The Computation Graph Abstraction ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>a presents the computation graph for a 1-layer MLP with a softmax output transformation.
In our notation, oval nodes represent mathematical operations or functions, and shaded rectangle nodes
represent parameters (bound variables). Network inputs are treated as constants, and drawn without a surrounding node.
Input and parameter nodes have no incoming arcs, and output nodes
have no outgoing arcs.
The output of each node is a matrix, the dimensionality of which is indicated
above the node.
</p>
</div>
<div id="S6.SS2.p6" class="ltx_para">
<p class="ltx_p">This graph is incomplete: without specifying the inputs, we cannot compute an
output. Figure <a href="#S6.F3" title="Figure 3 ‣ 6.2 The Computation Graph Abstraction ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>b shows a complete graph for an MLP that takes
three words as inputs, and predicts the distribution over part-of-speech tags
for the third word. This graph can be used for prediction, but not for
training, as the output is a vector (not a scalar) and the graph does not take
into account the correct answer or the loss term. Finally, the graph in
<a href="#S6.F3" title="Figure 3 ‣ 6.2 The Computation Graph Abstraction ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>c shows the computation graph for a specific training example,
in which the inputs are the (embeddings of) the words “the”, “black”,
“dog”, and the expected output is “NOUN” (whose index is 5).</p>
</div>
<div id="S6.SS2.p7" class="ltx_para">
<p class="ltx_p">Once the graph is built, it is straightforward to run either a forward
computation (compute the result of the computation) or a backward computation
(computing the gradients), as we show below. Constructing the graphs may look
daunting, but is actually very easy using dedicated software libraries and APIs.</p>
</div>
<section id="S6.SS2.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Forward Computation</h5>

<div id="S6.SS2.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">The forward pass computes the outputs of the
nodes in the graph. Since each node’s output depends only on itself and on its
incoming edges, it is trivial to compute the outputs of all nodes by traversing
the nodes in a topological order and computing the output of each node given the
already computed outputs of its predecessors.</p>
</div>
<div id="S6.SS2.SSS5.Px1.p2" class="ltx_para">
<p class="ltx_p">More formally, in a graph of <math id="S6.SS2.SSS5.Px1.p2.m1" class="ltx_Math" alttext="N" display="inline"><mi>N</mi></math> nodes, we associate each node with an index <math id="S6.SS2.SSS5.Px1.p2.m2" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> according to their topological
ordering. Let <math id="S6.SS2.SSS5.Px1.p2.m3" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> be the function computed by node <math id="S6.SS2.SSS5.Px1.p2.m4" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> (e.g.
<em class="ltx_emph">multiplication</em>. <em class="ltx_emph">addition</em>, …). Let <math id="S6.SS2.SSS5.Px1.p2.m5" class="ltx_Math" alttext="\pi(i)" display="inline"><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM591">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> be the
parent nodes of node <math id="S6.SS2.SSS5.Px1.p2.m6" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>, and <math id="S6.SS2.SSS5.Px1.p2.m7" class="ltx_Math" alttext="\pi^{-1}(i)=\{j\mid i\in\pi(j)\}" display="inline"><mrow><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM592">i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mi id="XM594">j</mi><mo>∣</mo><mrow id="XM595"><mi>i</mi><mo>∈</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM593">j</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math> the children nodes
of node <math id="S6.SS2.SSS5.Px1.p2.m8" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> (these are the arguments of <math id="S6.SS2.SSS5.Px1.p2.m9" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math>).
Denote by <math id="S6.SS2.SSS5.Px1.p2.m10" class="ltx_Math" alttext="v(i)" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM596">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> the output of node <math id="S6.SS2.SSS5.Px1.p2.m11" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>, that is, the application of <math id="S6.SS2.SSS5.Px1.p2.m12" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> to
the output values of its arguments <math id="S6.SS2.SSS5.Px1.p2.m13" class="ltx_Math" alttext="\pi^{-1}(i)" display="inline"><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM597">i</mi><mo stretchy="false">)</mo></mrow></mrow></math>. For variable and input nodes,
<math id="S6.SS2.SSS5.Px1.p2.m14" class="ltx_Math" alttext="f_{i}" display="inline"><msub><mi>f</mi><mi>i</mi></msub></math> is a constant function and <math id="S6.SS2.SSS5.Px1.p2.m15" class="ltx_Math" alttext="\pi^{-1}(i)" display="inline"><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM598">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> is empty.
The Forward algorithm computes the values <math id="S6.SS2.SSS5.Px1.p2.m16" class="ltx_Math" alttext="v(i)" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM599">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> for all <math id="S6.SS2.SSS5.Px1.p2.m17" class="ltx_Math" alttext="i\in[1,N]" display="inline"><mrow><mi>i</mi><mo>∈</mo><mrow><mo stretchy="false">[</mo><mn id="XM600">1</mn><mo>,</mo><mi id="XM601">N</mi><mo stretchy="false">]</mo></mrow></mrow></math>.
<span class="ltx_ERROR undefined">{algorithm}</span>[h]
<span class="ltx_text ltx_caption">Computation Graph Forward Pass</span>

<span class="ltx_ERROR undefined">{algorithmic}</span>[1]
<span class="ltx_ERROR undefined">\For</span>i = 1 to N
<span class="ltx_ERROR undefined">\State</span>Let <math id="S6.SS2.SSS5.Px1.p2.m18" class="ltx_Math" alttext="a_{1},\ldots,a_{m}=\pi^{-1}(i)" display="inline"><mrow><mrow><msub id="XM603"><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM604">…</mi><mo>,</mo><msub id="XM605"><mi>a</mi><mi>m</mi></msub></mrow><mo>=</mo><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM602">i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS2.SSS5.Px1.p2.m19" class="ltx_Math" alttext="v(i)\leftarrow f_{i}(v(a_{1}),\ldots,v(a_{m}))" display="inline"><mrow><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM606">i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>←</mo><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM612"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM610"><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi mathvariant="normal" id="XM613">…</mi><mo>,</mo><mrow id="XM614"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM611"><mi>a</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
<span class="ltx_ERROR undefined">\EndFor</span></p>
</div>
</section>
<section id="S6.SS2.SSS5.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Backward Computation (Derivatives, Backprop)</h5>

<div id="S6.SS2.SSS5.Px2.p1" class="ltx_para">
<p class="ltx_p">The backward pass begins by designating a node <math id="S6.SS2.SSS5.Px2.p1.m1" class="ltx_Math" alttext="N" display="inline"><mi>N</mi></math> with scalar (<math id="S6.SS2.SSS5.Px2.p1.m2" class="ltx_Math" alttext="1\times 1" display="inline"><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow></math>) output as a loss-node, and running forward computation up to that node.
The backward computation will computes the gradients with respect to that node’s value.
Denote by <math id="S6.SS2.SSS5.Px2.p1.m3" class="ltx_Math" alttext="d(i)" display="inline"><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM615">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> the quantity <math id="S6.SS2.SSS5.Px2.p1.m4" class="ltx_Math" alttext="\diffp{N}{i}" display="inline"><mrow><merror class="ltx_ERROR undefined undefined"><mtext>\diffp</mtext></merror><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>i</mi></mrow></math>. The backpropagation algorithm is
used to compute the values <math id="S6.SS2.SSS5.Px2.p1.m5" class="ltx_Math" alttext="d(i)" display="inline"><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM616">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> for all nodes <math id="S6.SS2.SSS5.Px2.p1.m6" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>.</p>
</div>
<div id="S6.SS2.SSS5.Px2.p2" class="ltx_para ltx_noindent">
<p class="ltx_p">The backward pass fills a table <math id="S6.SS2.SSS5.Px2.p2.m1" class="ltx_Math" alttext="d(i)" display="inline"><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM617">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> as follows:
<span class="ltx_ERROR undefined">{algorithm}</span>[h]
<span class="ltx_text ltx_caption">Computation Graph Backward Pass (Backpropagation)</span>

<span class="ltx_ERROR undefined">{algorithmic}</span>[1]
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS2.SSS5.Px2.p2.m2" class="ltx_Math" alttext="d(N)\leftarrow 1" display="inline"><mrow><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM618">N</mi><mo stretchy="false">)</mo></mrow></mrow><mo>←</mo><mn>1</mn></mrow></math>
<span class="ltx_ERROR undefined">\For</span>i = N-1 to 1
<span class="ltx_ERROR undefined">\State</span><math id="S6.SS2.SSS5.Px2.p2.m3" class="ltx_Math" alttext="d(i)\leftarrow\sum_{j\in\pi(i)}d(j)\cdot\diffp{f_{j}}{i}" display="inline"><mrow><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM620">i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>←</mo><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mi>j</mi><mo>∈</mo><mrow><mi>π</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM619">i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mrow><mrow><mrow><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM621">j</mi><mo stretchy="false">)</mo></mrow></mrow><mo>⋅</mo><merror class="ltx_ERROR undefined undefined"><mtext>\diffp</mtext></merror></mrow><mo>⁢</mo><msub><mi>f</mi><mi>j</mi></msub><mo>⁢</mo><mi>i</mi></mrow></mrow></mrow></math>
<span class="ltx_ERROR undefined">\EndFor</span></p>
</div>
<div id="S6.SS2.SSS5.Px2.p3" class="ltx_para ltx_noindent">
<p class="ltx_p">The quantity <math id="S6.SS2.SSS5.Px2.p3.m1" class="ltx_Math" alttext="\diffp{f_{j}}{i}" display="inline"><mrow><merror class="ltx_ERROR undefined undefined"><mtext>\diffp</mtext></merror><mo>⁢</mo><msub><mi>f</mi><mi>j</mi></msub><mo>⁢</mo><mi>i</mi></mrow></math> is the partial derivative of
<math id="S6.SS2.SSS5.Px2.p3.m2" class="ltx_Math" alttext="f_{j}(\pi^{-1}(j))" display="inline"><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM623"><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM622">j</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math> w.r.t the
argument <math id="S6.SS2.SSS5.Px2.p3.m3" class="ltx_Math" alttext="i\in\pi^{-1}(j)" display="inline"><mrow><mi>i</mi><mo>∈</mo><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM624">j</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. This value depends on the function <math id="S6.SS2.SSS5.Px2.p3.m4" class="ltx_Math" alttext="f_{j}" display="inline"><msub><mi>f</mi><mi>j</mi></msub></math> and the
values <math id="S6.SS2.SSS5.Px2.p3.m5" class="ltx_Math" alttext="v(a_{1}),\ldots,v(a_{m})" display="inline"><mrow><mrow id="XM627"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM625"><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mi mathvariant="normal" id="XM628">…</mi><mo>,</mo><mrow id="XM629"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM626"><mi>a</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math> (where <math id="S6.SS2.SSS5.Px2.p3.m6" class="ltx_Math" alttext="a_{1},\ldots,a_{m}=\pi^{-1}(j)" display="inline"><mrow><mrow><msub id="XM631"><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM632">…</mi><mo>,</mo><msub id="XM633"><mi>a</mi><mi>m</mi></msub></mrow><mo>=</mo><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM630">j</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>) of its arguments, which were computed in the forward pass.</p>
</div>
<div id="S6.SS2.SSS5.Px2.p4" class="ltx_para">
<p class="ltx_p">Thus, in order to define a new kind of node, one need to define two methods: one
for calculating the forward value <math id="S6.SS2.SSS5.Px2.p4.m1" class="ltx_Math" alttext="v(i)" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM634">i</mi><mo stretchy="false">)</mo></mrow></mrow></math> based on the nodes inputs, and the
another for calculating <math id="S6.SS2.SSS5.Px2.p4.m2" class="ltx_Math" alttext="\diffp{f_{i}}{x}" display="inline"><mrow><merror class="ltx_ERROR undefined undefined"><mtext>\diffp</mtext></merror><mo>⁢</mo><msub><mi>f</mi><mi>i</mi></msub><mo>⁢</mo><mi>x</mi></mrow></math> for each <math id="S6.SS2.SSS5.Px2.p4.m3" class="ltx_Math" alttext="x\in\pi^{-1}(i)" display="inline"><mrow><mi>x</mi><mo>∈</mo><mrow><msup><mi>π</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM635">i</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</p>
</div>
<div id="S6.SS2.SSS5.Px2.p5" class="ltx_para">
<p class="ltx_p">For further information on automatic differentiation see
<cite class="ltx_cite">[, Section 7]</cite>, <cite class="ltx_cite">[]</cite>.

For more in depth discussion of the backpropagation algorithm and computation
graphs (also called flow graphs) see
<cite class="ltx_cite">[, Section 6.4]</cite>, <cite class="ltx_cite">[]</cite>.
For a popular yet technical presentation,
see Chris Olah’s description at
<a href="http://colah.github.io/posts/2015-08-Backprop/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://colah.github.io/posts/2015-08-Backprop/</span></a>.</p>
</div>
</section>
<section id="S6.SS2.SSS5.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Software</h5>

<div id="S6.SS2.SSS5.Px3.p1" class="ltx_para">
<p class="ltx_p">Several software packages implement the computation-graph model, including
Theano<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">18</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">18</sup><a href="http://deeplearning.net/software/theano/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://deeplearning.net/software/theano/</span></a></span></span></span>,
Chainer<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">19</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">19</sup><a href="http://chainer.org" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://chainer.org</span></a></span></span></span>,
penne<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">20</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">20</sup><a href="https://bitbucket.org/ndnlp/penne" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">https://bitbucket.org/ndnlp/penne</span></a></span></span></span> and
CNN/pyCNN<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">21</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">21</sup><a href="https://github.com/clab/cnn" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">https://github.com/clab/cnn</span></a></span></span></span>.
All these packages support all the essential
components (node types) for defining a wide range of neural network
architectures, covering the structures described in this tutorial and more.
Graph creation is made almost transparent by use of operator overloading. The
framework defines a type for representing graph nodes (commonly called
<em class="ltx_emph">expression</em>s), methods for constructing nodes for inputs and parameters,
and a set of functions and mathematical operations that take expressions as
input and result in more complex expressions. For example, the python code for
creating the computation graph from Figure (<a href="#S6.F3" title="Figure 3 ‣ 6.2 The Computation Graph Abstraction ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>c) using the pyCNN
framework is:</p>
</div>
<div id="S6.SS2.SSS5.Px3.p2" class="ltx_para">
<div id="LSTx1" class="ltx_listingblock ltx_lstlisting ltx_lst_language_python ltx_listing">
<div class="ltx_listing_data"><a href="data:text/plain,from%20pycnn%20import%20*%0A#%20model%20initialization.%0Amodel%20=%20Model()%0Amodel.add_parameters(%22W1%22,%20(20,150))%0Amodel.add_parameters(%22b1%22,%2020)%0Amodel.add_parameters(%22W2%22,%20(17,20))%0Amodel.add_parameters(%22b2%22,%2017)%0Amodel.add_lookup_parameters(%22words%22,%20(100,%2050))%0A%0A#%20Building%20the%20computation%20graph:%0Arenew_cg()%20#%20create%20a%20new%20graph.%0A#%20Wrap%20the%20model%20parameters%20as%20graph-nodes.%0AW1%20=%20parameter(model%5B%22W1%22%5D)%0Ab1%20=%20parameter(model%5B%22b1%22%5D)%0AW2%20=%20parameter(model%5B%22W2%22%5D)%0Ab2%20=%20parameter(model%5B%22b2%22%5D)%0Adef%20get_index(x):%20return%201%0A#%20Generate%20the%20embeddings%20layer.%0Avthe%20%20%20=%20lookup(model%5B%22words%22%5D,%20get_index(%22the%22))%0Avblack%20=%20lookup(model%5B%22words%22%5D,%20get_index(%22black%22))%0Avdog%20%20%20=%20lookup(model%5B%22words%22%5D,%20get_index(%22dog%22))%0A%0A#%20Connect%20the%20leaf%20nodes%20into%20a%20complete%20graph.%0Ax%20=%20concatenate(%5Bvthe,%20vblack,%20vdog%5D)%0Aoutput%20=%20softmax(W2*(tanh(W1*x)+b1)+b2)%0Aloss%20=%20-log(pick(output,%205))%0A%0Aloss_value%20=%20loss.forward()%0Aloss.backward()%20#%20the%20gradient%20is%20computed%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20#%20and%20stored%20in%20the%20corresponding%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20#%20parameters.">⬇</a></div>
<table class="ltx_tabular">
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">from<span class="ltx_text ltx_lst_space"> </span>pycnn<span class="ltx_text ltx_lst_space"> </span>import<span class="ltx_text ltx_lst_space"> </span>*</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">#<span class="ltx_text ltx_lst_space"> </span>model<span class="ltx_text ltx_lst_space"> </span>initialization.</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>Model()</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model.add_parameters("W1",<span class="ltx_text ltx_lst_space"> </span>(20,150))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model.add_parameters("b1",<span class="ltx_text ltx_lst_space"> </span>20)</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model.add_parameters("W2",<span class="ltx_text ltx_lst_space"> </span>(17,20))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model.add_parameters("b2",<span class="ltx_text ltx_lst_space"> </span>17)</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">model.add_lookup_parameters("words",<span class="ltx_text ltx_lst_space"> </span>(100,<span class="ltx_text ltx_lst_space"> </span>50))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line"></span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">#<span class="ltx_text ltx_lst_space"> </span>Building<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>computation<span class="ltx_text ltx_lst_space"> </span>graph:</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">renew_cg()<span class="ltx_text ltx_lst_space"> </span>#<span class="ltx_text ltx_lst_space"> </span>create<span class="ltx_text ltx_lst_space"> </span>a<span class="ltx_text ltx_lst_space"> </span>new<span class="ltx_text ltx_lst_space"> </span>graph.</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">#<span class="ltx_text ltx_lst_space"> </span>Wrap<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>model<span class="ltx_text ltx_lst_space"> </span>parameters<span class="ltx_text ltx_lst_space"> </span>as<span class="ltx_text ltx_lst_space"> </span>graph-nodes.</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">W1<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>parameter(model["W1"])</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">b1<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>parameter(model["b1"])</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">W2<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>parameter(model["W2"])</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">b2<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>parameter(model["b2"])</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">def<span class="ltx_text ltx_lst_space"> </span>get_index(x):<span class="ltx_text ltx_lst_space"> </span>return<span class="ltx_text ltx_lst_space"> </span>1</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">#<span class="ltx_text ltx_lst_space"> </span>Generate<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>embeddings<span class="ltx_text ltx_lst_space"> </span>layer.</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">vthe<span class="ltx_text ltx_lst_space">   </span>=<span class="ltx_text ltx_lst_space"> </span>lookup(model["words"],<span class="ltx_text ltx_lst_space"> </span>get_index("the"))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">vblack<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>lookup(model["words"],<span class="ltx_text ltx_lst_space"> </span>get_index("black"))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">vdog<span class="ltx_text ltx_lst_space">   </span>=<span class="ltx_text ltx_lst_space"> </span>lookup(model["words"],<span class="ltx_text ltx_lst_space"> </span>get_index("dog"))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line"></span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">#<span class="ltx_text ltx_lst_space"> </span>Connect<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>leaf<span class="ltx_text ltx_lst_space"> </span>nodes<span class="ltx_text ltx_lst_space"> </span>into<span class="ltx_text ltx_lst_space"> </span>a<span class="ltx_text ltx_lst_space"> </span>complete<span class="ltx_text ltx_lst_space"> </span>graph.</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">x<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>concatenate([vthe,<span class="ltx_text ltx_lst_space"> </span>vblack,<span class="ltx_text ltx_lst_space"> </span>vdog])</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">output<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>softmax(W2*(tanh(W1*x)+b1)+b2)</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">loss<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>-log(pick(output,<span class="ltx_text ltx_lst_space"> </span>5))</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line"></span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">loss_value<span class="ltx_text ltx_lst_space"> </span>=<span class="ltx_text ltx_lst_space"> </span>loss.forward()</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;">loss.backward()<span class="ltx_text ltx_lst_space"> </span>#<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>gradient<span class="ltx_text ltx_lst_space"> </span>is<span class="ltx_text ltx_lst_space"> </span>computed</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;"><span class="ltx_text ltx_lst_space">                 </span>#<span class="ltx_text ltx_lst_space"> </span>and<span class="ltx_text ltx_lst_space"> </span>stored<span class="ltx_text ltx_lst_space"> </span>in<span class="ltx_text ltx_lst_space"> </span>the<span class="ltx_text ltx_lst_space"> </span>corresponding</span>
                </td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td">
                  <span class="ltx_text ltx_lst_line ltx_font_typewriter" style="font-size:80%;"><span class="ltx_text ltx_lst_space">                 </span>#<span class="ltx_text ltx_lst_space"> </span>parameters.</span>
                </td>
</tr>
</table>
</div>
</div>
<div id="S6.SS2.SSS5.Px3.p3" class="ltx_para ltx_noindent">
<p class="ltx_p">Most of the code involves various initializations: the first block
defines model parameters that are be shared between different computation
graphs (recall that each graph corresponds to a specific training example).
The second block turns the model parameters into the graph-node
(Expression) types. The third block retrieves the Expressions for the
embeddings of the input words. Finally, the fourth block is where the graph
is created. Note how transparent the graph creation is – there is an almost a
one-to-one correspondence between creating the graph and describing it
mathematically. The last block shows a forward and backward pass.
The other software frameworks follow similar patterns.</p>
</div>
<div id="S6.SS2.SSS5.Px3.p4" class="ltx_para">
<p class="ltx_p">Theano involves an optimizing compiler for computation graphs, which is both a
blessing and a curse. On the one hand, once compiled, large graphs can be run
efficiently on either the CPU or a GPU, making it ideal for large graphs with a
fixed structure, where only the inputs change between instances. However, the
compilation step itself can be costly, and it makes the interface a bit
cumbersome to work with. In contrast, the other packages focus on building
large and dynamic computation graphs and executing them “on the fly” without a
compilation step. While the execution speed may suffer with respect to Theano’s
optimized version, these packages are especially convenient when working with
the recurrent and recursive networks described in Sections <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>, <a href="#S12" title="12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a> as well
as in structured prediction settings as described in Section <a href="#S8" title="8 Structured Output Prediction ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>.</p>
</div>
</section>
<section id="S6.SS2.SSS5.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Implementation Recipe</h5>

<div id="S6.SS2.SSS5.Px4.p1" class="ltx_para">
<p class="ltx_p">Using the computation graph abstraction, the pseudo-code for a network training
algorithm is given in Algorithm <a href="#S6.SS2.SSS5.Px4" title="Implementation Recipe ‣ 6.2 The Computation Graph Abstraction ‣ 6 Neural Network Training ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.2</span></a>.</p>
</div>
<span class="ltx_ERROR undefined">{algorithm}</span>
<div id="S6.SS2.SSS5.Px4.p2" class="ltx_para">
<p class="ltx_p">[h!]
<span class="ltx_text ltx_caption">Neural Network Training with Computation Graph Abstraction
(using minibatches of size 1) </span></p>
</div>
<span class="ltx_ERROR undefined">{algorithmic}</span>
<div id="S6.SS2.SSS5.Px4.p3" class="ltx_para">
<p class="ltx_p">[1]
<span class="ltx_ERROR undefined">\State</span>Define network parameters.
<span class="ltx_ERROR undefined">\For</span>iteration = 1 to N
<span class="ltx_ERROR undefined">\For</span>Training example <math id="S6.SS2.SSS5.Px4.p3.m1" class="ltx_Math" alttext="\mathbf{x_{i}},\mathbf{y_{i}}" display="inline"><mrow><msub id="XM636"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>,</mo><msub id="XM637"><mi>𝐲</mi><mi>𝐢</mi></msub></mrow></math> in dataset
<span class="ltx_ERROR undefined">\State</span>loss_node <math id="S6.SS2.SSS5.Px4.p3.m2" class="ltx_Math" alttext="\leftarrow" display="inline"><mo>←</mo></math> build_computation_graph(<math id="S6.SS2.SSS5.Px4.p3.m3" class="ltx_Math" alttext="\mathbf{x_{i}}" display="inline"><msub><mi>𝐱</mi><mi>𝐢</mi></msub></math>, <math id="S6.SS2.SSS5.Px4.p3.m4" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math>, parameters)
<span class="ltx_ERROR undefined">\State</span>loss_node.forward()
<span class="ltx_ERROR undefined">\State</span>gradients <math id="S6.SS2.SSS5.Px4.p3.m5" class="ltx_Math" alttext="\leftarrow" display="inline"><mo>←</mo></math> loss_node().backward()
<span class="ltx_ERROR undefined">\State</span>parameters <math id="S6.SS2.SSS5.Px4.p3.m6" class="ltx_Math" alttext="\leftarrow" display="inline"><mo>←</mo></math> update_parameters(parameters, gradients)
<span class="ltx_ERROR undefined">\EndFor</span><span class="ltx_ERROR undefined">\EndFor</span><span class="ltx_ERROR undefined">\State</span><span class="ltx_ERROR undefined">\Return</span>parameters.


</p>
</div>
<div id="S6.SS2.SSS5.Px4.p4" class="ltx_para">
<p class="ltx_p">Here, build_computation_graph is a user-defined function that builds the
computation graph for the given input, output and network structure, returning a
single loss node. update_parameters is an optimizer specific update rule.
The recipe specifies that a new graph is created for each training example. This
accommodates cases in which the network structure varies between training
example, such as recurrent and recursive neural networks, to be discussed in
Sections <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a> – <a href="#S12" title="12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>. For networks with fixed
structures, such as an MLPs, it may be more efficient to create one base
computation graph and vary only the
inputs and expected outputs between examples.</p>
</div>
</section>
<section id="S6.SS2.SSS5.Px5" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Network Composition</h5>

<div id="S6.SS2.SSS5.Px5.p1" class="ltx_para">
<p class="ltx_p">As long as the network’s output is a vector (<math id="S6.SS2.SSS5.Px5.p1.m1" class="ltx_Math" alttext="1\times k" display="inline"><mrow><mn>1</mn><mo>×</mo><mi>k</mi></mrow></math> matrix), it is trivial to compose networks by making the output of one
network the input of another, creating arbitrary networks. The computation
graph abstractions makes this ability explicit: a node in the computation graph
can itself be a computation graph with a designated output node.
One can then design arbitrarily deep and complex networks, and be able to easily evaluate and
train them thanks to automatic forward and gradient computation. This makes it
easy to define and train networks for structured outputs and multi-objective
training, as we discuss in Section <a href="#S7" title="7 Cascading and Multi-task Learning ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>, as well as complex recurrent and recursive
networks, as discussed in Sections <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>–<a href="#S12" title="12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>.</p>
</div>
</section>
</section>
<section id="S6.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.3 </span>Optimization Issues</h3>

<div id="S6.SS3.p1" class="ltx_para">
<p class="ltx_p">Once the gradient computation is taken care of, the network is trained
using SGD or another gradient-based optimization
algorithm. The function being optimized is not
convex, and for a long time training of neural networks was considered a
“black art” which can only be done by selected few. Indeed, many parameters
affect the optimization process, and care has to be taken to tune these parameters.
While this tutorial is not intended as a comprehensive guide to successfully training
neural networks, we do list here a few of the prominent issues. For further discussion
on optimization techniques and algorithms for neural networks, refer to
<cite class="ltx_cite">[, Chapter 8]</cite>. For some theoretical discussion and analysis,
refer to <cite class="ltx_cite">[]</cite>. For various practical tips and
recommendations, see <cite class="ltx_cite">[]</cite>.</p>
</div>
<section id="S6.SS3.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Initialization</h5>

<div id="S6.SS3.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">The non-convexity of the loss function means the
optimization procedure may get stuck in a local minimum or a saddle point, and
that starting from different initial points (e.g. different random values for
the parameters) may result in different results. Thus, it is advised to run
several restarts of the training starting at different random initializations,
and choosing the best one based on a development set.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">22</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">22</sup>When debugging,
and for reproducibility of results, it is advised to used a fixed random seed.</span></span></span>
The amount of variance in the
results is different for different network formulations and datasets, and cannot
be predicted in advance.</p>
</div>
<div id="S6.SS3.SSS5.Px1.p2" class="ltx_para">
<p class="ltx_p">The magnitude of the random values has an important effect on the
success of training. An effective scheme due to Glorot and Bengio
<span class="ltx_ERROR undefined">\citeyear</span>glorot2010understanding, called <em class="ltx_emph">xavier initialization</em> after
Glorot’s first name, suggests initializing a weight matrix <math id="S6.SS3.SSS5.Px1.p2.m1" class="ltx_Math" alttext="\mathbf{W}\in\mathbb{R}^{d_{in}\times d_{out}}" display="inline"><mrow><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></msup></mrow></math> as:</p>
<table id="S13.EGx15" class="ltx_equationgroup ltx_eqn_align">

<tr id="S6.Ex37" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                    <math id="S6.Ex37.m1" class="ltx_Math" alttext="\displaystyle\mathbf{W}\sim U\left[-\frac{\sqrt{6}}{\sqrt{d_{in}+d_{out}}},+%
\frac{\sqrt{6}}{\sqrt{d_{in}+d_{out}}}\right]" display="inline"><mrow><mi>𝐖</mi><mo>∼</mo><mrow><mi>U</mi><mo>⁢</mo><mrow><mo>[</mo><mrow id="XM640"><mo>-</mo><mstyle displaystyle="true"><mfrac><msqrt><mn>6</mn></msqrt><msqrt><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></msqrt></mfrac></mstyle></mrow><mo>,</mo><mrow id="XM641"><mo>+</mo><mstyle displaystyle="true"><mfrac><msqrt><mn>6</mn></msqrt><msqrt><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow></msqrt></mfrac></mstyle></mrow><mo>]</mo></mrow></mrow></mrow></math>
                  </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S6.SS3.SSS5.Px1.p3" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S6.SS3.SSS5.Px1.p3.m1" class="ltx_Math" alttext="U[a,b]" display="inline"><mrow><mi>U</mi><mo>⁢</mo><mrow><mo stretchy="false">[</mo><mi id="XM642">a</mi><mo>,</mo><mi id="XM643">b</mi><mo stretchy="false">]</mo></mrow></mrow></math> is a uniformly sampled random value in the range <math id="S6.SS3.SSS5.Px1.p3.m2" class="ltx_Math" alttext="[a,b]" display="inline"><mrow><mo stretchy="false">[</mo><mi id="XM644">a</mi><mo>,</mo><mi id="XM645">b</mi><mo stretchy="false">]</mo></mrow></math>.
This advice works well on many occasions, and is the preferred default
initialization method by many.
</p>
</div>
<div id="S6.SS3.SSS5.Px1.p4" class="ltx_para">
<p class="ltx_p">Analysis by He et al <span class="ltx_ERROR undefined">\citeyear</span>he2015delving
suggests that when using ReLU non-linearities, the weights should be
initialized by sampling from a zero-mean Gaussian distribution whose standard
deviation is <math id="S6.SS3.SSS5.Px1.p4.m1" class="ltx_Math" alttext="\sqrt{\frac{2}{d_{in}}}" display="inline"><msqrt><mfrac><mn>2</mn><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></mfrac></msqrt></math>.
This initialization was found by He et
al to work better than xavier initialization in an image classification task,
especially when deep networks were involved.</p>
</div>
</section>
<section id="S6.SS3.SSS5.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Vanishing and Exploding Gradients</h5>

<div id="S6.SS3.SSS5.Px2.p1" class="ltx_para">
<p class="ltx_p">In deep networks, it is common for
the error gradients to either vanish (become exceedingly close to 0) or explode
(become exceedingly high) as they propagate back through the computation graph.
The problem becomes more severe in deeper networks, and especially so in
recursive and recurrent networks <cite class="ltx_cite">[]</cite>. Dealing with the vanishing gradients problem is
still an open research question. Solutions include making the networks shallower,
step-wise training (first train the first layers based on some auxiliary output signal,
then fix them and train the upper layers of the complete network based on the
real task signal), or specialized architectures that are designed to assist in
gradient flow (e.g., the LSTM and GRU architectures for recurrent networks,
discussed in Section <a href="#S11" title="11 Concrete RNN Architectures ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a>).
Dealing with the exploding gradients has a simple but very
effective solution: clipping the gradients if their norm exceeds a given
threshold. Let <math id="S6.SS3.SSS5.Px2.p1.m1" class="ltx_Math" alttext="\mathbf{\hat{g}}" display="inline"><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></math> be the gradients of all parameters in the network,
and <math id="S6.SS3.SSS5.Px2.p1.m2" class="ltx_Math" alttext="\|\mathbf{\hat{g}}\|" display="inline"><mrow><mo>∥</mo><mover accent="true" id="XM646"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>∥</mo></mrow></math> be their <math id="S6.SS3.SSS5.Px2.p1.m3" class="ltx_Math" alttext="L_{2}" display="inline"><msub><mi>L</mi><mn>2</mn></msub></math> norm. Pascanu et al
<span class="ltx_ERROR undefined">\citeyear</span>pascanu2012difficulty suggest to set: <math id="S6.SS3.SSS5.Px2.p1.m4" class="ltx_Math" alttext="\mathbf{\hat{g}}\leftarrow\frac{threshold}{\|\mathbf{\hat{g}}\|}\mathbf{\hat{g}}" display="inline"><mrow><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>←</mo><mrow><mfrac><mrow><mi>t</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>d</mi></mrow><mrow><mo>∥</mo><mover accent="true" id="XM647"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>∥</mo></mrow></mfrac><mo>⁢</mo><mover accent="true"><mi>𝐠</mi><mo stretchy="false">^</mo></mover></mrow></mrow></math> if <math id="S6.SS3.SSS5.Px2.p1.m5" class="ltx_Math" alttext="\|\mathbf{\hat{g}}\|&gt;threshold" display="inline"><mrow><mrow><mo>∥</mo><mover accent="true" id="XM648"><mi>𝐠</mi><mo stretchy="false">^</mo></mover><mo>∥</mo></mrow><mo>&gt;</mo><mrow><mi>t</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>d</mi></mrow></mrow></math>.</p>
</div>
</section>
<section id="S6.SS3.SSS5.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Saturation and Dead Neurons</h5>

<div id="S6.SS3.SSS5.Px3.p1" class="ltx_para">
<p class="ltx_p">Layers with <math id="S6.SS3.SSS5.Px3.p1.m1" class="ltx_Math" alttext="tanh" display="inline"><mrow><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi></mrow></math> and <math id="S6.SS3.SSS5.Px3.p1.m2" class="ltx_Math" alttext="sigmoid" display="inline"><mrow><mi>s</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>d</mi></mrow></math> activations can
become saturated – resulting in output values for that layer that are all close to one,
the upper-limit
of the activation function. Saturated neurons have very small gradients, and
should be avoided.
Layers with the ReLU activation cannot be saturated, but can “die” – most or
all values are negative and thus clipped at zero for all inputs, resulting in a
gradient of zero for that layer.
If your network does not train well, it is advisable to monitor the network for
saturated or dead layers. Saturated neurons are caused by
too large values entering the layer. This may be controlled for by changing the
initialization, scaling the range of the input values, or changing the learning
rate.
Dead neurons are caused by all weights entering the layer being
negative (for example this can happen after a large gradient update). Reducing
the learning rate will help in this situation.
For saturated layers, another option is to normalize the values in the saturated
layer after the activation, i.e. instead of <math id="S6.SS3.SSS5.Px3.p1.m3" class="ltx_Math" alttext="g(\mathbf{h})=tanh(\mathbf{h})" display="inline"><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM649">𝐡</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM650">𝐡</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> using
<math id="S6.SS3.SSS5.Px3.p1.m4" class="ltx_Math" alttext="g(\mathbf{h})=\frac{tanh(\mathbf{h})}{\|tanh(\mathbf{h})\|}" display="inline"><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM654">𝐡</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM651">𝐡</mi><mo stretchy="false">)</mo></mrow></mrow><mrow><mo>∥</mo><mrow id="XM653"><mi>t</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM652">𝐡</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∥</mo></mrow></mfrac></mrow></math>.
Layer normalization is an effective measure for countering saturation, but is also expensive in
terms of gradient computation.</p>
</div>
</section>
<section id="S6.SS3.SSS5.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Shuffling</h5>

<div id="S6.SS3.SSS5.Px4.p1" class="ltx_para">
<p class="ltx_p">The order in which the training examples are presented to
the network is important. The SGD formulation above specifies selecting a random
example in each turn. In practice, most implementations go over the training example
in order.
It is advised to shuffle the training examples before
each pass through the data.</p>
</div>
</section>
<section id="S6.SS3.SSS5.Px5" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Learning Rate</h5>

<div id="S6.SS3.SSS5.Px5.p1" class="ltx_para">
<p class="ltx_p">Selection of the learning rate is important. Too large
learning rates will prevent the network from converging on an effective
solution. Too small learning rates will take very long time to converge. As a
rule of thumb, one should experiment with a range of initial learning rates in
range <math id="S6.SS3.SSS5.Px5.p1.m1" class="ltx_Math" alttext="[0,1]" display="inline"><mrow><mo stretchy="false">[</mo><mn id="XM655">0</mn><mo>,</mo><mn id="XM656">1</mn><mo stretchy="false">]</mo></mrow></math>, e.g. <math id="S6.SS3.SSS5.Px5.p1.m2" class="ltx_Math" alttext="0.001" display="inline"><mn>0.001</mn></math>, <math id="S6.SS3.SSS5.Px5.p1.m3" class="ltx_Math" alttext="0.01" display="inline"><mn>0.01</mn></math>, <math id="S6.SS3.SSS5.Px5.p1.m4" class="ltx_Math" alttext="0.1" display="inline"><mn>0.1</mn></math>, <math id="S6.SS3.SSS5.Px5.p1.m5" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>. Monitor the network’s loss
over time, and decrease the learning rate once the network seem to be stuck in a
fixed region. <em class="ltx_emph">Learning rate scheduling</em> decrease the rate as a function
of the number of observed minibatches.
A common schedule is dividing the initial learning rate by the iteration
number. Léon Bottou <span class="ltx_ERROR undefined">\citeyear</span>bottou2012stochastic recommends using a
learning rate of the form <math id="S6.SS3.SSS5.Px5.p1.m6" class="ltx_Math" alttext="\eta_{t}=\eta_{0}(1+\eta_{0}\lambda t)^{-1}" display="inline"><mrow><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><mrow><msub><mi>η</mi><mn>0</mn></msub><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mrow id="XM657"><mn>1</mn><mo>+</mo><mrow><msub><mi>η</mi><mn>0</mn></msub><mo>⁢</mo><mi>λ</mi><mo>⁢</mo><mi>t</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mrow></math> where
<math id="S6.SS3.SSS5.Px5.p1.m7" class="ltx_Math" alttext="\eta_{0}" display="inline"><msub><mi>η</mi><mn>0</mn></msub></math> is the initial learning rate, <math id="S6.SS3.SSS5.Px5.p1.m8" class="ltx_Math" alttext="\eta_{t}" display="inline"><msub><mi>η</mi><mi>t</mi></msub></math> is the learning rate to use on
the <math id="S6.SS3.SSS5.Px5.p1.m9" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math>th training example, and <math id="S6.SS3.SSS5.Px5.p1.m10" class="ltx_Math" alttext="\lambda" display="inline"><mi>λ</mi></math> is an additional hyperparameter. He
further recommends determining a good value of <math id="S6.SS3.SSS5.Px5.p1.m11" class="ltx_Math" alttext="\eta_{0}" display="inline"><msub><mi>η</mi><mn>0</mn></msub></math> based on a small sample of
the data prior to running on the entire dataset.</p>
</div>
</section>
<section id="S6.SS3.SSS5.Px6" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Minibatches</h5>

<div id="S6.SS3.SSS5.Px6.p1" class="ltx_para">
<p class="ltx_p">Parameter updates occur either every training
example (minibatches of size 1) or every <math id="S6.SS3.SSS5.Px6.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> training examples.
Some problems benefit from training with larger minibatch sizes.
In terms of the computation graph abstraction, one can create
a computation graph for each of the <math id="S6.SS3.SSS5.Px6.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> training examples, and then connecting
the <math id="S6.SS3.SSS5.Px6.p1.m3" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> loss nodes under an averaging node, whose output will be the loss
of the minibatch.
Large minibatched training can also be beneficial in terms of computation
efficiency on specialized computing architectures such as GPUs. This is beyond
the scope of this tutorial.</p>
</div>
</section>
</section>
<section id="S6.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.4 </span>Regularization</h3>

<div id="S6.SS4.p1" class="ltx_para">
<p class="ltx_p">Neural network models have many parameters, and overfitting can easily occur.
Overfitting can be alleviated to some extent by <em class="ltx_emph">regularization</em>.
A common regularization method is <math id="S6.SS4.p1.m1" class="ltx_Math" alttext="L_{2}" display="inline"><msub><mi>L</mi><mn>2</mn></msub></math> regularization, placing a squared
penalty on parameters with large values by adding an additive <math id="S6.SS4.p1.m2" class="ltx_Math" alttext="\frac{\lambda}{2}\|\theta\|^{2}" display="inline"><mrow><mfrac><mi>λ</mi><mn>2</mn></mfrac><mo>⁢</mo><msup><mrow><mo>∥</mo><mi id="XM658">θ</mi><mo>∥</mo></mrow><mn>2</mn></msup></mrow></math> term
to the objective function to be minimized, where <math id="S6.SS4.p1.m3" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math> is the set of model
parameters, <math id="S6.SS4.p1.m4" class="ltx_Math" alttext="\|\cdot\|^{2}" display="inline"><mrow><mo>∥</mo><mo>⋅</mo><msup><mo>∥</mo><mn>2</mn></msup></mrow></math> is the squared <math id="S6.SS4.p1.m5" class="ltx_Math" alttext="L_{2}" display="inline"><msub><mi>L</mi><mn>2</mn></msub></math> norm (sum of squares of the
values), and <math id="S6.SS4.p1.m6" class="ltx_Math" alttext="\lambda" display="inline"><mi>λ</mi></math> is a hyperparameter controlling the amount of
regularization.</p>
</div>
<div id="S6.SS4.p2" class="ltx_para">
<p class="ltx_p">A recently proposed alternative regularization method is <em class="ltx_emph">dropout</em>
<cite class="ltx_cite">[]</cite>. The dropout method is designed to prevent the
network from learning to rely on specific weights. It works by randomly
dropping (setting to 0) half of the neurons in the network (or in a specific
layer) in each training example.
Work by Wager et al
<span class="ltx_ERROR undefined">\citeyear</span>wager2013dropout establishes a strong connection between the dropout
method and <math id="S6.SS4.p2.m1" class="ltx_Math" alttext="L_{2}" display="inline"><msub><mi>L</mi><mn>2</mn></msub></math> regularization. Gal and Gharamani <span class="ltx_ERROR undefined">\citeyear</span>gal2015dropout
show that a multi-layer perceptron with dropout applied at every layer can be
interpreted as Bayesian model averaging.</p>
</div>
<div id="S6.SS4.p3" class="ltx_para">
<p class="ltx_p">The dropout technique is one of the key factors
contributing to very strong results of neural-network methods on image
classification tasks <cite class="ltx_cite">[]</cite>, especially when combined
with ReLU activation units <cite class="ltx_cite">[]</cite>. The dropout technique
is effective also in NLP applications of neural networks.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S7" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7 </span>Cascading and Multi-task Learning</h2>

<div id="S7.p1" class="ltx_para">
<p class="ltx_p">The combination of online training methods with automatic gradient computations
using the computation graph abstraction allows for an easy implementation of model
cascading, parameter sharing and multi-task learning.</p>
</div>
<section id="S7.SS4.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Model cascading</h5>

<div id="S7.SS4.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">is a powerful technique in which large networks are built by
composing them out of smaller component networks.
For example, we may have a feed-forward network for predicting the part of
speech of a word based on its neighbouring words and/or the characters that
compose it. In a pipeline approach, we would use this network for predicting
parts of speech, and then feed the predictions as input features to neural
network that does syntactic chunking or parsing.
Instead, we could think of the hidden layers of this network as an encoding
that captures the relevant information for predicting the part of speech. In a
cascading approach, we take the hidden layers of this network and connect them (and
not the part of speech prediction themselves) as the inputs for the syntactic
network. We now have a larger network that takes as input sequences of words and
characters, and outputs a syntactic structure.
The computation graph abstraction allows us to easily propagate the
error gradients from the syntactic task loss all the way back to the characters.</p>
</div>
<div id="S7.SS4.SSS5.Px1.p2" class="ltx_para">
<p class="ltx_p">To combat the vanishing gradient problem of deep networks, as well as to make
better use of available training material, the individual component network’s
parameters can be bootstrapped by training
them separately on a relevant task, before plugging them in to the larger network
for further tuning. For example, the part-of-speech predicting network can be
trained to accurately predict parts-of-speech on a relatively large annotated
corpus, before plugging its hidden layer into the syntactic parsing network
for which less training data is available. In case the training data provide
direct supervision for both tasks, we can make use of it during training by
creating a network with two outputs, one for each task, computing a separate
loss for each output, and then summing the losses into a single node from which
we backpropagate the error gradients.</p>
</div>
<div id="S7.SS4.SSS5.Px1.p3" class="ltx_para">
<p class="ltx_p">Model cascading is very common when using convolutional, recursive and recurrent neural
networks, where, for example, a recurrent network is used to encode a sentence
into a fixed sized vector, which is then used as the input of another network.
The supervision signal of the recurrent network comes primarily from the upper
network that consumes the recurrent network’s output as it inputs.</p>
</div>
</section>
<section id="S7.SS4.SSS5.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Multi-task learning</h5>

<div id="S7.SS4.SSS5.Px2.p1" class="ltx_para">
<p class="ltx_p">is used when we have related prediction tasks that do not
necessarily feed into one another, but we do believe that information that is
useful for one type of prediction can be useful also to some of the other tasks.
For example, chunking, named entity recognition (NER) and language modeling are
examples of synergistic tasks. Information for predicting chunk boundaries,
named-entity boundaries and the next word in the sentence all rely on some
shared underlying syntactic-semantic representation. Instead of training a
separate network for each task, we can create a single network with several
outputs. A common approach is to have a multi-layer feed-forward network, whose
final hidden layer (or a concatenation of all hidden layers) is then passed to
different output layers.

This way, most of the parameters of the network are
shared between the different tasks. Useful information learned from one
task can then help to disambiguate other tasks.
Again, the computation graph abstraction makes it very easy to construct such
networks and compute the gradients for them, by computing a separate loss for
each available supervision signal, and then summing the losses into a single
loss that is used for computing the gradients. In case we have several corpora,
each with different kind of supervision signal (e.g. we have one corpus for NER
and another for chunking), the training procedure will shuffle all of the
available training example, performing gradient computation and updates with
respect to a different loss in every turn. Multi-task learning in the context
of language-processing is introduced and discussed in <cite class="ltx_cite">[]</cite>.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S8" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">8 </span>Structured Output Prediction</h2>

<div id="S8.p1" class="ltx_para">
<p class="ltx_p">Many problems in NLP involve structured outputs: cases where the desired output
is not a class label or distribution over class labels, but a structured object
such as a sequence, a tree or a graph. Canonical examples are sequence tagging
(e.g. part-of-speech tagging) sequence segmentation (chunking, NER), and syntactic parsing.
In this section, we discuss how feed-forward neural network models can be used for structured tasks.
In later sections we discuss specialized neural network models for dealing with
sequences (Section <a href="#S10" title="10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>) and trees (Section <a href="#S12" title="12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>).</p>
</div>
<section id="S8.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">8.1 </span>Greedy Structured Prediction</h3>

<div id="S8.SS1.p1" class="ltx_para">
<p class="ltx_p">The greedy approach to structured prediction is to decompose the structure
prediction problem into a sequence of local prediction problems and training
a classifier to perform each local decision. At test time, the trained
classifier is used in a greedy manner. Examples of this approach are
left-to-right tagging models <cite class="ltx_cite">[]</cite> and greedy transition-based parsing <cite class="ltx_cite">[]</cite>.
Such approaches are easily adapted to use neural networks
by simply replacing the local classifier from a linear classifier such as an SVM
or a logistic regression model to a neural network, as demonstrated in <cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S8.SS1.p2" class="ltx_para">
<p class="ltx_p">The greedy approaches suffer from error propagation, where mistakes in early
decisions carry over and influence later decisions. The overall higher accuracy
achievable with non-linear neural network classifiers helps in offsetting this
problem to some extent. In addition,
training techniques were proposed for mitigating the error
propagation problem by either attempting to take easier predictions before
harder ones (the easy-first approach <cite class="ltx_cite">[]</cite>) or making
training conditions more similar to testing conditions by exposing the
training procedure to inputs that result from likely mistakes
<cite class="ltx_cite">[]</cite>. These are effective also for
training greedy neural network models, as demonstrated by Ma et al
<cite class="ltx_cite">[]</cite> (easy-first tagger) and <cite class="ltx_cite">[]</cite> (dynamic
oracle training for greedy dependency parsing).</p>
</div>
</section>
<section id="S8.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">8.2 </span>Search Based Structured Prediction</h3>

<div id="S8.SS2.p1" class="ltx_para">
<p class="ltx_p">The common approach to predicting natural language structures is search based.
For in-depth discussion of search-based structure prediction in NLP, see the book by Smith
<cite class="ltx_cite">[]</cite>.
The techniques can easily be
adapted to use a neural-network. In the neural-networks literature, such models
were discussed under the framework of <em class="ltx_emph">energy based learning</em>
<cite class="ltx_cite">[, Section 7]</cite>. They are presented here using setup and
terminology familiar to the NLP community.</p>
</div>
<div id="S8.SS2.p2" class="ltx_para">
<p class="ltx_p">Search-based structured prediction is formulated as a search problem over
possible structures:</p>
</div>
<div id="S8.SS2.p3" class="ltx_para">
<table id="S8.Ex38" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex38.m1" class="ltx_Math" alttext="predict(x)=\operatorname*{arg\,max}_{y\in\mathcal{Y}(x)}score(x,y)" display="block"><mrow><mrow><mi>p</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM660">x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mrow><mpadded width="+1.7pt"><mi>arg</mi></mpadded><mo>⁢</mo><mi>max</mi></mrow><mrow><mi>y</mi><mo>∈</mo><mrow><mi class="ltx_font_mathcaligraphic">𝒴</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM659">x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mo>⁡</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi></mrow></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM661">x</mi><mo>,</mo><mi id="XM662">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p4" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S8.SS2.p4.m1" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> is an input structure, <math id="S8.SS2.p4.m2" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> is an output over <math id="S8.SS2.p4.m3" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> (in a
typical example <math id="S8.SS2.p4.m4" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> is a sentence and <math id="S8.SS2.p4.m5" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> is a tag-assignment or a parse-tree
over the sentence), <math id="S8.SS2.p4.m6" class="ltx_Math" alttext="\mathcal{Y}(x)" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">𝒴</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM663">x</mi><mo stretchy="false">)</mo></mrow></mrow></math> is the set of all valid structures over
<math id="S8.SS2.p4.m7" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math>, and we are looking for an output <math id="S8.SS2.p4.m8" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> that will maximize the score of the <math id="S8.SS2.p4.m9" class="ltx_Math" alttext="x,y" display="inline"><mrow><mi id="XM664">x</mi><mo>,</mo><mi id="XM665">y</mi></mrow></math> pair.</p>
</div>
<div id="S8.SS2.p5" class="ltx_para ltx_noindent">
<p class="ltx_p">The scoring function is defined as a linear model:</p>
<table id="S8.Ex39" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex39.m1" class="ltx_Math" alttext="score(x,y)=\Phi(x,y)\cdot\mathbf{w}" display="block"><mrow><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM666">x</mi><mo>,</mo><mi id="XM667">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="normal">Φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM668">x</mi><mo>,</mo><mi id="XM669">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>⋅</mo><mi>𝐰</mi></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <math id="S8.SS2.p5.m1" class="ltx_Math" alttext="\Phi" display="inline"><mi mathvariant="normal">Φ</mi></math> is a feature extraction function and <math id="S8.SS2.p5.m2" class="ltx_Math" alttext="\mathbf{w}" display="inline"><mi>𝐰</mi></math> is a weight vector.</p>
</div>
<div id="S8.SS2.p6" class="ltx_para">
<p class="ltx_p">In order to make the search for the optimal <math id="S8.SS2.p6.m1" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> tractable, the structure <math id="S8.SS2.p6.m2" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> is
decomposed into parts, and the feature function is defined in terms of the
parts, where <math id="S8.SS2.p6.m3" class="ltx_Math" alttext="\phi(p)" display="inline"><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM670">p</mi><mo stretchy="false">)</mo></mrow></mrow></math> is a part-local feature extraction function:</p>
<table id="S8.Ex40" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex40.m1" class="ltx_Math" alttext="\Phi(x,y)=\sum_{\mathclap{p\in parts(x,y)}}\phi(p)" display="block"><mrow><mrow><mi mathvariant="normal">Φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM673">x</mi><mo>,</mo><mi id="XM674">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mrow><merror class="ltx_ERROR undefined undefined"><mtext>\mathclap</mtext></merror><mo>⁢</mo><mi>p</mi></mrow><mo>∈</mo><mrow><mi>p</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM671">x</mi><mo>,</mo><mi id="XM672">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></munder><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM675">p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p7" class="ltx_para">
<p class="ltx_p">Each part is scored separately, and the structure score
is the sum of the component parts scores:</p>
</div>
<div id="S8.SS2.p8" class="ltx_para">
<table id="S13.EGx16" class="ltx_equationgroup ltx_eqn_align">

<tr id="S8.Ex41" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S8.Ex41.m1" class="ltx_Math" alttext="\displaystyle score(x,y)=" display="inline"><mrow><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM683">x</mi><mo>,</mo><mi id="XM684">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S8.Ex41.m2" class="ltx_Math" alttext="\displaystyle\mathbf{w}\cdot\Phi(x,y)=\mathbf{w}\cdot\sum_{p\in y}\phi(p)=\sum%
_{p\in y}\mathbf{w}\cdot\phi(p)=\sum_{p\in y}score(p)" display="inline"><mrow><mrow><mrow><mi>𝐰</mi><mo>⋅</mo><mi mathvariant="normal">Φ</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM685">x</mi><mo>,</mo><mi id="XM686">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>𝐰</mi><mo>⋅</mo><mrow><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder></mstyle><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM687">p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder></mstyle><mrow><mrow><mi>𝐰</mi><mo>⋅</mo><mi>ϕ</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM688">p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mstyle displaystyle="true"><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder></mstyle><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM689">p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p9" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S8.SS2.p9.m1" class="ltx_Math" alttext="p\in y" display="inline"><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></math> is a shorthand for <math id="S8.SS2.p9.m2" class="ltx_Math" alttext="p\in parts(x,y)" display="inline"><mrow><mi>p</mi><mo>∈</mo><mrow><mi>p</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM690">x</mi><mo>,</mo><mi id="XM691">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.
The decomposition of <math id="S8.SS2.p9.m3" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> into parts is such that there exists an inference
algorithm that allows for efficient search for the best scoring structure given
the scores of the individual parts.</p>
</div>
<div id="S8.SS2.p10" class="ltx_para">
<p class="ltx_p">One can now trivially replace the linear scoring function over parts with a neural-network:</p>
</div>
<div id="S8.SS2.p11" class="ltx_para">
<table id="S8.Ex42" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex42.m1" class="ltx_Math" alttext="score(x,y)=\sum_{p\in y}score(p)=\sum_{p\in y}NN(c(p))" display="block"><mrow><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM692">x</mi><mo>,</mo><mi id="XM693">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM694">p</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM696"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM695">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p12" class="ltx_para ltx_noindent">
<p class="ltx_p">where <math id="S8.SS2.p12.m1" class="ltx_Math" alttext="c(p)" display="inline"><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM697">p</mi><mo stretchy="false">)</mo></mrow></mrow></math> maps the part <math id="S8.SS2.p12.m2" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math> into a <math id="S8.SS2.p12.m3" class="ltx_Math" alttext="d_{in}" display="inline"><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></math> dimensional vector.
</p>
</div>
<div id="S8.SS2.p13" class="ltx_para">
<p class="ltx_p">In case of a one hidden-layer feed-forward network:</p>
</div>
<div id="S8.SS2.p14" class="ltx_para">
<table id="S8.Ex43" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex43.m1" class="ltx_Math" alttext="score(x,y)=\sum_{p\in y}NN_{MLP1}(c(p))=\sum_{p\in y}(g(c(p)\mathbf{W^{1}}+%
\mathbf{b^{1}}))\mathbf{w}" display="block"><mrow><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM698">x</mi><mo>,</mo><mi id="XM699">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder><mrow><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mrow><mi>M</mi><mo>⁢</mo><mi>L</mi><mo>⁢</mo><mi>P</mi><mo>⁢</mo><mn>1</mn></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM701"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM700">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo largeop="true" movablelimits="false" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></munder><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM704"><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM703"><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM702">p</mi><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mn>𝟏</mn></msup></mrow><mo>+</mo><msup><mi>𝐛</mi><mn>𝟏</mn></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>𝐰</mi></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p15" class="ltx_para ltx_noindent">
<p class="ltx_p"><math id="S8.SS2.p15.m1" class="ltx_Math" alttext="c(p)\in\mathbb{R}^{d_{in}}" display="inline"><mrow><mrow><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM705">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></msup></mrow></math>,
<math id="S8.SS2.p15.m2" class="ltx_Math" alttext="\mathbf{W^{1}}\in\mathbb{R}^{d_{in}\times d_{1}}" display="inline"><mrow><msup><mi>𝐖</mi><mn>𝟏</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></msup></mrow></math>,
<math id="S8.SS2.p15.m3" class="ltx_Math" alttext="\mathbf{b^{1}}\in\mathbb{R}^{d_{1}}" display="inline"><mrow><msup><mi>𝐛</mi><mn>𝟏</mn></msup><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mn>1</mn></msub></msup></mrow></math>,
<math id="S8.SS2.p15.m4" class="ltx_Math" alttext="\mathbf{w}\in\mathbb{R}^{d_{1}}" display="inline"><mrow><mi>𝐰</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mn>1</mn></msub></msup></mrow></math>.
A common objective in structured prediction is making the gold structure <math id="S8.SS2.p15.m5" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math>
score higher than any other structure <math id="S8.SS2.p15.m6" class="ltx_Math" alttext="y^{\prime}" display="inline"><msup><mi>y</mi><mo>′</mo></msup></math>, leading to the following
(generalized perceptron) loss:</p>
</div>
<div id="S8.SS2.p16" class="ltx_para">
<table id="S8.Ex44" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex44.m1" class="ltx_Math" alttext="\max_{y^{\prime}}score(x,y^{\prime})-score(x,y)" display="block"><mrow><mrow><mrow><munder><mi>max</mi><msup><mi>y</mi><mo>′</mo></msup></munder><mo>⁡</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi></mrow></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM706">x</mi><mo>,</mo><msup id="XM707"><mi>y</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow><mo>-</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM708">x</mi><mo>,</mo><mi id="XM709">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p17" class="ltx_para">
<p class="ltx_p">In terms of implementation, this means: create a computation graph <math id="S8.SS2.p17.m1" class="ltx_Math" alttext="CG_{p}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msub><mi>G</mi><mi>p</mi></msub></mrow></math> for
each of the possible parts, and calculate its score. Then, run inference over
the scored parts to find the best scoring structure <math id="S8.SS2.p17.m2" class="ltx_Math" alttext="y^{\prime}" display="inline"><msup><mi>y</mi><mo>′</mo></msup></math>. Connect the output
nodes of the computation graphs corresponding to parts in the gold (predicted)
structure <math id="S8.SS2.p17.m3" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> (<math id="S8.SS2.p17.m4" class="ltx_Math" alttext="y^{\prime}" display="inline"><msup><mi>y</mi><mo>′</mo></msup></math>) into a summing node <math id="S8.SS2.p17.m5" class="ltx_Math" alttext="CG_{y}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msub><mi>G</mi><mi>y</mi></msub></mrow></math> (<math id="S8.SS2.p17.m6" class="ltx_Math" alttext="CG_{y}^{\prime}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msubsup><mi>G</mi><mi>y</mi><mo>′</mo></msubsup></mrow></math>). Connect <math id="S8.SS2.p17.m7" class="ltx_Math" alttext="CG_{y}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msub><mi>G</mi><mi>y</mi></msub></mrow></math> and
<math id="S8.SS2.p17.m8" class="ltx_Math" alttext="CG_{y}^{\prime}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msubsup><mi>G</mi><mi>y</mi><mo>′</mo></msubsup></mrow></math> using a “minus” node, <math id="S8.SS2.p17.m9" class="ltx_Math" alttext="CG_{l}" display="inline"><mrow><mi>C</mi><mo>⁢</mo><msub><mi>G</mi><mi>l</mi></msub></mrow></math>, and compute the gradients.</p>
</div>
<div id="S8.SS2.p18" class="ltx_para">
<p class="ltx_p">As argued in <cite class="ltx_cite">[, Section 5]</cite>, the generalized perceptron loss may not be
a good loss function when training structured prediction neural networks as it
does not have a margin, and a margin-based hinge loss is preferred:</p>
</div>
<div id="S8.SS2.p19" class="ltx_para">
<table id="S8.Ex45" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex45.m1" class="ltx_Math" alttext="max(0,m+score(x,y)-\max_{y^{\prime}\neq y}score(x,y^{\prime}))" display="block"><mrow><mi>m</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn id="XM715">0</mn><mo>,</mo><mrow id="XM716"><mrow><mi>m</mi><mo>+</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM710">x</mi><mo>,</mo><mi id="XM711">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mrow><munder><mi>max</mi><mrow><msup><mi>y</mi><mo>′</mo></msup><mo>≠</mo><mi>y</mi></mrow></munder><mo>⁡</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi></mrow></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM712">x</mi><mo>,</mo><msup id="XM714"><mi>y</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.p20" class="ltx_para ltx_noindent">
<p class="ltx_p">It is trivial to modify the implementation above to work with the hinge loss.</p>
</div>
<div id="S8.SS2.p21" class="ltx_para">
<p class="ltx_p">Note that in both cases we lose the nice properties of the linear model. In particular,
the model is no longer convex. This is to be expected, as even the simplest non-linear neural
network is already non-convex. Nonetheless, we could still use standard
neural-network optimization techniques to train the structured model.</p>
</div>
<div id="S8.SS2.p22" class="ltx_para">
<p class="ltx_p">Training and inference is slower, as we have to evaluate the neural network (and
take gradients) <math id="S8.SS2.p22.m1" class="ltx_Math" alttext="|parts(x,y)|" display="inline"><mrow><mo stretchy="false">|</mo><mrow id="XM719"><mi>p</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM717">x</mi><mo>,</mo><mi id="XM718">y</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></math> times.</p>
</div>
<div id="S8.SS2.p23" class="ltx_para">
<p class="ltx_p">Structured prediction is a vast field and is beyond the scope of this tutorial,
but loss functions, regularizers and methods described in, e.g.,
<cite class="ltx_cite">[]</cite>, such as cost-augmented decoding, can be easily
applied or adapted to the neural-network framework.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">23</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">23</sup>One should keep in
mind that the resulting objectives are no longer convex, and so lack the formal
guarantees and bounds associated with convex optimization problems. Similarly,
the theory, learning bounds and guarantees associated with the algorithms do not
automatically transfer to the neural versions.</span></span></span></p>
</div>
<section id="S8.SS2.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Probabilistic objective (CRF)</h5>

<div id="S8.SS2.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">In a probabilistic framework (“CRF”), we treat each of the parts scores as a
<em class="ltx_emph">clique potential</em> (see <cite class="ltx_cite">[]</cite>) and define the score of each structure <math id="S8.SS2.SSS5.Px1.p1.m1" class="ltx_Math" alttext="y" display="inline"><mi>y</mi></math> to be:</p>
<table id="S8.Ex46" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S8.Ex46.m1" class="ltx_Math" alttext="score_{CRF}(x,y)=P(y|x)=\frac{\sum_{p\in y}e^{score(p)}}{\sum_{y^{\prime}\in%
\mathcal{Y}(x)}\sum_{p\in y^{\prime}}e^{score(p)}}=\frac{\sum_{p\in y}e^{NN(c(%
p))}}{\sum_{y^{\prime}\in\mathcal{Y}(x)}\sum_{p\in y^{\prime}}e^{NN(c(p))}}" display="block"><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>C</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>F</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi id="XM728">x</mi><mo>,</mo><mi id="XM729">y</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">|</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></msub><msup><mi>e</mi><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM720">p</mi><mo stretchy="false">)</mo></mrow></mrow></msup></mrow><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><msup><mi>y</mi><mo>′</mo></msup><mo>∈</mo><mrow><mi class="ltx_font_mathcaligraphic">𝒴</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM721">x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><msup><mi>y</mi><mo>′</mo></msup></mrow></msub><msup><mi>e</mi><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM722">p</mi><mo stretchy="false">)</mo></mrow></mrow></msup></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><mi>y</mi></mrow></msub><msup><mi>e</mi><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM724"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM723">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></msup></mrow><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><msup><mi>y</mi><mo>′</mo></msup><mo>∈</mo><mrow><mi class="ltx_font_mathcaligraphic">𝒴</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM725">x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mi>p</mi><mo>∈</mo><msup><mi>y</mi><mo>′</mo></msup></mrow></msub><msup><mi>e</mi><mrow><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM727"><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM726">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></msup></mrow></mrow></mfrac></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S8.SS2.SSS5.Px1.p2" class="ltx_para">
<p class="ltx_p">The scoring function defines a conditional distribution <math id="S8.SS2.SSS5.Px1.p2.m1" class="ltx_Math" alttext="P(y|x)" display="inline"><mrow><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">|</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math>, and we wish to
set the parameters of the network such that corpus conditional log likelihood
<math id="S8.SS2.SSS5.Px1.p2.m2" class="ltx_Math" alttext="\sum_{(x_{i},y_{i})\in training}\log P(y_{i}|x_{i})" display="inline"><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mrow><mo stretchy="false">(</mo><msub id="XM730"><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub id="XM731"><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo>∈</mo><mrow><mi>t</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>g</mi></mrow></mrow></msub><mi>log</mi><mi>P</mi><mrow><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> is maximized.</p>
</div>
<div id="S8.SS2.SSS5.Px1.p3" class="ltx_para">
<p class="ltx_p">The loss for a given training example <math id="S8.SS2.SSS5.Px1.p3.m1" class="ltx_Math" alttext="(x,y)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM732">x</mi><mo>,</mo><mi id="XM733">y</mi><mo stretchy="false">)</mo></mrow></math> is then: <math id="S8.SS2.SSS5.Px1.p3.m2" class="ltx_Math" alttext="-\log score_{CRF}(x,y)" display="inline"><mrow><mo>-</mo><mrow><mrow><mi>log</mi><mo>⁡</mo><mrow><mi>s</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><msub><mi>e</mi><mrow><mi>C</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>F</mi></mrow></msub></mrow></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM734">x</mi><mo>,</mo><mi id="XM735">y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.
Taking the gradient with respect to the loss is as involved as building the
associated computation graph. The tricky part is the denominator (the
<em class="ltx_emph">partition function</em>) which requires summing over the potentially
exponentially many structures in <math id="S8.SS2.SSS5.Px1.p3.m3" class="ltx_Math" alttext="\mathcal{Y}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒴</mi></math>. However, for some problems, a
dynamic programming algorithm exists for efficiently solving the summation in
polynomial time. When such an algorithm exists, it can be adapted to also create
a polynomial-size computation graph.</p>
</div>
<div id="S8.SS2.SSS5.Px1.p4" class="ltx_para">
<p class="ltx_p">When an efficient enough algorithm for computing the partition function is not
available, approximate methods can be used. For example, one may use beam search
for inference, and for the partition function sum over the structures remaining
in the beam instead of over the exponentially large <math id="S8.SS2.SSS5.Px1.p4.m1" class="ltx_Math" alttext="\mathcal{Y}(x)" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">𝒴</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM736">x</mi><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
<div id="S8.SS2.SSS5.Px1.p5" class="ltx_para">
<p class="ltx_p">A hinge based approached was used by Pei et al <span class="ltx_ERROR undefined">\citeyear</span>pei2015effective for
arc-factored dependency parsing, and the probabilistic approach by Durrett and
Klein <cite class="ltx_cite">[]</cite> for a CRF constituency parser.
The approximate beam-based partition function was effectively used by
Zhou et al <span class="ltx_ERROR undefined">\citeyear</span>zhou2015neural in a transition based parser.</p>
</div>
</section>
<section id="S8.SS2.SSS5.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Reranking</h5>

<div id="S8.SS2.SSS5.Px2.p1" class="ltx_para">
<p class="ltx_p">When searching over all possible structures is
intractable, inefficient or hard to integrate into a model, reranking methods
are often used. In the reranking framework <cite class="ltx_cite">[]</cite>
a base model is used to produce a list of the <math id="S8.SS2.SSS5.Px2.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-best scoring structures.
A more complex model is then trained to score the candidates in the <math id="S8.SS2.SSS5.Px2.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-best
list such that the best structure with respect to the gold one is scored
highest. As the search is now performed over <math id="S8.SS2.SSS5.Px2.p1.m3" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> items rather than over an
exponential space, the complex model can condition on
(extract features from) arbitrary aspects of the scored structure.
Reranking methods are natural candidates for structured prediction using
neural-network models, as they allow the modeler to focus on the feature
extraction and network structure, while removing the need to integrate the
neural network scoring into a decoder. Indeed, reranking methods are often used
for experimenting with neural models that are not straightforward to integrate
into a decoder, such as convolutional, recurrent and recursive networks, which
will be discussed in later sections. Works using the reranking approach include
<cite class="ltx_cite">[]</cite></p>
</div>
</section>
<section id="S8.SS2.SSS5.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">MEMM and hybrid approaches</h5>

<div id="S8.SS2.SSS5.Px3.p1" class="ltx_para">
<p class="ltx_p">Other formulations are, of course, also possible. For example, an MEMM
<cite class="ltx_cite">[]</cite> can be
trivially adapted to the neural network world by replacing the logistic
regression (“Maximum Entropy”) component with an MLP.
</p>
</div>
<div id="S8.SS2.SSS5.Px3.p2" class="ltx_para">
<p class="ltx_p">Hybrid approaches between neural networks and linear models are also explored.
In particular, Weiss et al <cite class="ltx_cite">[]</cite> report strong results for
transition-based dependency parsing in a two-stage model. In the first stage,
a static feed-forward neural
network (MLP2) is trained to perform well on
each of the individual decisions of the structured problem in isolation.
In the second stage, the neural network model is held fixed, and the
different layers (output as well as hidden layer vectors) for each input are
then concatenated and used as the input features of a linear structured
perceptron model <cite class="ltx_cite">[]</cite> that is trained to perform
beam-search for the best resulting
structure. While it is not clear that such training regime is more effective than
training a single structured-prediction neural network, the use of two simpler,
isolated models allowed the researchers to perform a much more extensive hyper-parameter
search (e.g. tuning layer sizes, activation functions, learning rates and so on)
for each model than is feasible with more complicated networks.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
</section>
<section id="S9" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">9 </span>Convolutional Layers</h2>

<div id="S9.p1" class="ltx_para">
<p class="ltx_p">Sometimes we are interested in making predictions based on ordered sets of items
(e.g. the sequence of words in a sentence, the sequence of sentences in a
document and so on). Consider for example predicting the sentiment (positive,
negative or neutral) of a sentence. Some of the sentence words are very
informative of the sentiment, other words are less informative, and to a good
approximation, an informative clue is informative regardless of its position in
the sentence. We would like to feed all of the sentence words into a learner,
and let the training process figure out the important clues. One possible
solution is feeding a CBOW representation into a fully connected
network such as an MLP. However, a downside of the CBOW approach is that it
ignores the ordering information completely, assigning the sentences “it was
not good, it was actually quite bad” and “it was not bad, it was actually
quite good” the exact same representation. While the global position of the
indicators “not good” and “not bad” does not matter for the classification
task, the local ordering of the words (that the word “not” appears right
before the word “bad”) is very important. A naive approach would suggest
embedding word-pairs (bi-grams) rather than words, and building a CBOW over the
embedded bigrams. While such architecture could be effective, it will result in
huge embedding matrices, will not scale for longer n-grams, and will suffer from
data sparsity problems as it does not share statistical strength between
different n-grams (the embedding of “quite good” and “very good” are
completely independent of one another, so if the learner saw only one of them
during training, it will not be able to deduce anything about the other based on
its component words). The convolution-and-pooling (also called convolutional
neural networks, or CNNs) architecture is an elegant and robust solution to the
this modeling problem. A convolutional neural network is designed to identify
indicative local predictors in a large structure, and combine them to produce a
fixed size vector representation of the structure, capturing these local aspects
that are most informative for the prediction task at hand.</p>
</div>
<div id="S9.p2" class="ltx_para">
<p class="ltx_p">Convolution-and-pooling architectures <cite class="ltx_cite">[]</cite> evolved in the neural
networks vision community, where
they showed great success as object detectors – recognizing an object from a
predefined category (“cat”, “bicycles”) regardless of its position in the
image <cite class="ltx_cite">[]</cite>. When applied to images, the architecture is using
2-dimensional (grid) convolutions. When applied to text, NLP we are mainly
concerned with 1-d (sequence) convolutions. Convolutional networks were introduced
to the NLP community in the pioneering work of Collobert, Weston and Colleagues <span class="ltx_ERROR undefined">\citeyear</span>collobert2011natural
who used them for semantic-role labeling, and later by Kalchbrenner et al <span class="ltx_ERROR undefined">\citeyear</span>kalchbrenner2014convolutional
and Kim <cite class="ltx_cite">[]</cite> who used them for sentiment and question-type classification.</p>
</div>
<section id="S9.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.1 </span>Basic Convolution + Pooling</h3>

<div id="S9.SS1.p1" class="ltx_para">
<p class="ltx_p">The main idea behind a convolution and pooling architecture for language tasks
is to apply a non-linear (learned) function over each instantiation of a <math id="S9.SS1.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-word sliding
window over the
sentence. This
function (also called “filter”) transforms a window of <math id="S9.SS1.p1.m2" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> words into a
<math id="S9.SS1.p1.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> dimensional vector that
captures important properties of the words in the window (each dimension is
sometimes referred to in the literature as a “channel”). Then, a “pooling”
operation is used combine the vectors resulting from the different windows into
a single <math id="S9.SS1.p1.m4" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector, by taking the max or the average value observed in each of the
<math id="S9.SS1.p1.m5" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> channels over the different windows. The intention is to focus on the
most important “features” in the sentence, regardless of their location.
The <math id="S9.SS1.p1.m6" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector is then fed further into a network that is used
for prediction. The gradients that are propagated back from the network’s loss
during the training process are used to tune the parameters of the filter
function to highlight the aspects of the data that are important for the task
the network is trained for. Intuitively, when the sliding window is run over a sequence,
the filter function learns to identify informative k-grams.
</p>
</div>
<div id="S9.SS1.p2" class="ltx_para">
<p class="ltx_p">More formally, consider a sequence of words <math id="S9.SS1.p2.m1" class="ltx_Math" alttext="\mathbf{x}=x_{1},\ldots,x_{n}" display="inline"><mrow><mi>𝐱</mi><mo>=</mo><mrow><msub id="XM737"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM738">…</mi><mo>,</mo><msub id="XM739"><mi>x</mi><mi>n</mi></msub></mrow></mrow></math>, each with their
corresponding <math id="S9.SS1.p2.m2" class="ltx_Math" alttext="d_{emb}" display="inline"><msub><mi>d</mi><mrow><mi>e</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>b</mi></mrow></msub></math> dimensional word embedding <math id="S9.SS1.p2.m3" class="ltx_Math" alttext="v(x_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM740"><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>. A <math id="S9.SS1.p2.m4" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>d convolution
layer<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">24</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">24</sup><math id="S9.SS1.p2.m5" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>d here refers to a convolution operating over 1-dimensional
inputs such as sequences, as opposed to 2d convolutions which are
applied to images.</span></span></span> of width <math id="S9.SS1.p2.m6" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> works by moving a sliding window of size <math id="S9.SS1.p2.m7" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> over the
sentence, and applying the same “filter” to each window in the sequence
<math id="S9.SS1.p2.m8" class="ltx_Math" alttext="(v(x_{i});v(x_{i+1}),\ldots;v(x_{i+k-1})" display="inline"><mrow><mo stretchy="false">(</mo><mi>v</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo>;</mo><mi>v</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><mo>,</mo><mi mathvariant="normal" id="XM749">…</mi><mo>;</mo><mi>v</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mrow><mi>i</mi><mo>+</mo><mi>k</mi></mrow><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></math>.
The filter function is usually a linear transformation followed by a non-linear activation function.</p>
</div>
<div id="S9.SS1.p3" class="ltx_para">
<p class="ltx_p">Let the concatenated vector of the <math id="S9.SS1.p3.m1" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>th window be <math id="S9.SS1.p3.m2" class="ltx_Math" alttext="\mathbf{w_{i}}=v(x_{i});v(x_{i+1});v(x_{i+k-1})" display="inline"><mrow><msub><mi>𝐰</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mrow id="XM754"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM751"><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM755"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM752"><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM756"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM753"><mi>x</mi><mrow><mrow><mi>i</mi><mo>+</mo><mi>k</mi></mrow><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, <math id="S9.SS1.p3.m3" class="ltx_Math" alttext="\mathbf{w_{i}}\in\mathbb{R}^{kd_{emb}}" display="inline"><mrow><msub><mi>𝐰</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>k</mi><mo>⁢</mo><msub><mi>d</mi><mrow><mi>e</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>b</mi></mrow></msub></mrow></msup></mrow></math>.
Depending on whether we pad the sentence with <math id="S9.SS1.p3.m4" class="ltx_Math" alttext="k-1" display="inline"><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></math> words to each side, we may
get either <math id="S9.SS1.p3.m5" class="ltx_Math" alttext="m=n-k+1" display="inline"><mrow><mi>m</mi><mo>=</mo><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow><mo>+</mo><mn>1</mn></mrow></mrow></math> (<em class="ltx_emph">narrow convolution</em>) or <math id="S9.SS1.p3.m6" class="ltx_Math" alttext="m=n+k+1" display="inline"><mrow><mi>m</mi><mo>=</mo><mrow><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mrow></math> windows (<em class="ltx_emph">wide
convolution</em>) <cite class="ltx_cite">[]</cite>.
The result of the convolution layer is <math id="S9.SS1.p3.m7" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math> vectors <math id="S9.SS1.p3.m8" class="ltx_Math" alttext="\mathbf{p_{1}},\ldots,\mathbf{p_{m}}" display="inline"><mrow><msub id="XM757"><mi>𝐩</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM758">…</mi><mo>,</mo><msub id="XM759"><mi>𝐩</mi><mi>𝐦</mi></msub></mrow></math>, <math id="S9.SS1.p3.m9" class="ltx_Math" alttext="\mathbf{p_{i}}\in\mathbb{R}^{d_{conv}}" display="inline"><mrow><msub><mi>𝐩</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></msup></mrow></math> where:</p>
<table id="S13.EGx17" class="ltx_equationgroup ltx_eqn_align">

<tr id="S9.Ex47" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S9.Ex47.m1" class="ltx_Math" alttext="\displaystyle\mathbf{p_{i}}=g(\mathbf{w_{i}}\mathbf{W}+\mathbf{b})" display="inline"><mrow><msub><mi>𝐩</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM761"><mrow><msub><mi>𝐰</mi><mi>𝐢</mi></msub><mo>⁢</mo><mi>𝐖</mi></mrow><mo>+</mo><mi>𝐛</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">.</p>
</div>
<div id="S9.SS1.p4" class="ltx_para">
<p class="ltx_p"><math id="S9.SS1.p4.m1" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> is a non-linear activation function that is applied element-wise, <math id="S9.SS1.p4.m2" class="ltx_Math" alttext="\mathbf{W}\in\mathbb{R}^{k\cdot d_{emb}\times d_{conv}}" display="inline"><mrow><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mrow><mi>k</mi><mo>⋅</mo><msub><mi>d</mi><mrow><mi>e</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>b</mi></mrow></msub></mrow><mo>×</mo><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></mrow></msup></mrow></math> and <math id="S9.SS1.p4.m3" class="ltx_Math" alttext="\mathbf{b}\in\mathbb{R}^{d_{conv}}" display="inline"><mrow><mi>𝐛</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></msup></mrow></math> are parameters of the network. Each <math id="S9.SS1.p4.m4" class="ltx_Math" alttext="\mathbf{p_{i}}" display="inline"><msub><mi>𝐩</mi><mi>𝐢</mi></msub></math> is a
<math id="S9.SS1.p4.m5" class="ltx_Math" alttext="d_{conv}" display="inline"><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></math> dimensional vector, encoding the information in <math id="S9.SS1.p4.m6" class="ltx_Math" alttext="\mathbf{w_{i}}" display="inline"><msub><mi>𝐰</mi><mi>𝐢</mi></msub></math>. Ideally,
each dimension captures a different kind of indicative information. The <math id="S9.SS1.p4.m7" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math>
vectors are then combined using a <em class="ltx_emph">max pooling layer</em>, resulting in a
single <math id="S9.SS1.p4.m8" class="ltx_Math" alttext="d_{conv}" display="inline"><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></math> dimensional vector <math id="S9.SS1.p4.m9" class="ltx_Math" alttext="\mathbf{c}" display="inline"><mi>𝐜</mi></math>.</p>
</div>
<div id="S9.SS1.p5" class="ltx_para">
<table id="S9.Ex48" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S9.Ex48.m1" class="ltx_Math" alttext="c_{j}=\max_{1&lt;i\leq m}\mathbf{p_{i}}[j]" display="block"><mrow><msub><mi>c</mi><mi>j</mi></msub><mo>=</mo><mrow><mrow><munder><mi>max</mi><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow></munder><mo>⁡</mo><msub><mi>𝐩</mi><mi>𝐢</mi></msub></mrow><mo>⁢</mo><mrow><mo stretchy="false">[</mo><mi id="XM762">j</mi><mo stretchy="false">]</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S9.SS1.p6" class="ltx_para ltx_noindent">
<p class="ltx_p"><math id="S9.SS1.p6.m1" class="ltx_Math" alttext="\mathbf{p_{i}}[j]" display="inline"><mrow><msub><mi>𝐩</mi><mi>𝐢</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">[</mo><mi id="XM763">j</mi><mo stretchy="false">]</mo></mrow></mrow></math> denotes the <math id="S9.SS1.p6.m2" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>th component of <math id="S9.SS1.p6.m3" class="ltx_Math" alttext="\mathbf{p_{i}}" display="inline"><msub><mi>𝐩</mi><mi>𝐢</mi></msub></math>.
The effect of the max-pooling operation is to get the most salient information across
window positions. Ideally, each dimension will “specialize” in a particular
sort of predictors, and max operation will pick on the most important
predictor of each type.</p>
</div>
<div id="S9.SS1.p7" class="ltx_para">
<p class="ltx_p">Figure <a href="#S9.F4" title="Figure 4 ‣ 9.1 Basic Convolution + Pooling ‣ 9 Convolutional Layers ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> provides an illustration of the process.</p>
</div>
<figure id="S9.F4" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.9]cnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 4: </span><math id="S9.F4.m7" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>d convolution+pooling over the sentence “the quick brown fox
jumped over the lazy dog”. This is a narrow convolution (no padding is added to
the sentence) with a window size of 3. Each word is translated to a <math id="S9.F4.m8" class="ltx_Math" alttext="2" display="inline"><mn>2</mn></math>-dim
embedding vector (not shown). The embedding vectors are then concatenated,
resulting in <math id="S9.F4.m9" class="ltx_Math" alttext="6" display="inline"><mn>6</mn></math>-dim window representations.
Each of the seven windows is transfered through a <math id="S9.F4.m10" class="ltx_Math" alttext="6\times 3" display="inline"><mrow><mn>6</mn><mo>×</mo><mn>3</mn></mrow></math> filter (linear transformation followed by element-wise tanh),
resulting in seven <math id="S9.F4.m11" class="ltx_Math" alttext="3" display="inline"><mn>3</mn></math>-dimensional filtered representations. Then, a max-pooling
operation is applied, taking the max over each dimension, resulting in a final
<math id="S9.F4.m12" class="ltx_Math" alttext="3" display="inline"><mn>3</mn></math>-dimensional pooled vector.</figcaption>
</figure>
<div id="S9.SS1.p8" class="ltx_para">
<p class="ltx_p">The resulting vector <math id="S9.SS1.p8.m1" class="ltx_Math" alttext="\mathbf{c}" display="inline"><mi>𝐜</mi></math> is a representation of the sentence in which each dimension
reflects the most salient information with respect to some prediction task.
<math id="S9.SS1.p8.m2" class="ltx_Math" alttext="\mathbf{c}" display="inline"><mi>𝐜</mi></math> is then fed into a downstream network layers, perhaps in parallel to
other vectors, culminating in an output layer which is used for prediction. The
training procedure of the network calculates the loss with respect to the
prediction task, and the error gradients are propagated all the way back through
the pooling and convolution layers, as well as the embedding layers.
<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">25</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">25</sup>Besides being useful for prediction, a by-product of the training
procedure is a set of parameters <math id="S9.SS1.p8.m3" class="ltx_Math" alttext="\mathbf{W}" display="inline"><mi>𝐖</mi></math>, <math id="S9.SS1.p8.m4" class="ltx_Math" alttext="\mathbf{B}" display="inline"><mi>𝐁</mi></math> and embeddings <math id="S9.SS1.p8.m5" class="ltx_Math" alttext="v()" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow></mrow></math> that can
be used in a convolution and pooling architecture to encode arbitrary length
sentences into fixed-size vectors, such that sentences that share the same kind
of predictive information will be close to each other.</span></span></span></p>
</div>
<div id="S9.SS1.p9" class="ltx_para">
<p class="ltx_p">While max-pooling is the most common pooling operation in text applications,
other pooling operations are also possible, the second most common operation
being <em class="ltx_emph">average pooling</em>, taking the average value of each index instead of
the max.</p>
</div>
</section>
<section id="S9.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.2 </span>Dynamic, Hierarchical and k-max Pooling</h3>

<div id="S9.SS2.p1" class="ltx_para">
<p class="ltx_p">Rather than performing a single pooling operation over the entire sequence, we
may want to retain some positional information based on our domain understanding
of the prediction problem at hand. To this end, we can split the vectors
<math id="S9.SS2.p1.m1" class="ltx_Math" alttext="\mathbf{p_{i}}" display="inline"><msub><mi>𝐩</mi><mi>𝐢</mi></msub></math> into <math id="S9.SS2.p1.m2" class="ltx_Math" alttext="\ell" display="inline"><mi mathvariant="normal">ℓ</mi></math> distinct groups, apply the pooling separately on each group,
and then concatenate the <math id="S9.SS2.p1.m3" class="ltx_Math" alttext="\ell" display="inline"><mi mathvariant="normal">ℓ</mi></math> resulting <math id="S9.SS2.p1.m4" class="ltx_Math" alttext="d_{conv}" display="inline"><msub><mi>d</mi><mrow><mi>c</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>n</mi><mo>⁢</mo><mi>v</mi></mrow></msub></math> vectors <math id="S9.SS2.p1.m5" class="ltx_Math" alttext="\mathbf{c_{1}},\ldots,\mathbf{c_{\ell}}" display="inline"><mrow><msub id="XM764"><mi>𝐜</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM765">…</mi><mo>,</mo><msub id="XM766"><mi>𝐜</mi><mi mathvariant="normal">ℓ</mi></msub></mrow></math>. The division of the <math id="S9.SS2.p1.m6" class="ltx_Math" alttext="\mathbf{p_{i}}" display="inline"><msub><mi>𝐩</mi><mi>𝐢</mi></msub></math>s into groups is performed
based on domain knowledge. For example, we may conjecture that words appearing
early in the sentence are more indicative than words appearing late. We
can then split the sequence into <math id="S9.SS2.p1.m7" class="ltx_Math" alttext="\ell" display="inline"><mi mathvariant="normal">ℓ</mi></math> equally sized regions, applying a separate
max-pooling to each region. For example, Johnson and Zhang
<cite class="ltx_cite">[]</cite> found
that when classifying documents into topics, it is useful to have 20
average-pooling regions, clearly separating the initial sentences (where
the topic is usually introduced) from later ones, while for a sentiment
classification task a single max-pooling operation over the entire sentence was
optimal (suggesting that one or two very strong signals are enough to determine
the sentiment, regardless of the position in the sentence).</p>
</div>
<div id="S9.SS2.p2" class="ltx_para">
<p class="ltx_p">Similarly, in a relation extraction kind of task we may be given two words and
asked to determine the relation between them. We could argue that the words
before the first word, the words after the second word, and the words between
them provide three different kinds of information <cite class="ltx_cite">[]</cite>. We can thus
split the <math id="S9.SS2.p2.m1" class="ltx_Math" alttext="\mathbf{p_{i}}" display="inline"><msub><mi>𝐩</mi><mi>𝐢</mi></msub></math> vectors accordingly, pooling separately the windows
resulting from each group.
</p>
</div>
<div id="S9.SS2.p3" class="ltx_para">
<p class="ltx_p">Another variation is performing <em class="ltx_emph">hierarchical pooling</em>, in which we have a
succession of convolution and pooling layers, where each stage applies a
convolution to a sequence, pools every <math id="S9.SS2.p3.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> neighboring vectors, performs a
convolution on the resulting pooled sequence, applies another convolution and so
on. This architecture allows sensitivity to increasingly larger structures.</p>
</div>
<div id="S9.SS2.p4" class="ltx_para">
<p class="ltx_p">Finally, <cite class="ltx_cite">[]</cite> introduced a <em class="ltx_emph">k-max pooling</em>
operation, in which the top <math id="S9.SS2.p4.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> values in each dimension are retained instead of
only the best one, while preserving the order in which they appeared in the
text.
For example a, consider the following matrix:</p>
</div>
<div id="S9.SS2.p5" class="ltx_para ltx_noindent">
<table id="S9.Ex49" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S9.Ex49.m1" class="ltx_Math" alttext="\begin{bmatrix}1&amp;2&amp;3\\
9&amp;6&amp;5\\
2&amp;3&amp;1\\
7&amp;8&amp;1\\
3&amp;4&amp;1\\
\end{bmatrix}" display="block"><mrow><mo>[</mo><mtable displaystyle="true" id="S9.Ex49.m1.xm1"><mtr id="S9.Ex49.m1.xm1a"><mtd columnalign="center" id="S9.Ex49.m1.xm1b"><mn>1</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1c"><mn>2</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1d"><mn>3</mn></mtd></mtr><mtr id="S9.Ex49.m1.xm1e"><mtd columnalign="center" id="S9.Ex49.m1.xm1f"><mn>9</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1g"><mn>6</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1h"><mn>5</mn></mtd></mtr><mtr id="S9.Ex49.m1.xm1i"><mtd columnalign="center" id="S9.Ex49.m1.xm1j"><mn>2</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1k"><mn>3</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1l"><mn>1</mn></mtd></mtr><mtr id="S9.Ex49.m1.xm1m"><mtd columnalign="center" id="S9.Ex49.m1.xm1n"><mn>7</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1o"><mn>8</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1p"><mn>1</mn></mtd></mtr><mtr id="S9.Ex49.m1.xm1q"><mtd columnalign="center" id="S9.Ex49.m1.xm1r"><mn>3</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1s"><mn>4</mn></mtd><mtd columnalign="center" id="S9.Ex49.m1.xm1t"><mn>1</mn></mtd></mtr></mtable><mo>]</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">A 1-max pooling over the column vectors will result in
<math id="S9.SS2.p5.m1" class="ltx_Math" alttext="\begin{bmatrix}9&amp;8&amp;5\\
\end{bmatrix}" display="inline"><mrow><mo>[</mo><mtable id="S9.SS2.p5.m1.xm1"><mtr id="S9.SS2.p5.m1.xm1a"><mtd columnalign="center" id="S9.SS2.p5.m1.xm1b"><mn>9</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m1.xm1c"><mn>8</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m1.xm1d"><mn>5</mn></mtd></mtr></mtable><mo>]</mo></mrow></math>, while a 2-max pooling will result in
the following matrix:
<math id="S9.SS2.p5.m2" class="ltx_Math" alttext="\begin{bmatrix}9&amp;6&amp;3\\
7&amp;8&amp;5\\
\end{bmatrix}" display="inline"><mrow><mo>[</mo><mtable id="S9.SS2.p5.m2.xm1"><mtr id="S9.SS2.p5.m2.xm1a"><mtd columnalign="center" id="S9.SS2.p5.m2.xm1b"><mn>9</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m2.xm1c"><mn>6</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m2.xm1d"><mn>3</mn></mtd></mtr><mtr id="S9.SS2.p5.m2.xm1e"><mtd columnalign="center" id="S9.SS2.p5.m2.xm1f"><mn>7</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m2.xm1g"><mn>8</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m2.xm1h"><mn>5</mn></mtd></mtr></mtable><mo>]</mo></mrow></math> whose rows will then be concatenated to <math id="S9.SS2.p5.m3" class="ltx_Math" alttext="\begin{bmatrix}9&amp;6&amp;3&amp;7&amp;8&amp;5\\
\end{bmatrix}" display="inline"><mrow><mo>[</mo><mtable id="S9.SS2.p5.m3.xm1"><mtr id="S9.SS2.p5.m3.xm1a"><mtd columnalign="center" id="S9.SS2.p5.m3.xm1b"><mn>9</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m3.xm1c"><mn>6</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m3.xm1d"><mn>3</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m3.xm1e"><mn>7</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m3.xm1f"><mn>8</mn></mtd><mtd columnalign="center" id="S9.SS2.p5.m3.xm1g"><mn>5</mn></mtd></mtr></mtable><mo>]</mo></mrow></math></p>
</div>
<div id="S9.SS2.p6" class="ltx_para">
<p class="ltx_p">The k-max pooling operation makes it possible
to pool the <math id="S9.SS2.p6.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> most active indicators that may be
a number of positions apart; it preserves the order
of the features, but is insensitive to their specific
positions. It can also discern more finely the number
of times the feature is highly activated <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S9.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">9.3 </span>Variations</h3>

<div id="S9.SS3.p1" class="ltx_para">
<p class="ltx_p">Rather than a single convolutional layer, several convolutional layers may be
applied in parallel. For example, we may have four different convolutional
layers, each with a different window size in the range 2–5, capturing n-gram
sequences of varying lengths.
The result of each convolutional layer will then
be pooled, and the resulting vectors concatenated and fed to further processing
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S9.SS3.p2" class="ltx_para">
<p class="ltx_p">The convolutional architecture need not be restricted into the linear ordering
of a sentence. For example, Ma et al <span class="ltx_ERROR undefined">\citeyear</span>ma2015dependencybased generalize the
convolution operation to work over syntactic dependency trees. There, each
window is around a node in the syntactic tree, and the pooling is performed over the different nodes.
Similarly, Liu et al <span class="ltx_ERROR undefined">\citeyear</span>liu2015dependencybased apply a convolutional
architecture on top of dependency paths extracted from dependency trees.
Le and Zuidema <span class="ltx_ERROR undefined">\citeyear</span>le2015forest propose to perform max pooling
over vectors representing the different derivations leading to the same chart
item in a chart parser.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S10" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">10 </span>Recurrent Neural Networks – Modeling Sequences and Stacks</h2>

<div id="S10.p1" class="ltx_para">
<p class="ltx_p">When dealing with language data, it is very common to work with sequences, such
as words (sequences of letters), sentences (sequences of words) and documents.
We saw how feed-forward networks can accommodate arbitrary feature functions over
sequences through the use of vector concatenation and vector addition (CBOW).
In particular, the CBOW representations allows to encode arbitrary length
sequences as fixed sized vectors.
However, the
CBOW representation is quite limited, and forces one to disregard the order of
features. The convolutional networks also allow encoding a sequence into a
fixed size vector. While representations derived from convolutional networks
are an improvement above the CBOW representation as they offer some sensitivity
to word order, their order sensitivity is restricted to mostly local patterns,
and disregards the order of patterns that are far apart in the sequence.</p>
</div>
<div id="S10.p2" class="ltx_para">
<p class="ltx_p">Recurrent neural networks (RNNs) <cite class="ltx_cite">[]</cite> allow representing
arbitrarily sized structured
inputs in a fixed-size vector, while paying attention to the structured
properties of the input.</p>
</div>
<section id="S10.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">10.1 </span>The RNN Abstraction</h3>

<div id="S10.SS1.p1" class="ltx_para">
<p class="ltx_p">We use <math id="S10.SS1.p1.m1" class="ltx_Math" alttext="\mathbf{x_{i:j}}" display="inline"><msub><mi>𝐱</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐣</mi></mrow></msub></math> to denote the sequence of vectors <math id="S10.SS1.p1.m2" class="ltx_Math" alttext="\mathbf{x_{i}},\ldots,\mathbf{x_{j}}" display="inline"><mrow><msub id="XM767"><mi>𝐱</mi><mi>𝐢</mi></msub><mo>,</mo><mi mathvariant="normal" id="XM768">…</mi><mo>,</mo><msub id="XM769"><mi>𝐱</mi><mi>𝐣</mi></msub></mrow></math>.
The RNN abstraction takes as input an ordered list of input vectors
<math id="S10.SS1.p1.m3" class="ltx_Math" alttext="\mathbf{x_{1}},...,\mathbf{x_{n}}" display="inline"><mrow><msub id="XM770"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM771">…</mi><mo>,</mo><msub id="XM772"><mi>𝐱</mi><mi>𝐧</mi></msub></mrow></math> together with an initial <em class="ltx_emph">state vector</em> <math id="S10.SS1.p1.m4" class="ltx_Math" alttext="\mathbf{s_{0}}" display="inline"><msub><mi>𝐬</mi><mn>𝟎</mn></msub></math>,
and returns an ordered list of state vectors <math id="S10.SS1.p1.m5" class="ltx_Math" alttext="\mathbf{s_{1}},...,\mathbf{s_{n}}" display="inline"><mrow><msub id="XM773"><mi>𝐬</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM774">…</mi><mo>,</mo><msub id="XM775"><mi>𝐬</mi><mi>𝐧</mi></msub></mrow></math>, as well as
an ordered list of <em class="ltx_emph">output vectors</em> <math id="S10.SS1.p1.m6" class="ltx_Math" alttext="\mathbf{y_{1}},...,\mathbf{y_{n}}" display="inline"><mrow><msub id="XM776"><mi>𝐲</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM777">…</mi><mo>,</mo><msub id="XM778"><mi>𝐲</mi><mi>𝐧</mi></msub></mrow></math>. An output vector
<math id="S10.SS1.p1.m7" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> is a function of the corresponding state vector <math id="S10.SS1.p1.m8" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math>.
The input vectors <math id="S10.SS1.p1.m9" class="ltx_Math" alttext="\mathbf{x_{i}}" display="inline"><msub><mi>𝐱</mi><mi>𝐢</mi></msub></math> are presented to the RNN in a sequential fashion, and
the state vector <math id="S10.SS1.p1.m10" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> and output vector <math id="S10.SS1.p1.m11" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> represent the state of the RNN after observing the
inputs <math id="S10.SS1.p1.m12" class="ltx_Math" alttext="\mathbf{x_{1:i}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐢</mi></mrow></msub></math>. The output vector <math id="S10.SS1.p1.m13" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> is then used for further
prediction. For example, a model for predicting the conditional
probability of an event <math id="S10.SS1.p1.m14" class="ltx_Math" alttext="e" display="inline"><mi>e</mi></math> given the sequence <math id="S10.SS1.p1.m15" class="ltx_Math" alttext="\mathbf{m_{1:i}}" display="inline"><msub><mi>𝐦</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐢</mi></mrow></msub></math> can be defined as
<math id="S10.SS1.p1.m16" class="ltx_Math" alttext="p(e=j|\mathbf{x_{1:i}})=softmax(\mathbf{y_{i}}\mathbf{W}+\mathbf{b})[j]" display="inline"><mrow><mi>p</mi><mrow><mo stretchy="false">(</mo><mi>e</mi><mo>=</mo><mi>j</mi><mo stretchy="false">|</mo><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐢</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo stretchy="false">(</mo><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mi>𝐖</mi><mo>+</mo><mi>𝐛</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></mrow></math>. The RNN model provides
a framework for conditioning on the entire history <math id="S10.SS1.p1.m17" class="ltx_Math" alttext="\mathbf{x_{1}},\ldots,\mathbf{x_{i}}" display="inline"><mrow><msub id="XM779"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM780">…</mi><mo>,</mo><msub id="XM781"><mi>𝐱</mi><mi>𝐢</mi></msub></mrow></math>
without resorting to the Markov assumption which is traditionally used for modeling
sequences. Indeed, RNN-based language models result in very good perplexity
scores when compared to n-gram based models.</p>
</div>
<div id="S10.SS1.p2" class="ltx_para">
<p class="ltx_p">Mathematically, we have a recursively defined function <math id="S10.SS1.p2.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> that takes as input a
state vector <math id="S10.SS1.p2.m2" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> and an input vector <math id="S10.SS1.p2.m3" class="ltx_Math" alttext="\mathbf{x_{i+1}}" display="inline"><msub><mi>𝐱</mi><mrow><mi>𝐢</mi><mo>+</mo><mn>𝟏</mn></mrow></msub></math>, and results in a new
state vector <math id="S10.SS1.p2.m4" class="ltx_Math" alttext="\mathbf{s_{i+1}}" display="inline"><msub><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>+</mo><mn>𝟏</mn></mrow></msub></math>. An additional function <math id="S10.SS1.p2.m5" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math> is used to map a state
vector <math id="S10.SS1.p2.m6" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> to an output vector <math id="S10.SS1.p2.m7" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math>.
When constructing an RNN, much like when constructing a feed-forward network,
one has to specify the dimension of the inputs <math id="S10.SS1.p2.m8" class="ltx_Math" alttext="\mathbf{x_{i}}" display="inline"><msub><mi>𝐱</mi><mi>𝐢</mi></msub></math> as well as the
dimensions of the outputs <math id="S10.SS1.p2.m9" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math>. The dimensions of the states <math id="S10.SS1.p2.m10" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> are
a function of the output dimension.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">26</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">26</sup>While RNN architectures in which the state dimension
is independent of the output dimension are possible, the current popular
architectures, including the Simple RNN, the LSTM and the GRU do not follow this
flexibility.</span></span></span></p>
</div>
<div id="S10.SS1.p3" class="ltx_para">
<table id="S13.EGx18" class="ltx_equationgroup ltx_eqn_align">

<tr id="S10.Ex50" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex50.m1" class="ltx_Math" alttext="\displaystyle RNN(\mathbf{s_{0}},\mathbf{x_{1:n}})=" display="inline"><mrow><mrow><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM786"><mi>𝐬</mi><mn>𝟎</mn></msub><mo>,</mo><msub id="XM787"><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex50.m2" class="ltx_Math" alttext="\displaystyle\mathbf{s_{1:n}},\;\mathbf{y_{1:n}}" display="inline"><mrow><msub id="XM788"><mi>𝐬</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub><mo rspace="5.3pt">,</mo><msub id="XM789"><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S10.Ex51" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex51.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex51.m2" class="ltx_Math" alttext="\displaystyle=R(\mathbf{s_{i-1}},\mathbf{x_{i}})" display="inline"><mrow><mi></mi><mo>=</mo><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM792"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>,</mo><msub id="XM793"><mi>𝐱</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S10.Ex52" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex52.m1" class="ltx_Math" alttext="\displaystyle\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex52.m2" class="ltx_Math" alttext="\displaystyle=O(\mathbf{s_{i}})" display="inline"><mrow><mi></mi><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM795"><mi>𝐬</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<table id="S10.Ex54" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S10.Ex54.m1" class="ltx_Math" alttext="\mathbf{x_{i}}\in\mathbb{R}^{d_{in}},\;\;\mathbf{y_{i}}\in\mathbb{R}^{d_{out}}%
,\;\;\mathbf{s_{i}}\in\mathbb{R}^{f(d_{out})}" display="block"><mrow><mrow id="XM799"><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>i</mi><mo>⁢</mo><mi>n</mi></mrow></msub></msup></mrow><mo rspace="8.1pt">,</mo><mrow><mrow id="XM797"><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub></msup></mrow><mo rspace="8.1pt">,</mo><mrow id="XM798"><msub><mi>𝐬</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM796"><mi>d</mi><mrow><mi>o</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></msup></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S10.SS1.p4" class="ltx_para">
<p class="ltx_p">The functions <math id="S10.SS1.p4.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> and <math id="S10.SS1.p4.m2" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math> are the same across the sequence positions, but the
RNN keeps track of the states of computation through the state vector that is
kept and being passed between invocations of <math id="S10.SS1.p4.m3" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math>.</p>
</div>
<div id="S10.SS1.p5" class="ltx_para">
<p class="ltx_p">Graphically, the RNN has been traditionally presented as in Figure
<a href="#S10.F5" title="Figure 5 ‣ 10.1 The RNN Abstraction ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>.</p>
</div>
<figure id="S10.F5" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.3]rnn-cycle.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Graphical representation of an RNN (recursive).</figcaption>
</figure>
<div id="S10.SS1.p6" class="ltx_para ltx_noindent">
<p class="ltx_p">This presentation follows the recursive definition, and is correct for
arbitrary long sequences. However, for a finite sized input sequence (and all
input sequences we deal with are finite) one can <em class="ltx_emph">unroll</em> the recursion,
resulting in the structure in Figure <a href="#S10.F6" title="Figure 6 ‣ 10.1 The RNN Abstraction ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.</p>
</div>
<figure id="S10.F6" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.8]rnn-unrolled.pdf</p>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Graphical representation of an RNN (unrolled).</figcaption>
</figure>
<div id="S10.SS1.p7" class="ltx_para ltx_noindent">
<p class="ltx_p">While not usually shown in the visualization, we include here the parameters <math id="S10.SS1.p7.m1" class="ltx_Math" alttext="\theta" display="inline"><mi>θ</mi></math>
in order to highlight the fact that the same parameters are shared across all time steps.
Different instantiations of <math id="S10.SS1.p7.m2" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> and <math id="S10.SS1.p7.m3" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math> will result in different network
structures, and will exhibit different properties in terms of their running
times and their ability to be trained effectively using gradient-based methods.
However, they all adhere to the same abstract interface. We will provide details
of concrete instantiations of <math id="S10.SS1.p7.m4" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> and <math id="S10.SS1.p7.m5" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math> – the Simple RNN, the LSTM and the
GRU – in Section <a href="#S11" title="11 Concrete RNN Architectures ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a>.
Before that, let’s consider modeling with the RNN abstraction.</p>
</div>
<div id="S10.SS1.p8" class="ltx_para">
<p class="ltx_p">First, we note that the value of <math id="S10.SS1.p8.m1" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> is based on the entire input <math id="S10.SS1.p8.m2" class="ltx_Math" alttext="\mathbf{x_{1}},...,\mathbf{x_{i}}" display="inline"><mrow><msub id="XM801"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM802">…</mi><mo>,</mo><msub id="XM803"><mi>𝐱</mi><mi>𝐢</mi></msub></mrow></math>.
For example, by expanding the recursion for <math id="S10.SS1.p8.m3" class="ltx_Math" alttext="i=4" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>4</mn></mrow></math> we get:
</p>
</div>
<div id="S10.SS1.p9" class="ltx_para">
<table id="S13.EGx19" class="ltx_equationgroup ltx_eqn_align">

<tr id="S10.Ex55" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex55.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s_{4}}=" display="inline"><mrow><msub><mi>𝐬</mi><mn>𝟒</mn></msub><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex55.m2" class="ltx_Math" alttext="\displaystyle R(\mathbf{s_{3}},\mathbf{x_{4}})" display="inline"><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM806"><mi>𝐬</mi><mn>𝟑</mn></msub><mo>,</mo><msub id="XM807"><mi>𝐱</mi><mn>𝟒</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S10.Ex56" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex56.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex56.m2" class="ltx_Math" alttext="\displaystyle R(\overbrace{R(\mathbf{s_{2}},\mathbf{x_{3}})}^{\mathbf{s_{3}}},%
\mathbf{x_{4}})" display="inline"><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover id="XM814"><mover accent="true"><mrow><mi>R</mi><mo movablelimits="false">⁢</mo><mrow><mo movablelimits="false" stretchy="false">(</mo><msub id="XM812"><mi>𝐬</mi><mn>𝟐</mn></msub><mo movablelimits="false">,</mo><msub id="XM813"><mi>𝐱</mi><mn>𝟑</mn></msub><mo movablelimits="false" stretchy="false">)</mo></mrow></mrow><mo movablelimits="false">⏞</mo></mover><msub><mi>𝐬</mi><mn>𝟑</mn></msub></mover><mo>,</mo><msub id="XM815"><mi>𝐱</mi><mn>𝟒</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S10.Ex57" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex57.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex57.m2" class="ltx_Math" alttext="\displaystyle R(R(\overbrace{R(\mathbf{s_{1}},\mathbf{x_{2}})}^{\mathbf{s_{2}}%
},\mathbf{x_{3}}),\mathbf{x_{4}})" display="inline"><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM834"><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover id="XM832"><mover accent="true"><mrow><mi>R</mi><mo movablelimits="false">⁢</mo><mrow><mo movablelimits="false" stretchy="false">(</mo><msub id="XM826"><mi>𝐬</mi><mn>𝟏</mn></msub><mo movablelimits="false">,</mo><msub id="XM827"><mi>𝐱</mi><mn>𝟐</mn></msub><mo movablelimits="false" stretchy="false">)</mo></mrow></mrow><mo movablelimits="false">⏞</mo></mover><msub><mi>𝐬</mi><mn>𝟐</mn></msub></mover><mo>,</mo><msub id="XM833"><mi>𝐱</mi><mn>𝟑</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM835"><mi>𝐱</mi><mn>𝟒</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S10.Ex58" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S10.Ex58.m1" class="ltx_Math" alttext="\displaystyle=" display="inline"><mo>=</mo></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S10.Ex58.m2" class="ltx_Math" alttext="\displaystyle R(R(R(\overbrace{R(\mathbf{s_{0}},\mathbf{x_{1}})}^{\mathbf{s_{1%
}}},\mathbf{x_{2}}),\mathbf{x_{3}}),\mathbf{x_{4}})" display="inline"><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM898"><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM896"><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover id="XM894"><mover accent="true"><mrow><mi>R</mi><mo movablelimits="false">⁢</mo><mrow><mo movablelimits="false" stretchy="false">(</mo><msub id="XM868"><mi>𝐬</mi><mn>𝟎</mn></msub><mo movablelimits="false">,</mo><msub id="XM869"><mi>𝐱</mi><mn>𝟏</mn></msub><mo movablelimits="false" stretchy="false">)</mo></mrow></mrow><mo movablelimits="false">⏞</mo></mover><msub><mi>𝐬</mi><mn>𝟏</mn></msub></mover><mo>,</mo><msub id="XM895"><mi>𝐱</mi><mn>𝟐</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM897"><mi>𝐱</mi><mn>𝟑</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub id="XM899"><mi>𝐱</mi><mn>𝟒</mn></msub><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S10.SS1.p10" class="ltx_para">
<p class="ltx_p">Thus, <math id="S10.SS1.p10.m1" class="ltx_Math" alttext="\mathbf{s_{n}}" display="inline"><msub><mi>𝐬</mi><mi>𝐧</mi></msub></math> (as well as <math id="S10.SS1.p10.m2" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>) could be thought of as <em class="ltx_emph">encoding</em> the entire input
sequence.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">27</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">27</sup>Note that, unless <math id="S10.SS1.p10.m3" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> is specifically designed against this,
it is likely that the later elements of the input sequence have stronger effect
on <math id="S10.SS1.p10.m4" class="ltx_Math" alttext="\mathbf{s_{n}}" display="inline"><msub><mi>𝐬</mi><mi>𝐧</mi></msub></math> than earlier ones.</span></span></span>
Is the encoding useful? This depends on our definition of usefulness. The job of
the network training is to set the parameters of <math id="S10.SS1.p10.m5" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> and <math id="S10.SS1.p10.m6" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math> such that the state
conveys useful information for the task we are tying to solve.</p>
</div>
</section>
<section id="S10.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">10.2 </span>RNN Training</h3>

<div id="S10.SS2.p1" class="ltx_para">
<p class="ltx_p">Viewed as in Figure <a href="#S10.F6" title="Figure 6 ‣ 10.1 The RNN Abstraction ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> it is easy to see that an unrolled RNN is just a
very deep neural network (or rather, a very large <em class="ltx_emph">computation graph</em> with
somewhat complex nodes), in which the same parameters are shared across many
parts of the computation. To train an RNN network, then, all we need to do is to
create the unrolled computation graph for a given input sequence, add a loss
node to the unrolled graph, and then use the backward (backpropagation)
algorithm to compute the gradients with respect to that loss. This procedure is
referred to in the RNN literature as <em class="ltx_emph">backpropagation through time</em>, or
BPTT <cite class="ltx_cite">[]</cite>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">28</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">28</sup>Variants of the BPTT algorithm include unrolling the RNN
only for a fixed number of input symbols at each time: first unroll the RNN for
inputs <math id="S10.SS2.p1.m1" class="ltx_Math" alttext="\mathbf{x_{1:k}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐤</mi></mrow></msub></math>, resulting in <math id="S10.SS2.p1.m2" class="ltx_Math" alttext="\mathbf{s_{1:k}}" display="inline"><msub><mi>𝐬</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐤</mi></mrow></msub></math>. Compute a loss, and
backpropagate the error through the network (<math id="S10.SS2.p1.m3" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> steps back). Then, unroll the
inputs <math id="S10.SS2.p1.m4" class="ltx_Math" alttext="\mathbf{x_{k+1:2k}}" display="inline"><msub><mi>𝐱</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mrow><mn>𝟐</mn><mo>⁢</mo><mi>𝐤</mi></mrow></mrow></msub></math>, this time using <math id="S10.SS2.p1.m5" class="ltx_Math" alttext="\mathbf{s_{k}}" display="inline"><msub><mi>𝐬</mi><mi>𝐤</mi></msub></math> as the initial state, and
again backpropagate the error for <math id="S10.SS2.p1.m6" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> steps, and so on. This strategy is based
on the observations that for the Simple-RNN variant, the gradients after <math id="S10.SS2.p1.m7" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>
steps tend to vanish (for large enough <math id="S10.SS2.p1.m8" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>), and so omitting them is negligible.
This procedure allows training of arbitrarily long sequences. For RNN variants
such as the LSTM or the GRU that are designed specifically to mitigate the
vanishing gradients problem, this fixed size unrolling is less motivated,
yet it is still being used, for example when doing language modeling over a book
without breaking it into sentences.</span></span></span> There are various ways in which the
supervision signal can be applied.</p>
</div>
<section id="S10.SS2.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Acceptor</h5>

<div id="S10.SS2.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">One option is to base the supervision signal only on the
final output vector, <math id="S10.SS2.SSS5.Px1.p1.m1" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>. Viewed this way, the RNN is an
<em class="ltx_emph">acceptor</em>.
We observe the final state, and then decide on an outcome.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">29</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">29</sup>The terminology is borrowed from Finite-State
Acceptors. However, the RNN has a potentially infinite number of states, making
it necessary to rely on a function other than a lookup table for mapping states to
decisions.</span></span></span>
For example, consider training an RNN to read the characters of a word one by
one and then use the final state to predict the part-of-speech of that word
(this is inspired by <cite class="ltx_cite">[]</cite>), an RNN that reads in a sentence and,
based on the final state decides if it conveys positive or negative sentiment
(this is inspired by <cite class="ltx_cite">[]</cite>) or an RNN that reads in a sequence of words
and decides whether it is a valid noun-phrase.
The loss in such cases is defined in terms of a function of <math id="S10.SS2.SSS5.Px1.p1.m2" class="ltx_Math" alttext="\mathbf{y_{n}}=O(\mathbf{s_{n}})" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐧</mi></msub><mo>=</mo><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM900"><mi>𝐬</mi><mi>𝐧</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, and the
error gradients will backpropagate through the rest of the
sequence (see Figure <a href="#S10.F7" title="Figure 7 ‣ Acceptor ‣ 10.2 RNN Training ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>).<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">30</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">30</sup>This kind of supervision signal may be hard to train for long
sequences, especially so with the Simple-RNN, because of the vanishing gradients problem.
It is also a generally hard learning task, as we do not tell the process on which parts of the input to focus.</span></span></span>
The loss can take any familiar form – cross entropy, hinge, margin, etc.</p>
</div>
<figure id="S10.F7" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.6]acceptor-rnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>Acceptor RNN Training Graph.</figcaption>
</figure>
</section>
<section id="S10.SS2.SSS5.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Encoder</h5>

<div id="S10.SS2.SSS5.Px2.p1" class="ltx_para">
<p class="ltx_p">Similar to the acceptor case, an encoder supervision uses only the final output
vector, <math id="S10.SS2.SSS5.Px2.p1.m1" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>. However, unlike the acceptor, where a prediction is made solely on the basis of
the final vector, here the final vector is treated as an encoding of the information in the sequence,
and is used as additional information together with other signals. For example, an extractive document
summarization system may first run over the document with an RNN, resulting in a
vector <math id="S10.SS2.SSS5.Px2.p1.m2" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math> summarizing the entire document. Then, <math id="S10.SS2.SSS5.Px2.p1.m3" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math> will be used
together with with other features in order to select the sentences to be included in the summarization.</p>
</div>
</section>
<section id="S10.SS2.SSS5.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Transducer</h5>

<div id="S10.SS2.SSS5.Px3.p1" class="ltx_para">
<p class="ltx_p">Another option is to treat the RNN as a transducer,
producing an output for each input it reads in. Modeled this way, we can compute
a local loss signal <math id="S10.SS2.SSS5.Px3.p1.m1" class="ltx_Math" alttext="L_{local}(\mathbf{\hat{y_{i}}},\mathbf{y_{i}})" display="inline"><mrow><msub><mi>L</mi><mrow><mi>l</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>l</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM901"><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">^</mo></mover><mo>,</mo><msub id="XM902"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> for each of the outputs
<math id="S10.SS2.SSS5.Px3.p1.m2" class="ltx_Math" alttext="\mathbf{\hat{y_{i}}}" display="inline"><mover accent="true"><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">^</mo></mover></math> based on a true label <math id="S10.SS2.SSS5.Px3.p1.m3" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math>. The loss for unrolled sequence
will then be: <math id="S10.SS2.SSS5.Px3.p1.m4" class="ltx_Math" alttext="L(\mathbf{\hat{y_{1:n}}},\mathbf{y_{1:n}})=\sum_{i=1}^{n}{L_{local}(\mathbf{%
\hat{y_{i}}},\mathbf{y_{i}})}" display="inline"><mrow><mrow><mi>L</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM903"><msub><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub><mo stretchy="false">^</mo></mover><mo>,</mo><msub id="XM904"><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mo largeop="true" symmetric="true">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><msub><mi>L</mi><mrow><mi>l</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>l</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mover accent="true" id="XM905"><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">^</mo></mover><mo>,</mo><msub id="XM906"><mi>𝐲</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>, or using another combination rather
than a sum such as an average or a weighted average (see Figure
<a href="#S10.F8" title="Figure 8 ‣ Transducer ‣ 10.2 RNN Training ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>). One example for such a
transducer is a sequence tagger, in which we take <math id="S10.SS2.SSS5.Px3.p1.m5" class="ltx_Math" alttext="\mathbf{x_{i:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐧</mi></mrow></msub></math> to be feature
representations for the <math id="S10.SS2.SSS5.Px3.p1.m6" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> words of a sentence, and <math id="S10.SS2.SSS5.Px3.p1.m7" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> as an input for
predicting the tag
assignment of word <math id="S10.SS2.SSS5.Px3.p1.m8" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> based on words <math id="S10.SS2.SSS5.Px3.p1.m9" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>:<math id="S10.SS2.SSS5.Px3.p1.m10" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>.
A CCG super-tagger based on such an
architecture provides state-of-the art CCG super-tagging results
<cite class="ltx_cite">[]</cite>.</p>
</div>
<figure id="S10.F8" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.6]transducer-rnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Transducer RNN Training Graph.</figcaption>
</figure>
<div id="S10.SS2.SSS5.Px3.p2" class="ltx_para">
<p class="ltx_p">A very natural use-case of the transduction setup is for
language modeling, in which the sequence of words <math id="S10.SS2.SSS5.Px3.p2.m1" class="ltx_Math" alttext="\mathbf{x_{1:i}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐢</mi></mrow></msub></math> is used to
predict a distribution over the <math id="S10.SS2.SSS5.Px3.p2.m2" class="ltx_Math" alttext="i+1" display="inline"><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></math>th word. RNN based language models are shown to
provide much better perplexities than traditional language models
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S10.SS2.SSS5.Px3.p3" class="ltx_para">
<p class="ltx_p">Using RNNs as transducers allows us to relax the Markov assumption that is
traditionally taken in language models and HMM taggers, and condition on the
entire prediction history. The power of the ability to condition on arbitrarily long
histories is demonstrated in generative character-level RNN models, in which
a text is generated character by character, each character conditioning on the
previous ones <cite class="ltx_cite">[]</cite>. The generated texts show sensitivity to properties that are not
captured by n-gram language models, including line lengths and nested
parenthesis balancing. For a good demonstration and analysis of the properties of
RNN-based character level
language models, see <cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S10.SS2.SSS5.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Encoder - Decoder</h5>

<div id="S10.SS2.SSS5.Px4.p1" class="ltx_para">
<p class="ltx_p">Finally, an important special case of the encoder scenario
is the Encoder-Decoder framework <cite class="ltx_cite">[]</cite>.
The RNN is used to encode the sequence
into a vector representation <math id="S10.SS2.SSS5.Px4.p1.m1" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>, and this vector representation is then used
as auxiliary input to another RNN that is used as a decoder. For example, in a machine-translation
setup the first RNN encodes the source sentence
into a vector representation <math id="S10.SS2.SSS5.Px4.p1.m2" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>, and then this state vector is fed into a separate
(decoder) RNN that is trained to predict (using a transducer-like language modeling objective)
the words of the target language sentence based on the previously predicted
words as well as <math id="S10.SS2.SSS5.Px4.p1.m3" class="ltx_Math" alttext="\mathbf{y_{n}}" display="inline"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></math>.
The supervision happens only for the decoder RNN,
but the gradients are propagated all the way back to the encoder RNN (see Figure
<a href="#S10.F9" title="Figure 9 ‣ Encoder - Decoder ‣ 10.2 RNN Training ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>).</p>
</div>
<figure id="S10.F9" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.8]encdec-rnn2.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 9: </span>Encoder-Decoder RNN Training Graph.</figcaption>
</figure>
<div id="S10.SS2.SSS5.Px4.p2" class="ltx_para">
<p class="ltx_p">Such an
approach was shown to be surprisingly effective for Machine Translation
<cite class="ltx_cite">[]</cite> using LSTM RNNs. In order for this technique to work,
Sutskever et al found it effective to input the source sentence in reverse,
such that <math id="S10.SS2.SSS5.Px4.p2.m1" class="ltx_Math" alttext="\mathbf{x_{n}}" display="inline"><msub><mi>𝐱</mi><mi>𝐧</mi></msub></math> corresponds to the first word of the sentence. In this way,
it is easier for the second RNN to establish the relation between the first word
of the source sentence to the first word of the target sentence.
Another use-case of the encoder-decoder framework is for sequence transduction.
Here, in order to generate tags <math id="S10.SS2.SSS5.Px4.p2.m2" class="ltx_Math" alttext="t_{1},\ldots,t_{n}" display="inline"><mrow><msub id="XM907"><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM908">…</mi><mo>,</mo><msub id="XM909"><mi>t</mi><mi>n</mi></msub></mrow></math>, an encoder RNN is first used
to encode the sentence <math id="S10.SS2.SSS5.Px4.p2.m3" class="ltx_Math" alttext="\mathbf{x_{1:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></math> into fixed sized vector. This vector is then fed as the
initial state vector of another (transducer) RNN, which is used together with <math id="S10.SS2.SSS5.Px4.p2.m4" class="ltx_Math" alttext="\mathbf{x_{1:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></math>
to predict the label <math id="S10.SS2.SSS5.Px4.p2.m5" class="ltx_Math" alttext="t_{i}" display="inline"><msub><mi>t</mi><mi>i</mi></msub></math> at each position <math id="S10.SS2.SSS5.Px4.p2.m6" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>. This approach was used in
<cite class="ltx_cite">[]</cite> to model sentence compression by deletion.</p>
</div>
</section>
</section>
<section id="S10.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">10.3 </span>Multi-layer (stacked) RNNs</h3>

<div id="S10.SS3.p1" class="ltx_para">
<p class="ltx_p">RNNs can be stacked in layers, forming a
grid <cite class="ltx_cite">[]</cite>. Consider <math id="S10.SS3.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> RNNs, <math id="S10.SS3.p1.m2" class="ltx_Math" alttext="RNN_{1},\ldots,RNN_{k}" display="inline"><mrow><mrow id="XM910"><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mn>1</mn></msub></mrow><mo>,</mo><mi mathvariant="normal" id="XM911">…</mi><mo>,</mo><mrow id="XM912"><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><msub><mi>N</mi><mi>k</mi></msub></mrow></mrow></math>,
where the <math id="S10.SS3.p1.m3" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>th RNN has states <math id="S10.SS3.p1.m4" class="ltx_Math" alttext="\mathbf{s_{1:n}^{j}}" display="inline"><msubsup><mi>𝐬</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow><mi>𝐣</mi></msubsup></math> and outputs <math id="S10.SS3.p1.m5" class="ltx_Math" alttext="\mathbf{y_{1:n}^{j}}" display="inline"><msubsup><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow><mi>𝐣</mi></msubsup></math>.
The input for the first RNN are <math id="S10.SS3.p1.m6" class="ltx_Math" alttext="\mathbf{x_{1:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></math>, while the input of the
<math id="S10.SS3.p1.m7" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>th RNN (<math id="S10.SS3.p1.m8" class="ltx_Math" alttext="j\geq 2" display="inline"><mrow><mi>j</mi><mo>≥</mo><mn>2</mn></mrow></math>) are the outputs of the RNN below it, <math id="S10.SS3.p1.m9" class="ltx_Math" alttext="\mathbf{y_{1:n}^{j-1}}" display="inline"><msubsup><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msubsup></math>.
The output of the entire formation is the output of the last RNN,
<math id="S10.SS3.p1.m10" class="ltx_Math" alttext="\mathbf{y_{1:n}^{k}}" display="inline"><msubsup><mi>𝐲</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow><mi>𝐤</mi></msubsup></math>.
Such layered architectures are often called <em class="ltx_emph">deep RNNs</em>. A visual
representation of a 3-layer RNN is given in Figure <a href="#S10.F10" title="Figure 10 ‣ 10.3 Multi-layer (stacked) RNNs ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a>.</p>
</div>
<figure id="S10.F10" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.6]stacked-rnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 10: </span>A 3-layer (“deep”) RNN architecture.</figcaption>
</figure>
<div id="S10.SS3.p2" class="ltx_para">
<p class="ltx_p">While it is not theoretically clear what is
the additional power gained by the deeper architecture, it was observed
empirically that deep RNNs work better than shallower ones on some tasks.
In particular, Sutskever et al <span class="ltx_ERROR undefined">\citeyear</span>sutskever2014sequence report that a
4-layers deep architecture was crucial in achieving good machine-translation
performance in an encoder-decoder framework. Irsoy and Cardie
<span class="ltx_ERROR undefined">\citeyear</span>irsoy2014opinion also report improved results from moving from a
one-layer BI-RNN to an architecture with several layers.
Many other works report result
using layered RNN architectures, but do not explicitly compare to
1-layer RNNs.</p>
</div>
</section>
<section id="S10.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">10.4 </span>BI-RNN</h3>

<div id="S10.SS4.p1" class="ltx_para">
<p class="ltx_p">A useful elaboration of an RNN is a <em class="ltx_emph">bidirectional-RNN</em> (BI-RNN)
<cite class="ltx_cite">[]</cite>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">31</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">31</sup>When used with a
specific RNN architecture such as an LSTM, the model is called BI-LSTM.</span></span></span>
Consider the task of sequence tagging over a sentence <math id="S10.SS4.p1.m1" class="ltx_Math" alttext="x_{1},\ldots,x_{n}" display="inline"><mrow><msub id="XM913"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM914">…</mi><mo>,</mo><msub id="XM915"><mi>x</mi><mi>n</mi></msub></mrow></math>.
An RNN allows us to compute a function
of the <math id="S10.SS4.p1.m2" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>th word <math id="S10.SS4.p1.m3" class="ltx_Math" alttext="x_{i}" display="inline"><msub><mi>x</mi><mi>i</mi></msub></math> based on the past – the words <math id="S10.SS4.p1.m4" class="ltx_Math" alttext="x_{1:i}" display="inline"><msub><mi>x</mi><mrow><mn>1</mn><mo>:</mo><mi>i</mi></mrow></msub></math> up to and including it.
However, the following words <math id="S10.SS4.p1.m5" class="ltx_Math" alttext="x_{i:n}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>n</mi></mrow></msub></math> may also be useful for prediction, as is
evident by the common sliding-window approach in which the focus word is
categorized based on a window of <math id="S10.SS4.p1.m6" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> words surrounding it.
Much like the RNN relaxes the Markov assumption and allows looking
arbitrarily back into the past, the BI-RNN relaxes the fixed
window size assumption, allowing to look arbitrarily far at both the past and
the future.</p>
</div>
<div id="S10.SS4.p2" class="ltx_para">
<p class="ltx_p">Consider an input sequence <math id="S10.SS4.p2.m1" class="ltx_Math" alttext="\mathbf{x_{1:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></math>.
The BI-RNN works by maintaining two separate states, <math id="S10.SS4.p2.m2" class="ltx_Math" alttext="\mathbf{s^{f}_{i}}" display="inline"><msubsup><mi>𝐬</mi><mi>𝐢</mi><mi>𝐟</mi></msubsup></math> and <math id="S10.SS4.p2.m3" class="ltx_Math" alttext="\mathbf{s^{b}_{i}}" display="inline"><msubsup><mi>𝐬</mi><mi>𝐢</mi><mi>𝐛</mi></msubsup></math> for each input position <math id="S10.SS4.p2.m4" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>.
The <em class="ltx_emph">forward state</em> <math id="S10.SS4.p2.m5" class="ltx_Math" alttext="\mathbf{s^{f}_{i}}" display="inline"><msubsup><mi>𝐬</mi><mi>𝐢</mi><mi>𝐟</mi></msubsup></math> is based on <math id="S10.SS4.p2.m6" class="ltx_Math" alttext="\mathbf{x_{1}},\mathbf{x_{2}},\ldots,\mathbf{x_{i}}" display="inline"><mrow><msub id="XM916"><mi>𝐱</mi><mn>𝟏</mn></msub><mo>,</mo><msub id="XM917"><mi>𝐱</mi><mn>𝟐</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM918">…</mi><mo>,</mo><msub id="XM919"><mi>𝐱</mi><mi>𝐢</mi></msub></mrow></math>, while the
<em class="ltx_emph">backward state</em> <math id="S10.SS4.p2.m7" class="ltx_Math" alttext="\mathbf{s^{b}_{i}}" display="inline"><msubsup><mi>𝐬</mi><mi>𝐢</mi><mi>𝐛</mi></msubsup></math> is based on <math id="S10.SS4.p2.m8" class="ltx_Math" alttext="\mathbf{x_{n}},\mathbf{x_{n-1}},\ldots,\mathbf{x_{i}}" display="inline"><mrow><msub id="XM920"><mi>𝐱</mi><mi>𝐧</mi></msub><mo>,</mo><msub id="XM921"><mi>𝐱</mi><mrow><mi>𝐧</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>,</mo><mi mathvariant="normal" id="XM922">…</mi><mo>,</mo><msub id="XM923"><mi>𝐱</mi><mi>𝐢</mi></msub></mrow></math>.
The forward and backward states are generated by two different RNNs. The first
RNN (<math id="S10.SS4.p2.m9" class="ltx_Math" alttext="R^{f}" display="inline"><msup><mi>R</mi><mi>f</mi></msup></math>, <math id="S10.SS4.p2.m10" class="ltx_Math" alttext="O^{f}" display="inline"><msup><mi>O</mi><mi>f</mi></msup></math>)
is fed the input sequence <math id="S10.SS4.p2.m11" class="ltx_Math" alttext="\mathbf{x_{1:n}}" display="inline"><msub><mi>𝐱</mi><mrow><mn>𝟏</mn><mo>:</mo><mi>𝐧</mi></mrow></msub></math> as is, while the second RNN (<math id="S10.SS4.p2.m12" class="ltx_Math" alttext="R^{b}" display="inline"><msup><mi>R</mi><mi>b</mi></msup></math>, <math id="S10.SS4.p2.m13" class="ltx_Math" alttext="O^{b}" display="inline"><msup><mi>O</mi><mi>b</mi></msup></math>) is fed the
input sequence in reverse.
The state representation <math id="S10.SS4.p2.m14" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> is then composed of both the forward and
backward states.</p>
</div>
<div id="S10.SS4.p3" class="ltx_para">
<p class="ltx_p">The output at position <math id="S10.SS4.p3.m1" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> is based on the concatenation of the two output
vectors <math id="S10.SS4.p3.m2" class="ltx_Math" alttext="\mathbf{y_{i}}=[\mathbf{y^{f}_{i}};\mathbf{y^{b}_{i}}]=[O^{f}(\mathbf{s^{f}_{i%
}});O^{b}(\mathbf{s^{b}_{i}})]" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mo stretchy="false">[</mo><msubsup id="XM924"><mi>𝐲</mi><mi>𝐢</mi><mi>𝐟</mi></msubsup><mo>;</mo><msubsup id="XM925"><mi>𝐲</mi><mi>𝐢</mi><mi>𝐛</mi></msubsup><mo stretchy="false">]</mo></mrow><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow id="XM928"><msup><mi>O</mi><mi>f</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup id="XM926"><mi>𝐬</mi><mi>𝐢</mi><mi>𝐟</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM929"><msup><mi>O</mi><mi>b</mi></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup id="XM927"><mi>𝐬</mi><mi>𝐢</mi><mi>𝐛</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">]</mo></mrow></mrow></math>,
taking into account both the past and the future.
The vector <math id="S10.SS4.p3.m3" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> can then be used directly for prediction, or fed as part of the
input to a more complex network.
While the two RNNs are run independently of each other, the error gradients at
position <math id="S10.SS4.p3.m4" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> will flow both forward and backward through the two RNNs. A
visual
representation of the BI-RNN architecture is given in Figure <a href="#S10.F11" title="Figure 11 ‣ 10.4 BI-RNN ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a>.</p>
</div>
<figure id="S10.F11" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.8]bi-rnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 11: </span>BI-RNN over the sentence “the brown fox jumped .”.</figcaption>
</figure>
<div id="S10.SS4.p4" class="ltx_para">
<p class="ltx_p">The use of BI-RNNs for sequence tagging was introduced to the NLP community by
Irsoy and Cardie <span class="ltx_ERROR undefined">\citeyear</span>irsoy2014opinion.</p>
</div>
</section>
<section id="S10.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">10.5 </span>RNNs for Representing Stacks</h3>

<div id="S10.SS5.p1" class="ltx_para">
<p class="ltx_p">Some algorithms in language processing, including those for transition-based
parsing <cite class="ltx_cite">[]</cite>, require performing feature extraction over a
stack. Instead of being confined to looking at the <math id="S10.SS5.p1.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> top-most elements of the
stack, the RNN framework can be used to provide a fixed-sized vector encoding of
the entire stack.</p>
</div>
<div id="S10.SS5.p2" class="ltx_para">
<p class="ltx_p">The main intuition is that a stack is essentially a sequence, and so the stack
state can be represented by taking the stack elements and feeding them in order
into an RNN, resulting in a final encoding of the entire stack. In order to do
this computation efficiently (without performing an <math id="S10.SS5.p2.m1" class="ltx_Math" alttext="O(n)" display="inline"><mrow><mi>O</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM930">n</mi><mo stretchy="false">)</mo></mrow></mrow></math> stack encoding
operation each time the stack changes), the RNN state is maintained together
with the stack state. If the stack was push-only, this would be trivial:
whenever a new element <math id="S10.SS5.p2.m2" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math> is pushed into the stack, the corresponding vector
<math id="S10.SS5.p2.m3" class="ltx_Math" alttext="\mathbf{x}" display="inline"><mi>𝐱</mi></math> will be used together with the RNN state <math id="S10.SS5.p2.m4" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> in order to obtain a
new state <math id="S10.SS5.p2.m5" class="ltx_Math" alttext="\mathbf{s_{i+1}}" display="inline"><msub><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>+</mo><mn>𝟏</mn></mrow></msub></math>. Dealing with pop operation is more challenging, but
can be solved by using the persistent-stack data-structure
<cite class="ltx_cite">[]</cite>. Persistent, or immutable,
data-structures keep old versions of themselves intact when modified.
The persistent stack construction represents a stack as a pointer
to the head of a linked list. An empty stack is the empty list.
The push operation appends an element to the list, returning the new head.
The pop operation then returns the parent of the head, but keeping the original
list intact. From the point of view of someone who held a pointer to the
previous head, the stack did not change. A subsequent push operation will add a
new child to the same node. Applying this procedure throughout the lifetime of
the stack results in a tree, where the root is an empty stack and each path from
a node to the root represents an intermediary stack state. Figure
<a href="#S10.F12" title="Figure 12 ‣ 10.5 RNNs for Representing Stacks ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a> provides an example of such a tree.
The same process can be applied in the computation graph construction, creating
an RNN with a tree structure instead of a chain structure. Backpropagating the
error from a given node will then affect all the elements that participated in
the stack when the node was created, in order. Figure <a href="#S10.F13" title="Figure 13 ‣ 10.5 RNNs for Representing Stacks ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a> shows
the computation graph for the stack-RNN corresponding to the last state in
Figure <a href="#S10.F12" title="Figure 12 ‣ 10.5 RNNs for Representing Stacks ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>.
This modeling approach was proposed independently by Dyer et al and Watanabe et
al <cite class="ltx_cite">[]</cite> for
transition-based dependency parsing.</p>
</div>
<figure id="S10.F12" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.9]stack.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 12: </span>An immutable stack construction for the sequence of operations
<em class="ltx_emph">push a; push b; push c; pop; push d; pop; pop; push e; push f</em>.</figcaption>
</figure>
<figure id="S10.F13" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.7]stack-rnn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 13: </span>The stack-RNN corresponding to the final state in Figure
<a href="#S10.F12" title="Figure 12 ‣ 10.5 RNNs for Representing Stacks ‣ 10 Recurrent Neural Networks – Modeling Sequences and Stacks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>.</figcaption>
</figure>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S11" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">11 </span>Concrete RNN Architectures</h2>

<div id="S11.p1" class="ltx_para">
<p class="ltx_p">We now turn to present three different instantiations of the abstract <math id="S11.p1.m1" class="ltx_Math" alttext="RNN" display="inline"><mrow><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>N</mi></mrow></math>
architecture discussed in the previous section, providing concrete definitions
of the functions <math id="S11.p1.m2" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> and <math id="S11.p1.m3" class="ltx_Math" alttext="O" display="inline"><mi>O</mi></math>. These are the <em class="ltx_emph">Simple RNN</em> (SRNN), the
<em class="ltx_emph">Long Short-Term Memory</em> (LSTM) and the <em class="ltx_emph">Gated Recurrent Unit</em> (GRU).</p>
</div>
<section id="S11.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">11.1 </span>Simple RNN</h3>

<div id="S11.SS1.p1" class="ltx_para">
<p class="ltx_p">The simplest RNN formulation, known as an Elman Network or Simple-RNN (S-RNN),
was proposed by Elman <span class="ltx_ERROR undefined">\citeyear</span>elman1990finding and explored for use in language
modeling by Mikolov <span class="ltx_ERROR undefined">\citeyear</span>mikolov2012statistical. The S-RNN takes the following form:</p>
</div>
<div id="S11.SS1.p2" class="ltx_para">
<table id="S13.EGx20" class="ltx_equationgroup ltx_eqn_align">

<tr id="S11.Ex59" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex59.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s_{i}}=" display="inline"><mrow><msub><mi>𝐬</mi><mi>𝐢</mi></msub><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex59.m2" class="ltx_Math" alttext="\displaystyle R_{SRNN}(\mathbf{s_{i-1}},\mathbf{x_{i}})=g(\mathbf{x_{i}}%
\mathbf{W^{x}}+\mathbf{s_{i-1}}\mathbf{W^{s}}+\mathbf{b})" display="inline"><mrow><mrow><msub><mi>R</mi><mrow><mi>S</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>N</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM934"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>,</mo><msub id="XM935"><mi>𝐱</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM936"><mrow><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐬</mi></msup></mrow><mo>+</mo><mi>𝐛</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex60" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex60.m1" class="ltx_Math" alttext="\displaystyle\mathbf{y_{i}}=" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex60.m2" class="ltx_Math" alttext="\displaystyle O_{SRNN}(\mathbf{s_{i}})=\mathbf{s_{i}}" display="inline"><mrow><mrow><msub><mi>O</mi><mrow><mi>S</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>N</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM938"><mi>𝐬</mi><mi>𝐢</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>𝐬</mi><mi>𝐢</mi></msub></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
<table id="S11.Ex61" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S11.Ex61.m1" class="ltx_Math" alttext="\mathbf{s_{i}},\mathbf{y_{i}}\in\mathbb{R}^{d_{s}},\,\;\mathbf{x_{i}}\in%
\mathbb{R}^{d_{x}},\,\;\mathbf{W^{x}}\in\mathbb{R}^{d_{x}\times d_{s}},\,\;%
\mathbf{W^{s}}\in\mathbb{R}^{d_{s}\times d_{s}},\,\;\mathbf{b}\in\mathbb{R}^{d%
_{s}}" display="block"><mrow><mrow id="XM947"><mrow><msub id="XM939"><mi>𝐬</mi><mi>𝐢</mi></msub><mo>,</mo><msub id="XM940"><mi>𝐲</mi><mi>𝐢</mi></msub></mrow><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>s</mi></msub></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM945"><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>x</mi></msub></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM943"><msup><mi>𝐖</mi><mi>𝐱</mi></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>x</mi></msub><mo>×</mo><msub><mi>d</mi><mi>s</mi></msub></mrow></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM941"><msup><mi>𝐖</mi><mi>𝐬</mi></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>s</mi></msub><mo>×</mo><msub><mi>d</mi><mi>s</mi></msub></mrow></msup></mrow><mo rspace="7pt">,</mo><mrow id="XM942"><mi>𝐛</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>s</mi></msub></msup></mrow></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S11.SS1.p3" class="ltx_para">
<p class="ltx_p">That is, the state at position <math id="S11.SS1.p3.m1" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> is a linear combination of the input at
position <math id="S11.SS1.p3.m2" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> and the previous state, passed through a non-linear activation
(commonly <math id="S11.SS1.p3.m3" class="ltx_Math" alttext="\tanh" display="inline"><mi>tanh</mi></math> or ReLU).
The output at position <math id="S11.SS1.p3.m4" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> is the same as
the hidden state in that position.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">32</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">32</sup>Some authors treat the output at
position <math id="S11.SS1.p3.m5" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> as a more complicated function of the state. In our presentation,
such further transformation of the output are not considered part of the RNN,
but as separate computations that are applied to the RNNs output.
The distinction between the state and the output are needed for the LSTM
architecture, in which not all of the state is observed outside of the RNN.</span></span></span></p>
</div>
<div id="S11.SS1.p4" class="ltx_para">
<p class="ltx_p">In spite of its simplicity, the Simple RNN provides strong results for sequence
tagging <cite class="ltx_cite">[]</cite> as well as language modeling.
For comprehensive discussion on using Simple RNNs for language modeling, see
the PhD thesis by Mikolov <span class="ltx_ERROR undefined">\citeyear</span>mikolov2012statistical.</p>
</div>
</section>
<section id="S11.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">11.2 </span>LSTM</h3>

<div id="S11.SS2.p1" class="ltx_para">
<p class="ltx_p">The S-RNN is hard to train effectively because of the vanishing gradients problem.
Error signals (gradients) in later steps in the sequence diminish in quickly in the back-propagation
process, and do not reach earlier input signals, making it hard for the S-RNN to capture
long-range dependencies. The Long Short-Term Memory (LSTM) architecture <cite class="ltx_cite">[]</cite>
was designed to solve the vanishing gradients problem. The main idea behind the LSTM is
to introduce as part of the state representation also “memory cells” (a vector) that can preserve
gradients across time. Access to the memory cells is controlled by <em class="ltx_emph">gating components</em> – smooth
mathematical functions that simulate logical gates. At each input state, a gate is used to decide how
much of the new input should be written to the memory cell, and how much of the current content of the memory
cell should be forgotten.
Concretely, a gate <math id="S11.SS2.p1.m1" class="ltx_Math" alttext="\mathbf{g}\in[0,1]^{n}" display="inline"><mrow><mi>𝐠</mi><mo>∈</mo><msup><mrow><mo stretchy="false">[</mo><mn id="XM949">0</mn><mo>,</mo><mn id="XM950">1</mn><mo stretchy="false">]</mo></mrow><mi>n</mi></msup></mrow></math> is a vector of values in the range <math id="S11.SS2.p1.m2" class="ltx_Math" alttext="[0,1]" display="inline"><mrow><mo stretchy="false">[</mo><mn id="XM951">0</mn><mo>,</mo><mn id="XM952">1</mn><mo stretchy="false">]</mo></mrow></math> that is multiplied
component-wise with another vector <math id="S11.SS2.p1.m3" class="ltx_Math" alttext="\mathbf{v}\in\mathbb{R}^{n}" display="inline"><mrow><mi>𝐯</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>n</mi></msup></mrow></math>, and the result is then added to another vector.
The values of <math id="S11.SS2.p1.m4" class="ltx_Math" alttext="\mathbf{g}" display="inline"><mi>𝐠</mi></math> are designed to be close to either <math id="S11.SS2.p1.m5" class="ltx_Math" alttext="0" display="inline"><mn>0</mn></math> or <math id="S11.SS2.p1.m6" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math>, i.e. by using a sigmoid function.
Indices in <math id="S11.SS2.p1.m7" class="ltx_Math" alttext="\mathbf{v}" display="inline"><mi>𝐯</mi></math> corresponding to near-one values in <math id="S11.SS2.p1.m8" class="ltx_Math" alttext="\mathbf{g}" display="inline"><mi>𝐠</mi></math> are allowed
to pass, while those corresponding to near-zero values are blocked.</p>
</div>
<div id="S11.SS2.p2" class="ltx_para">
<p class="ltx_p">Mathematically, the LSTM architecture is defined as:<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">33</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">33</sup>There are many variants on the LSTM architecture presented here.
For example, forget gates were not part of the original proposal in <cite class="ltx_cite">[]</cite>, but are shown
to be an important part of the architecture. Other variants include peephole connections and gate-tying.
For an overview and comprehensive empirical comparison of various LSTM architectures see <cite class="ltx_cite">[]</cite>.</span></span></span></p>
</div>
<div id="S11.SS2.p3" class="ltx_para">
<table id="S13.EGx21" class="ltx_equationgroup ltx_eqn_align">

<tr id="S11.Ex62" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex62.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s_{j}}=R_{LSTM}(\mathbf{s_{j-1}},\mathbf{x_{j}})=" display="inline"><mrow><msub><mi>𝐬</mi><mi>𝐣</mi></msub><mo>=</mo><mrow><msub><mi>R</mi><mrow><mi>L</mi><mo>⁢</mo><mi>S</mi><mo>⁢</mo><mi>T</mi><mo>⁢</mo><mi>M</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM957"><mi>𝐬</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>,</mo><msub id="XM958"><mi>𝐱</mi><mi>𝐣</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex62.m2" class="ltx_Math" alttext="\displaystyle[\mathbf{c_{j}};\mathbf{h_{j}}]" display="inline"><mrow><mo stretchy="false">[</mo><msub id="XM959"><mi>𝐜</mi><mi>𝐣</mi></msub><mo>;</mo><msub id="XM960"><mi>𝐡</mi><mi>𝐣</mi></msub><mo stretchy="false">]</mo></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex63" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex63.m1" class="ltx_Math" alttext="\displaystyle\mathbf{c_{j}}=" display="inline"><mrow><msub><mi>𝐜</mi><mi>𝐣</mi></msub><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex63.m2" class="ltx_Math" alttext="\displaystyle\mathbf{c_{j-1}}\odot\mathbf{f}+\mathbf{g}\odot\mathbf{i}" display="inline"><mrow><mrow><msub><mi>𝐜</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⊙</mo><mi>𝐟</mi></mrow><mo>+</mo><mrow><mi>𝐠</mi><mo>⊙</mo><mi>𝐢</mi></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex64" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex64.m1" class="ltx_Math" alttext="\displaystyle\mathbf{h_{j}}=" display="inline"><mrow><msub><mi>𝐡</mi><mi>𝐣</mi></msub><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex64.m2" class="ltx_Math" alttext="\displaystyle\tanh(\mathbf{c_{j}})\odot\mathbf{o}" display="inline"><mrow><mrow><mi id="XM963">tanh</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><msub id="XM964"><mi>𝐜</mi><mi>𝐣</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>⊙</mo><mi>𝐨</mi></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex65" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex65.m1" class="ltx_Math" alttext="\displaystyle\mathbf{i}=" display="inline"><mrow><mi>𝐢</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex65.m2" class="ltx_Math" alttext="\displaystyle\sigma(\mathbf{x_{j}}\mathbf{W^{xi}}+\mathbf{h_{j-1}}\mathbf{W^{%
hi}})" display="inline"><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM966"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐢</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐢</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex66" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex66.m1" class="ltx_Math" alttext="\displaystyle\mathbf{f}=" display="inline"><mrow><mi>𝐟</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex66.m2" class="ltx_Math" alttext="\displaystyle\sigma(\mathbf{x_{j}}\mathbf{W^{xf}}+\mathbf{h_{j-1}}\mathbf{W^{%
hf}})" display="inline"><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM968"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐟</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐟</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex67" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex67.m1" class="ltx_Math" alttext="\displaystyle\mathbf{o}=" display="inline"><mrow><mi>𝐨</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex67.m2" class="ltx_Math" alttext="\displaystyle\sigma(\mathbf{x_{j}}\mathbf{W^{xo}}+\mathbf{h_{j-1}}\mathbf{W^{%
ho}})" display="inline"><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM970"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐨</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐨</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex68" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex68.m1" class="ltx_Math" alttext="\displaystyle\mathbf{g}=" display="inline"><mrow><mi>𝐠</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex68.m2" class="ltx_Math" alttext="\displaystyle\tanh(\mathbf{x_{j}}\mathbf{W^{xg}}+\mathbf{h_{j-1}}\mathbf{W^{hg%
}})" display="inline"><mrow><mi id="XM973">tanh</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow id="XM974"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐠</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐠</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex70" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex70.m1" class="ltx_Math" alttext="\displaystyle\mathbf{y_{j}}=O_{LSTM}(\mathbf{s_{j}})=" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐣</mi></msub><mo>=</mo><mrow><msub><mi>O</mi><mrow><mi>L</mi><mo>⁢</mo><mi>S</mi><mo>⁢</mo><mi>T</mi><mo>⁢</mo><mi>M</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM976"><mi>𝐬</mi><mi>𝐣</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex70.m2" class="ltx_Math" alttext="\displaystyle\mathbf{h_{j}}" display="inline"><msub><mi>𝐡</mi><mi>𝐣</mi></msub></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S11.SS2.p4" class="ltx_para">
<table id="S11.Ex71" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S11.Ex71.m1" class="ltx_Math" alttext="\mathbf{s_{j}}\in\mathbb{R}^{2\cdot d_{h}},\,\;\mathbf{x_{i}}\in\mathbb{R}^{d_%
{x}},\,\;\mathbf{c_{j}},\mathbf{h_{j}},\mathbf{i},\mathbf{f},\mathbf{o},%
\mathbf{g}\in\mathbb{R}^{d_{h}},\,\;\mathbf{W^{x\circ}}\in\mathbb{R}^{d_{x}%
\times d_{h}},\,\;\mathbf{W^{h\circ}}\in\mathbb{R}^{d_{h}\times d_{h}},\,\;" display="block"><mrow><mrow><mrow id="XM993"><msub><mi>𝐬</mi><mi>𝐣</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>2</mn><mo>⋅</mo><msub><mi>d</mi><mi>h</mi></msub></mrow></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM991"><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>∈</mo><mrow><msup id="XM985"><mi>ℝ</mi><msub><mi>d</mi><mi>x</mi></msub></msup><mo rspace="7pt">,</mo><msub id="XM986"><mi>𝐜</mi><mi>𝐣</mi></msub><mo>,</mo><msub id="XM987"><mi>𝐡</mi><mi>𝐣</mi></msub><mo>,</mo><mi id="XM988">𝐢</mi><mo>,</mo><mi id="XM989">𝐟</mi><mo>,</mo><mi id="XM990">𝐨</mi></mrow></mrow><mo>,</mo><mrow><mrow id="XM983"><mi>𝐠</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>h</mi></msub></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM981"><msup><mi>𝐖</mi><mrow><mi id="XM977">𝐱</mi><mo>⁣</mo><mo id="XM978">∘</mo></mrow></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>x</mi></msub><mo>×</mo><msub><mi>d</mi><mi>h</mi></msub></mrow></msup></mrow><mo rspace="7pt">,</mo><mrow id="XM982"><msup><mi>𝐖</mi><mrow><mi id="XM979">𝐡</mi><mo>⁣</mo><mo id="XM980">∘</mo></mrow></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>h</mi></msub><mo>×</mo><msub><mi>d</mi><mi>h</mi></msub></mrow></msup></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S11.SS2.p5" class="ltx_para">
<p class="ltx_p">The symbol <math id="S11.SS2.p5.m1" class="ltx_Math" alttext="\odot" display="inline"><mo>⊙</mo></math> is used to denote component-wise product.
The state at time <math id="S11.SS2.p5.m2" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math> is composed of two vectors, <math id="S11.SS2.p5.m3" class="ltx_Math" alttext="\mathbf{c_{j}}" display="inline"><msub><mi>𝐜</mi><mi>𝐣</mi></msub></math> and <math id="S11.SS2.p5.m4" class="ltx_Math" alttext="\mathbf{h_{j}}" display="inline"><msub><mi>𝐡</mi><mi>𝐣</mi></msub></math>, where <math id="S11.SS2.p5.m5" class="ltx_Math" alttext="\mathbf{c_{j}}" display="inline"><msub><mi>𝐜</mi><mi>𝐣</mi></msub></math> is the memory component and <math id="S11.SS2.p5.m6" class="ltx_Math" alttext="\mathbf{h_{j}}" display="inline"><msub><mi>𝐡</mi><mi>𝐣</mi></msub></math> is
the output, or state, component.
There are three gates, <math id="S11.SS2.p5.m7" class="ltx_Math" alttext="\mathbf{i}" display="inline"><mi>𝐢</mi></math>, <math id="S11.SS2.p5.m8" class="ltx_Math" alttext="\mathbf{f}" display="inline"><mi>𝐟</mi></math> and <math id="S11.SS2.p5.m9" class="ltx_Math" alttext="\mathbf{o}" display="inline"><mi>𝐨</mi></math>, controlling for <span class="ltx_text ltx_font_bold">i</span>nput, <span class="ltx_text ltx_font_bold">f</span>orget and <span class="ltx_text ltx_font_bold">o</span>utput.
The gate values are computed based on linear combinations of the current input <math id="S11.SS2.p5.m10" class="ltx_Math" alttext="\mathbf{x_{j}}" display="inline"><msub><mi>𝐱</mi><mi>𝐣</mi></msub></math> and the previous state <math id="S11.SS2.p5.m11" class="ltx_Math" alttext="\mathbf{h_{j-1}}" display="inline"><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></math>, passed
through a sigmoid activation function. An update candidate <math id="S11.SS2.p5.m12" class="ltx_Math" alttext="\mathbf{g}" display="inline"><mi>𝐠</mi></math> is computed
as a linear combination of <math id="S11.SS2.p5.m13" class="ltx_Math" alttext="\mathbf{x_{j}}" display="inline"><msub><mi>𝐱</mi><mi>𝐣</mi></msub></math> and <math id="S11.SS2.p5.m14" class="ltx_Math" alttext="\mathbf{h_{j-1}}" display="inline"><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></math>, passed through a <math id="S11.SS2.p5.m15" class="ltx_Math" alttext="\tanh" display="inline"><mi>tanh</mi></math>
activation function. The memory <math id="S11.SS2.p5.m16" class="ltx_Math" alttext="\mathbf{c_{j}}" display="inline"><msub><mi>𝐜</mi><mi>𝐣</mi></msub></math> is then updated: the forget gate controls how much of the previous memory to keep (<math id="S11.SS2.p5.m17" class="ltx_Math" alttext="\mathbf{c_{j-1}}\odot\mathbf{f}" display="inline"><mrow><msub><mi>𝐜</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⊙</mo><mi>𝐟</mi></mrow></math>),
and the input gate controls how much of the proposed update to keep (<math id="S11.SS2.p5.m18" class="ltx_Math" alttext="\mathbf{g}\odot\mathbf{i}" display="inline"><mrow><mi>𝐠</mi><mo>⊙</mo><mi>𝐢</mi></mrow></math>). Finally, the value of <math id="S11.SS2.p5.m19" class="ltx_Math" alttext="\mathbf{h_{j}}" display="inline"><msub><mi>𝐡</mi><mi>𝐣</mi></msub></math> (which is also the output <math id="S11.SS2.p5.m20" class="ltx_Math" alttext="\mathbf{y_{j}}" display="inline"><msub><mi>𝐲</mi><mi>𝐣</mi></msub></math>) is
determined based on the content of the memory <math id="S11.SS2.p5.m21" class="ltx_Math" alttext="\mathbf{c_{j}}" display="inline"><msub><mi>𝐜</mi><mi>𝐣</mi></msub></math>, passed through a <math id="S11.SS2.p5.m22" class="ltx_Math" alttext="\tanh" display="inline"><mi>tanh</mi></math> non-linearity and controlled by the output gate.
The gating mechanisms allow for gradients related to the memory part <math id="S11.SS2.p5.m23" class="ltx_Math" alttext="\mathbf{c_{j}}" display="inline"><msub><mi>𝐜</mi><mi>𝐣</mi></msub></math> to stay high across very long time ranges.</p>
</div>
<div id="S11.SS2.p6" class="ltx_para">
<p class="ltx_p">For further discussion on the LSTM architecture see the PhD thesis by Alex
Graves <span class="ltx_ERROR undefined">\citeyear</span>graves2008supervised, as well as
Chris Olah’s description.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">34</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">34</sup><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</span></a></span></span></span> For an analysis of the
behavior of an LSTM when used as a character-level language model, see
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S11.SS2.p7" class="ltx_para">
<p class="ltx_p">LSTMs are currently the most successful type of RNN architecture, and they are
responsible for many state-of-the-art sequence modeling results.
The main competitor of the LSTM-RNN is the GRU, to be discussed next.</p>
</div>
<section id="S11.SS2.SSS5.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Practical Considerations</h5>

<div id="S11.SS2.SSS5.Px1.p1" class="ltx_para">
<p class="ltx_p">When training LSTM networks, Jozefowicz et al
<span class="ltx_ERROR undefined">\citeyear</span>jozefowicz2015empirical strongly recommend to always initialize the bias term
of the forget gate to be close to one. When applying dropout to an RNN with an
LSTM, Zaremba et al <span class="ltx_ERROR undefined">\citeyear</span>zaremba2014recurrent found out that it is
crucial to apply dropout only on the non-recurrent connection, i.e. only to
apply it between layers and not between sequence positions.</p>
</div>
</section>
</section>
<section id="S11.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">11.3 </span>GRU</h3>

<div id="S11.SS3.p1" class="ltx_para">
<p class="ltx_p">The LSTM architecture is very effective, but also quite complicated. The
complexity of the system makes it hard to analyze,
and also computationally expensive to work with.
The gated recurrent unit (GRU) was recently introduced by Cho et al
<span class="ltx_ERROR undefined">\citeyear</span>cho2014learning as an alternative to the LSTM. It was subsequently
shown by Chung et al <span class="ltx_ERROR undefined">\citeyear</span>chung2014empirical to perform comparably to the
LSTM on several (non textual) datasets.</p>
</div>
<div id="S11.SS3.p2" class="ltx_para">
<p class="ltx_p">Like the LSTM, the GRU is also based on a gating mechanism, but with
substantially fewer gates and without a separate memory component.</p>
</div>
<div id="S11.SS3.p3" class="ltx_para">
<table id="S13.EGx22" class="ltx_equationgroup ltx_eqn_align">

<tr id="S11.Ex72" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex72.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s_{j}}=R_{GRU}(\mathbf{s_{j-1}},\mathbf{x_{j}})=" display="inline"><mrow><msub><mi>𝐬</mi><mi>𝐣</mi></msub><mo>=</mo><mrow><msub><mi>R</mi><mrow><mi>G</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>U</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM998"><mi>𝐬</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>,</mo><msub id="XM999"><mi>𝐱</mi><mi>𝐣</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex72.m2" class="ltx_Math" alttext="\displaystyle(\mathbf{1}-\mathbf{z})\odot\mathbf{s_{j-1}}+\mathbf{z}\odot%
\mathbf{h}" display="inline"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM1000"><mn>𝟏</mn><mo>-</mo><mi>𝐳</mi></mrow><mo stretchy="false">)</mo></mrow><mo>⊙</mo><msub><mi>𝐬</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></mrow><mo>+</mo><mrow><mi>𝐳</mi><mo>⊙</mo><mi>𝐡</mi></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex73" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex73.m1" class="ltx_Math" alttext="\displaystyle\mathbf{z}=" display="inline"><mrow><mi>𝐳</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex73.m2" class="ltx_Math" alttext="\displaystyle\sigma(\mathbf{x_{j}}\mathbf{W^{xz}}+\mathbf{h_{j-1}}\mathbf{W^{%
hz}})" display="inline"><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1002"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐳</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐳</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex74" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex74.m1" class="ltx_Math" alttext="\displaystyle\mathbf{r}=" display="inline"><mrow><mi>𝐫</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex74.m2" class="ltx_Math" alttext="\displaystyle\sigma(\mathbf{x_{j}}\mathbf{W^{xr}}+\mathbf{h_{j-1}}\mathbf{W^{%
hr}})" display="inline"><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1004"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐫</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐫</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex75" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex75.m1" class="ltx_Math" alttext="\displaystyle\mathbf{h}=" display="inline"><mrow><mi>𝐡</mi><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex75.m2" class="ltx_Math" alttext="\displaystyle\tanh(\mathbf{x_{j}}\mathbf{W^{xh}}+(\mathbf{h_{j-1}}\odot\mathbf%
{r})\mathbf{W^{hg}})" display="inline"><mrow><mi id="XM1009">tanh</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1010"><mrow><msub><mi>𝐱</mi><mi>𝐣</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝐡</mi></msup></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM1008"><msub><mi>𝐡</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⊙</mo><mi>𝐫</mi></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡𝐠</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S11.Ex77" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S11.Ex77.m1" class="ltx_Math" alttext="\displaystyle\mathbf{y_{j}}=O_{LSTM}(\mathbf{s_{j}})=" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐣</mi></msub><mo>=</mo><mrow><msub><mi>O</mi><mrow><mi>L</mi><mo>⁢</mo><mi>S</mi><mo>⁢</mo><mi>T</mi><mo>⁢</mo><mi>M</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM1012"><mi>𝐬</mi><mi>𝐣</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S11.Ex77.m2" class="ltx_Math" alttext="\displaystyle\mathbf{s_{j}}" display="inline"><msub><mi>𝐬</mi><mi>𝐣</mi></msub></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S11.SS3.p4" class="ltx_para">
<table id="S11.Ex78" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S11.Ex78.m1" class="ltx_Math" alttext="\mathbf{s_{j}}\in\mathbb{R}^{d_{h}},\,\;\mathbf{x_{i}}\in\mathbb{R}^{d_{x}},\,%
\;\mathbf{z},\mathbf{r},\mathbf{h}\in\mathbb{R}^{d_{h}},\,\;\mathbf{W^{x\circ}%
}\in\mathbb{R}^{d_{x}\times d_{h}},\,\;\mathbf{W^{h\circ}}\in\mathbb{R}^{d_{h}%
\times d_{h}},\,\;" display="block"><mrow><mrow><mrow id="XM1026"><msub><mi>𝐬</mi><mi>𝐣</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>h</mi></msub></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM1024"><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>∈</mo><mrow><msup id="XM1021"><mi>ℝ</mi><msub><mi>d</mi><mi>x</mi></msub></msup><mo rspace="7pt">,</mo><mi id="XM1022">𝐳</mi><mo>,</mo><mi id="XM1023">𝐫</mi></mrow></mrow><mo>,</mo><mrow><mrow id="XM1019"><mi>𝐡</mi><mo>∈</mo><msup><mi>ℝ</mi><msub><mi>d</mi><mi>h</mi></msub></msup></mrow><mo rspace="7pt">,</mo><mrow><mrow id="XM1017"><msup><mi>𝐖</mi><mrow><mi id="XM1013">𝐱</mi><mo>⁣</mo><mo id="XM1014">∘</mo></mrow></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>x</mi></msub><mo>×</mo><msub><mi>d</mi><mi>h</mi></msub></mrow></msup></mrow><mo rspace="7pt">,</mo><mrow id="XM1018"><msup><mi>𝐖</mi><mrow><mi id="XM1015">𝐡</mi><mo>⁣</mo><mo id="XM1016">∘</mo></mrow></msup><mo>∈</mo><msup><mi>ℝ</mi><mrow><msub><mi>d</mi><mi>h</mi></msub><mo>×</mo><msub><mi>d</mi><mi>h</mi></msub></mrow></msup></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S11.SS3.p5" class="ltx_para ltx_noindent">
<p class="ltx_p">One gate (<math id="S11.SS3.p5.m1" class="ltx_Math" alttext="\mathbf{r}" display="inline"><mi>𝐫</mi></math>) is used to control access to the previous state <math id="S11.SS3.p5.m2" class="ltx_Math" alttext="\mathbf{s_{j-1}}" display="inline"><msub><mi>𝐬</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></math> and compute a proposed update <math id="S11.SS3.p5.m3" class="ltx_Math" alttext="\mathbf{h}" display="inline"><mi>𝐡</mi></math>. The updated state
<math id="S11.SS3.p5.m4" class="ltx_Math" alttext="\mathbf{s_{j}}" display="inline"><msub><mi>𝐬</mi><mi>𝐣</mi></msub></math> (which also serves as the output <math id="S11.SS3.p5.m5" class="ltx_Math" alttext="\mathbf{y_{j}}" display="inline"><msub><mi>𝐲</mi><mi>𝐣</mi></msub></math>) is then determined based on an interpolation of the previous state <math id="S11.SS3.p5.m6" class="ltx_Math" alttext="\mathbf{s_{j-1}}" display="inline"><msub><mi>𝐬</mi><mrow><mi>𝐣</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></math> and the proposal <math id="S11.SS3.p5.m7" class="ltx_Math" alttext="\mathbf{h}" display="inline"><mi>𝐡</mi></math>,
where the proportions of the interpolation are controlled using the gate <math id="S11.SS3.p5.m8" class="ltx_Math" alttext="\mathbf{z}" display="inline"><mi>𝐳</mi></math>.</p>
</div>
<div id="S11.SS3.p6" class="ltx_para">
<p class="ltx_p">The GRU was shown to be effective in language modeling and machine
translation.
However, the jury between the GRU, the LSTM and possible alternative
RNN architectures is still out, and the subject is actively researched.
For an empirical exploration of the GRU and the LSTM architectures, see
<cite class="ltx_cite">[]</cite>.</p>
</div>
</section>
<section id="S11.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">11.4 </span>Other Variants</h3>

<div id="S11.SS4.p1" class="ltx_para">
<p class="ltx_p">The gated architectures of the LSTM and the GRU help in alleviating the
vanishing gradients problem of the Simple RNN, and allow these RNNs to capture
dependencies that span long time ranges.
Some researchers explore simpler architectures than the LSTM and the GRU for
achieving similar benefits.</p>
</div>
<div id="S11.SS4.p2" class="ltx_para">
<p class="ltx_p">Mikolov et al <span class="ltx_ERROR undefined">\citeyear</span>mikolov2014learning observed that the matrix
multiplication <math id="S11.SS4.p2.m1" class="ltx_Math" alttext="\mathbf{s_{i-1}}\mathbf{W^{s}}" display="inline"><mrow><msub><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐬</mi></msup></mrow></math> coupled with the nonlinearity <math id="S11.SS4.p2.m2" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math> in the update rule <math id="S11.SS4.p2.m3" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math>
of the Simple RNN causes the state vector <math id="S11.SS4.p2.m4" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> to undergo large changes
at each time step, prohibiting it from remembering information over long time
periods. They propose to split the state vector <math id="S11.SS4.p2.m5" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> into a slow changing component
<math id="S11.SS4.p2.m6" class="ltx_Math" alttext="\mathbf{c_{i}}" display="inline"><msub><mi>𝐜</mi><mi>𝐢</mi></msub></math> (“context units”) and a fast changing component <math id="S11.SS4.p2.m7" class="ltx_Math" alttext="\mathbf{h_{i}}" display="inline"><msub><mi>𝐡</mi><mi>𝐢</mi></msub></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">35</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">35</sup>We
depart from the notation in <cite class="ltx_cite">[]</cite> and reuse the
symbols used in the LSTM description.</span></span></span>
The slow changing component <math id="S11.SS4.p2.m8" class="ltx_Math" alttext="\mathbf{c_{i}}" display="inline"><msub><mi>𝐜</mi><mi>𝐢</mi></msub></math> is updated according to a linear interpolation
of the input and the previous component:
<math id="S11.SS4.p2.m9" class="ltx_Math" alttext="\mathbf{c_{i}}=(1-\alpha)\mathbf{x_{i}}\mathbf{W^{x1}}+\alpha\mathbf{c_{i-1}}" display="inline"><mrow><msub><mi>𝐜</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow id="XM1028"><mn>1</mn><mo>-</mo><mi>α</mi></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝟏</mi></msup></mrow><mo>+</mo><mrow><mi>α</mi><mo>⁢</mo><msub><mi>𝐜</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub></mrow></mrow></mrow></math>, where <math id="S11.SS4.p2.m10" class="ltx_Math" alttext="\alpha\in(0,1)" display="inline"><mrow><mi>α</mi><mo>∈</mo><mrow><mo stretchy="false">(</mo><mn id="XM1029">0</mn><mo>,</mo><mn id="XM1030">1</mn><mo stretchy="false">)</mo></mrow></mrow></math>. This
update allows <math id="S11.SS4.p2.m11" class="ltx_Math" alttext="\mathbf{c_{i}}" display="inline"><msub><mi>𝐜</mi><mi>𝐢</mi></msub></math> to accumulate the previous inputs. The fast changing
component <math id="S11.SS4.p2.m12" class="ltx_Math" alttext="\mathbf{h_{i}}" display="inline"><msub><mi>𝐡</mi><mi>𝐢</mi></msub></math> is updated similarly to the Simple RNN update rule,
but changed to take <math id="S11.SS4.p2.m13" class="ltx_Math" alttext="\mathbf{c_{i}}" display="inline"><msub><mi>𝐜</mi><mi>𝐢</mi></msub></math> into account as well:<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">36</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">36</sup>The update rule
diverges from the S-RNN update rule also by fixing the non-linearity to be
a sigmoid function, and by not using a bias term. However, these changes are
not discussed as central to the proposal.</span></span></span>
<math id="S11.SS4.p2.m14" class="ltx_Math" alttext="\mathbf{h_{i}}=\sigma(\mathbf{x_{i}}\mathbf{W^{x2}}+\mathbf{h_{i-1}}\mathbf{W^%
{h}}+\mathbf{c_{i}}\mathbf{W^{c}})" display="inline"><mrow><msub><mi>𝐡</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mi>σ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1031"><mrow><msub><mi>𝐱</mi><mi>𝐢</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐱𝟐</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐡</mi><mrow><mi>𝐢</mi><mo>-</mo><mn>𝟏</mn></mrow></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐡</mi></msup></mrow><mo>+</mo><mrow><msub><mi>𝐜</mi><mi>𝐢</mi></msub><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐜</mi></msup></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.
Finally, the output <math id="S11.SS4.p2.m15" class="ltx_Math" alttext="\mathbf{y_{i}}" display="inline"><msub><mi>𝐲</mi><mi>𝐢</mi></msub></math> is the concatenation of the slow and the fast
changing parts of the state: <math id="S11.SS4.p2.m16" class="ltx_Math" alttext="\mathbf{y_{i}}=[\mathbf{c_{i}};\mathbf{h_{i}}]" display="inline"><mrow><msub><mi>𝐲</mi><mi>𝐢</mi></msub><mo>=</mo><mrow><mo stretchy="false">[</mo><msub id="XM1032"><mi>𝐜</mi><mi>𝐢</mi></msub><mo>;</mo><msub id="XM1033"><mi>𝐡</mi><mi>𝐢</mi></msub><mo stretchy="false">]</mo></mrow></mrow></math>. Mikolov et al
demonstrate that this architecture provides competitive perplexities to
the much more complex LSTM on language modeling tasks.
</p>
</div>
<div id="S11.SS4.p3" class="ltx_para">
<p class="ltx_p">The approach of Mikolov et al can be interpreted as constraining the block of the
matrix <math id="S11.SS4.p3.m1" class="ltx_Math" alttext="\mathbf{W^{s}}" display="inline"><msup><mi>𝐖</mi><mi>𝐬</mi></msup></math> in the S-RNN corresponding to <math id="S11.SS4.p3.m2" class="ltx_Math" alttext="\mathbf{c_{i}}" display="inline"><msub><mi>𝐜</mi><mi>𝐢</mi></msub></math> to be a multiply of
the identity matrix (see Mikolov et al <span class="ltx_ERROR undefined">\citeyear</span>mikolov2014learning for the
details). Le et al <cite class="ltx_cite">[]</cite> propose an even simpler approach: set
the activation function of the S-RNN to a ReLU, and initialize the biases
<math id="S11.SS4.p3.m3" class="ltx_Math" alttext="\mathbf{b}" display="inline"><mi>𝐛</mi></math> as zeroes and the matrix
<math id="S11.SS4.p3.m4" class="ltx_Math" alttext="\mathbf{W^{s}}" display="inline"><msup><mi>𝐖</mi><mi>𝐬</mi></msup></math> as the identify matrix.
This causes an untrained RNN to copy the previous state to the current state, add
the effect of the current input <math id="S11.SS4.p3.m5" class="ltx_Math" alttext="\mathbf{x_{i}}" display="inline"><msub><mi>𝐱</mi><mi>𝐢</mi></msub></math> and set the negative values to zero.
After setting this initial bias towards state copying,
the training procedure allows <math id="S11.SS4.p3.m6" class="ltx_Math" alttext="\mathbf{W^{s}}" display="inline"><msup><mi>𝐖</mi><mi>𝐬</mi></msup></math> to change freely.
Le et al demonstrate that this simple modification makes the S-RNN comparable
to an LSTM with the same number of parameters on several tasks, including
language modeling.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S12" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">12 </span>Modeling Trees – Recursive Neural Networks</h2>

<div id="S12.p1" class="ltx_para">
<p class="ltx_p">The RNN is very useful for modeling sequences. In language
processing, it is often natural and desirable to work with tree structures.
The trees can be syntactic trees, discourse trees, or even trees representing
the sentiment expressed by various parts of a sentence <cite class="ltx_cite">[]</cite>.
We may
want to predict values based on specific tree nodes, predict values based on the
root nodes, or assign a quality score to a complete tree or part of a tree.
In other cases, we may not care about the tree structure directly but rather
reason about spans in the sentence. In such cases, the tree is merely used as a
backbone structure which help guide the encoding process of the sequence into a
fixed size vector.</p>
</div>
<div id="S12.p2" class="ltx_para">
<p class="ltx_p">The <em class="ltx_emph">recursive neural network</em> (RecNN) abstraction <cite class="ltx_cite">[]</cite>,
popularized in NLP by
Richard Socher and colleagues
<cite class="ltx_cite">[]</cite> is a generalization
of the RNN from sequences to (binary) trees.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">37</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">37</sup>While presented in terms
of binary parse trees, the concepts easily transfer to general recursively-defined data
structures, with the major technical challenge is the definition of an effective
form for <math id="S12.p2.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math>, the combination function.</span></span></span></p>
</div>
<div id="S12.p3" class="ltx_para">
<p class="ltx_p">Much like the RNN encodes each sentence prefix as a state vector, the RecNN encodes
each tree-node as a state vector in <math id="S12.p3.m1" class="ltx_Math" alttext="\mathbb{R}^{d}" display="inline"><msup><mi>ℝ</mi><mi>d</mi></msup></math>. We can then use these
state vectors either to predict values of the corresponding nodes, assign
quality values to each node, or as a semantic representation of the spans rooted
at the nodes.</p>
</div>
<div id="S12.p4" class="ltx_para">
<p class="ltx_p">The main intuition behind the recursive neural networks is that each subtree is
represented as a <math id="S12.p4.m1" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> dimensional vector, and the representation of a node <math id="S12.p4.m2" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math>
with children <math id="S12.p4.m3" class="ltx_Math" alttext="c_{1}" display="inline"><msub><mi>c</mi><mn>1</mn></msub></math> and <math id="S12.p4.m4" class="ltx_Math" alttext="c_{2}" display="inline"><msub><mi>c</mi><mn>2</mn></msub></math> is a function of the representation of the nodes:
<math id="S12.p4.m5" class="ltx_Math" alttext="vec(p)=f(vec(c_{1}),vec(c_{2}))" display="inline"><mrow><mrow><mi>v</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1034">p</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1040"><mi>v</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM1038"><mi>c</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow id="XM1041"><mi>v</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM1039"><mi>c</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, where <math id="S12.p4.m6" class="ltx_Math" alttext="f" display="inline"><mi>f</mi></math> is a composition function taking two
<math id="S12.p4.m7" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vectors and returning a single <math id="S12.p4.m8" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector. Much
like the RNN state <math id="S12.p4.m9" class="ltx_Math" alttext="\mathbf{s_{i}}" display="inline"><msub><mi>𝐬</mi><mi>𝐢</mi></msub></math> is used to encode the entire sequence <math id="S12.p4.m10" class="ltx_Math" alttext="\mathbf{x_{1}:i}" display="inline"><mrow><msub><mi>𝐱</mi><mn>𝟏</mn></msub><mo>:</mo><mi>𝐢</mi></mrow></math>,
the RecNN state associated with a tree node <math id="S12.p4.m11" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math> encodes the entire subtree
rooted at <math id="S12.p4.m12" class="ltx_Math" alttext="p" display="inline"><mi>p</mi></math>. See Figure <a href="#S12.F14" title="Figure 14 ‣ 12 Modeling Trees – Recursive Neural Networks ‣ A Primer on Neural Network Models for Natural Language Processing" class="ltx_ref"><span class="ltx_text ltx_ref_tag">14</span></a> for an illustration.</p>
</div>
<figure id="S12.F14" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">\includegraphics</span>
<p class="ltx_p ltx_align_center">[width=0.4]rec-nn.pdf</p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 14: </span>Illustration of a recursive neural network. The representations of
V and NP<math id="S12.F14.m3" class="ltx_Math" alttext="{}_{1}" display="inline"><msub><mi></mi><mn>1</mn></msub></math> are combined to form the representation of VP. The
representations of VP and NP<math id="S12.F14.m4" class="ltx_Math" alttext="{}_{2}" display="inline"><msub><mi></mi><mn>2</mn></msub></math> are then combined to form the
representation of S.</figcaption>
</figure>
<section id="S12.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">12.1 </span>Formal Definition</h3>

<div id="S12.SS1.p1" class="ltx_para">
<p class="ltx_p">Consider a binary parse tree <math id="S12.SS1.p1.m1" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> over an <math id="S12.SS1.p1.m2" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>-word sentence. As a reminder,
an ordered, unlabeled tree over a string <math id="S12.SS1.p1.m3" class="ltx_Math" alttext="x_{1},\ldots,x_{n}" display="inline"><mrow><msub id="XM1042"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM1043">…</mi><mo>,</mo><msub id="XM1044"><mi>x</mi><mi>n</mi></msub></mrow></math> can be represented as a unique
set of triplets <math id="S12.SS1.p1.m4" class="ltx_Math" alttext="(i,k,j)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM1045">i</mi><mo>,</mo><mi id="XM1046">k</mi><mo>,</mo><mi id="XM1047">j</mi><mo stretchy="false">)</mo></mrow></math>, s.t. <math id="S12.SS1.p1.m5" class="ltx_Math" alttext="i\leq k\leq j" display="inline"><mrow><mi>i</mi><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>j</mi></mrow></math>. Each such triplet indicates
that a node spanning words <math id="S12.SS1.p1.m6" class="ltx_Math" alttext="x_{i:j}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow></msub></math> is parent of the nodes spanning <math id="S12.SS1.p1.m7" class="ltx_Math" alttext="x_{i:k}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>k</mi></mrow></msub></math>
and <math id="S12.SS1.p1.m8" class="ltx_Math" alttext="x_{k+1:j}" display="inline"><msub><mi>x</mi><mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>:</mo><mi>j</mi></mrow></msub></math>. Triplets of the form <math id="S12.SS1.p1.m9" class="ltx_Math" alttext="(i,i,i)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM1048">i</mi><mo>,</mo><mi id="XM1049">i</mi><mo>,</mo><mi id="XM1050">i</mi><mo stretchy="false">)</mo></mrow></math> correspond to terminal symbols
at the tree leaves (the words <math id="S12.SS1.p1.m10" class="ltx_Math" alttext="x_{i}" display="inline"><msub><mi>x</mi><mi>i</mi></msub></math>). Moving from the unlabeled case to the
labeled one, we can represent a tree as a set of 6-tuples <math id="S12.SS1.p1.m11" class="ltx_Math" alttext="(A\rightarrow B,C,i,k,j)" display="inline"><mrow><mo stretchy="false">(</mo><mrow id="XM1056"><mi>A</mi><mo>→</mo><mrow><mi id="XM1051">B</mi><mo>,</mo><mi id="XM1052">C</mi><mo>,</mo><mi id="XM1053">i</mi><mo>,</mo><mi id="XM1054">k</mi><mo>,</mo><mi id="XM1055">j</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></math>, whereas <math id="S12.SS1.p1.m12" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math>, <math id="S12.SS1.p1.m13" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> and <math id="S12.SS1.p1.m14" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math> indicate the spans as before, and <math id="S12.SS1.p1.m15" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math>, <math id="S12.SS1.p1.m16" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math>
and <math id="S12.SS1.p1.m17" class="ltx_Math" alttext="C" display="inline"><mi>C</mi></math> are the node labels of of the nodes spanning <math id="S12.SS1.p1.m18" class="ltx_Math" alttext="x_{i:j}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow></msub></math>, <math id="S12.SS1.p1.m19" class="ltx_Math" alttext="x_{i:k}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>k</mi></mrow></msub></math> and
<math id="S12.SS1.p1.m20" class="ltx_Math" alttext="x_{k+1:j}" display="inline"><msub><mi>x</mi><mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>:</mo><mi>j</mi></mrow></msub></math> respectively. Here, leaf nodes have the form <math id="S12.SS1.p1.m21" class="ltx_Math" alttext="(A\rightarrow A,A,i,i,i)" display="inline"><mrow><mo stretchy="false">(</mo><mrow id="XM1062"><mi>A</mi><mo>→</mo><mrow><mi id="XM1057">A</mi><mo>,</mo><mi id="XM1058">A</mi><mo>,</mo><mi id="XM1059">i</mi><mo>,</mo><mi id="XM1060">i</mi><mo>,</mo><mi id="XM1061">i</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></math>, where <math id="S12.SS1.p1.m22" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> is a pre-terminal symbol. We refer to such tuples as
<em class="ltx_emph">production rules</em>.
For an example, consider the syntactic tree for the sentence “the boy saw her
duck”.</p>
<span class="ltx_ERROR undefined ltx_centering">\Tree</span>
<p class="ltx_p ltx_align_center">[.S [.NP [.Det the ] [.Noun boy ] ] [.VP [.Verb saw ] [.NP [.Det her ]
[.Noun duck ] ] ] ]</p>
<p class="ltx_p">Its corresponding unlabeled and labeled representations are :</p>
</div>
<div id="S12.SS1.p2" class="ltx_para">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_border_r">Unlabeled</th>
<th class="ltx_td ltx_align_center ltx_border_r">Labeled</th>
<th class="ltx_td ltx_align_left">Corresponding Span</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t">(1,1,1)</td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t">(Det, Det, Det, 1, 1, 1)</td>
<td class="ltx_td ltx_align_left ltx_border_t">
<math id="S12.SS1.p2.m1" class="ltx_Math" alttext="x_{1:1}" display="inline"><msub><mi>x</mi><mrow><mn>1</mn><mo>:</mo><mn>1</mn></mrow></msub></math> the</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(2,2,2)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(Noun, Noun, Noun, 2, 2, 2)</td>
<td class="ltx_td ltx_align_left">
<math id="S12.SS1.p2.m2" class="ltx_Math" alttext="x_{2:2}" display="inline"><msub><mi>x</mi><mrow><mn>2</mn><mo>:</mo><mn>2</mn></mrow></msub></math> boy</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(3,3,3)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(Verb, Verb, Verb, 3, 3, 3)</td>
<td class="ltx_td ltx_align_left">saw</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(4,4,4)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(Det, Det, Det, 4, 4, 4)</td>
<td class="ltx_td ltx_align_left">her</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(5,5,5)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(Noun, Noun, Noun, 5, 5, 5)</td>
<td class="ltx_td ltx_align_left">duck</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(4,4,5)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(NP, Det, Noun, 4, 4, 5)</td>
<td class="ltx_td ltx_align_left">her duck</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(3,3,5)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(VP, Verb, NP, 3, 3, 5)</td>
<td class="ltx_td ltx_align_left">saw her duck</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(1,1,2)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(NP, Det, Noun, 1, 1, 2)</td>
<td class="ltx_td ltx_align_left">the boy</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_r">(1,2,5)</td>
<td class="ltx_td ltx_align_center ltx_border_r">(S, NP, VP, 1, 2, 5)</td>
<td class="ltx_td ltx_align_left">the boy saw her duck</td>
</tr>
</tbody>
</table>
</div>
<div id="S12.SS1.p3" class="ltx_para">
<p class="ltx_p">The set of production rules above can be uniquely converted to a set tree nodes
<math id="S12.SS1.p3.m1" class="ltx_Math" alttext="q^{A}_{i:j}" display="inline"><msubsup><mi>q</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow><mi>A</mi></msubsup></math> (indicating a node with symbol <math id="S12.SS1.p3.m2" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> over the span <math id="S12.SS1.p3.m3" class="ltx_Math" alttext="x_{i:j}" display="inline"><msub><mi>x</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow></msub></math>)
by simply ignoring
the elements <math id="S12.SS1.p3.m4" class="ltx_Math" alttext="(B,C,k)" display="inline"><mrow><mo stretchy="false">(</mo><mi id="XM1063">B</mi><mo>,</mo><mi id="XM1064">C</mi><mo>,</mo><mi id="XM1065">k</mi><mo stretchy="false">)</mo></mrow></math> in each production rule. We are now in position to define
the Recursive Neural Network.</p>
</div>
<div id="S12.SS1.p4" class="ltx_para">
<p class="ltx_p">A Recursive Neural Network (RecNN) is a function that takes as input a parse
tree over an <math id="S12.SS1.p4.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>-word sentence <math id="S12.SS1.p4.m2" class="ltx_Math" alttext="x_{1},\ldots,x_{n}" display="inline"><mrow><msub id="XM1066"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM1067">…</mi><mo>,</mo><msub id="XM1068"><mi>x</mi><mi>n</mi></msub></mrow></math>. Each of the sentence’s
words is represented as a <math id="S12.SS1.p4.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>-dimensional vector <math id="S12.SS1.p4.m4" class="ltx_Math" alttext="\mathbf{x_{i}}" display="inline"><msub><mi>𝐱</mi><mi>𝐢</mi></msub></math>, and the tree is represented as
a set <math id="S12.SS1.p4.m5" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> of production rules <math id="S12.SS1.p4.m6" class="ltx_Math" alttext="(A\rightarrow B,C,i,j,k)" display="inline"><mrow><mo stretchy="false">(</mo><mrow id="XM1074"><mi>A</mi><mo>→</mo><mrow><mi id="XM1069">B</mi><mo>,</mo><mi id="XM1070">C</mi><mo>,</mo><mi id="XM1071">i</mi><mo>,</mo><mi id="XM1072">j</mi><mo>,</mo><mi id="XM1073">k</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></math>. Denote the nodes of
<math id="S12.SS1.p4.m7" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> by <math id="S12.SS1.p4.m8" class="ltx_Math" alttext="q^{A}_{i:j}" display="inline"><msubsup><mi>q</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow><mi>A</mi></msubsup></math>.
The RecNN returns as output a corresponding set of
<em class="ltx_emph ltx_markedasmath">inside state vectors</em> <math id="S12.SS1.p4.m10" class="ltx_Math" alttext="\mathbf{s^{A}_{i:j}}" display="inline"><msubsup><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐀</mi></msubsup></math>, where each inside state vector
<math id="S12.SS1.p4.m11" class="ltx_Math" alttext="\mathbf{s^{A}_{i:j}}\in\mathbb{R}^{d}" display="inline"><mrow><msubsup><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐀</mi></msubsup><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow></math> represents the
corresponding tree node <math id="S12.SS1.p4.m12" class="ltx_Math" alttext="q^{A}_{i:j}" display="inline"><msubsup><mi>q</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow><mi>A</mi></msubsup></math>, and encodes the entire structure rooted at that node.
Like the sequence RNN, the tree shaped RecNN is defined recursively using a
function <math id="S12.SS1.p4.m13" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math>, where the inside vector of a given node is defined as a function of the inside vectors of its
direct children.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">38</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">38</sup>Le and Zuidema <span class="ltx_ERROR undefined">\citeyear</span>le2014insideoutside extend the RecNN
definition such that each node has, in addition to its inside state vector, also an
<em class="ltx_emph">outside state vector</em> representing the entire structure around the
subtree rooted at that node. Their formulation is based on the recursive
computation of the classic inside-outside algorithm, and can be thought of as
the BI-RNN counterpart of the tree RecNN. For details, see
<cite class="ltx_cite">[]</cite>.</span></span></span>
Formally:</p>
</div>
<div id="S12.SS1.p5" class="ltx_para">
<table id="S13.EGx23" class="ltx_equationgroup ltx_eqn_align">

<tr id="S12.Ex79" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S12.Ex79.m1" class="ltx_Math" alttext="\displaystyle RecNN(x_{1},\ldots,x_{n},\mathcal{T})=" display="inline"><mrow><mrow><mi>R</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM1081"><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal" id="XM1082">…</mi><mo>,</mo><msub id="XM1083"><mi>x</mi><mi>n</mi></msub><mo>,</mo><mi class="ltx_font_mathcaligraphic" id="XM1084">𝒯</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S12.Ex79.m2" class="ltx_Math" alttext="\displaystyle\{\mathbf{s^{A}_{i:j}}\in\mathbb{R}^{d}\,\mid\,q^{A}_{i:j}\in%
\mathcal{T}\}" display="inline"><mrow><mo stretchy="false">{</mo><mrow id="XM1085"><msubsup><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐀</mi></msubsup><mo>∈</mo><mpadded width="+1.7pt"><msup><mi>ℝ</mi><mi>d</mi></msup></mpadded></mrow><mo rspace="4.2pt">∣</mo><mrow id="XM1086"><msubsup><mi>q</mi><mrow><mi>i</mi><mo>:</mo><mi>j</mi></mrow><mi>A</mi></msubsup><mo>∈</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow><mo stretchy="false">}</mo></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S12.Ex80" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S12.Ex80.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s^{A}_{i:i}}=" display="inline"><mrow><msubsup><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐢</mi></mrow><mi>𝐀</mi></msubsup><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S12.Ex80.m2" class="ltx_Math" alttext="\displaystyle v(x_{i})" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub id="XM1088"><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
<tr id="S12.Ex81" class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right">
                  <math id="S12.Ex81.m1" class="ltx_Math" alttext="\displaystyle\mathbf{s^{A}_{i:j}}=" display="inline"><mrow><msubsup><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐀</mi></msubsup><mo>=</mo><mi></mi></mrow></math>
                </td>
<td class="ltx_td ltx_align_left">
                  <math id="S12.Ex81.m2" class="ltx_Math" alttext="\displaystyle R(A,B,C,\mathbf{s^{B}_{i:k}},\mathbf{s^{C}_{k+1:j}})\;\;\;\;\;\;%
q^{B}_{i:k}\in\mathcal{T},\;\;q^{C}_{k+1:j}\in\mathcal{T}" display="inline"><mrow><mrow id="XM1105"><mrow><mrow id="XM1103"><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1098">A</mi><mo>,</mo><mi id="XM1099">B</mi><mo>,</mo><mi id="XM1100">C</mi><mo>,</mo><msubsup id="XM1101"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>,</mo><msubsup id="XM1102"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo mathvariant="italic" separator="true">   </mo><msubsup id="XM1104"><mi>q</mi><mrow><mi>i</mi><mo>:</mo><mi>k</mi></mrow><mi>B</mi></msubsup></mrow><mo>∈</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow><mo rspace="8.1pt">,</mo><mrow id="XM1106"><msubsup><mi>q</mi><mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>:</mo><mi>j</mi></mrow><mi>C</mi></msubsup><mo>∈</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></mrow></math>
                </td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S12.SS1.p6" class="ltx_para">
<p class="ltx_p">The function <math id="S12.SS1.p6.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> usually takes the form of a simple linear
transformation, which may or may not be followed by a non-linear activation
function <math id="S12.SS1.p6.m2" class="ltx_Math" alttext="g" display="inline"><mi>g</mi></math>:</p>
</div>
<div id="S12.SS1.p7" class="ltx_para">
<table id="S12.Ex82" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S12.Ex82.m1" class="ltx_Math" alttext="R(A,B,C,\mathbf{s^{B}_{i:k}},\mathbf{s^{C}_{k+1:j}})=g([\mathbf{s^{B}_{i:k}};%
\mathbf{s^{C}_{k+1:j}}]\mathbf{W})" display="block"><mrow><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1107">A</mi><mo>,</mo><mi id="XM1108">B</mi><mo>,</mo><mi id="XM1109">C</mi><mo>,</mo><msubsup id="XM1110"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>,</mo><msubsup id="XM1111"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1120"><mrow><mo stretchy="false">[</mo><msubsup id="XM1118"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>;</mo><msubsup id="XM1119"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">]</mo></mrow><mo>⁢</mo><mi>𝐖</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S12.SS1.p8" class="ltx_para ltx_noindent">
<p class="ltx_p">This formulation of <math id="S12.SS1.p8.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> ignores the tree labels, using the same matrix <math id="S12.SS1.p8.m2" class="ltx_Math" alttext="\mathbf{W}\in\mathbb{R}^{2d\times d}" display="inline"><mrow><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mrow><mn>2</mn><mo>⁢</mo><mi>d</mi></mrow><mo>×</mo><mi>d</mi></mrow></msup></mrow></math> for all combinations. This may be a useful
formulation in case the node labels do not exist (e.g. when the tree does not
represent a syntactic structure with clearly defined labels) or when they are
unreliable. However, if the labels are available, it is generally useful to
include them in the composition function. One approach would be to introduce
<em class="ltx_emph">label embeddings</em> <math id="S12.SS1.p8.m3" class="ltx_Math" alttext="v(A)" display="inline"><mrow><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1121">A</mi><mo stretchy="false">)</mo></mrow></mrow></math> mapping each non-terminal symbol to a <math id="S12.SS1.p8.m4" class="ltx_Math" alttext="d_{nt}" display="inline"><msub><mi>d</mi><mrow><mi>n</mi><mo>⁢</mo><mi>t</mi></mrow></msub></math>
dimensional vector, and change <math id="S12.SS1.p8.m5" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> to include the embedded symbols in the
combination function:</p>
</div>
<div id="S12.SS1.p9" class="ltx_para">
<table id="S12.Ex83" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S12.Ex83.m1" class="ltx_Math" alttext="R(A,B,C,\mathbf{s^{B}_{i:k}},\mathbf{s^{C}_{k+1:j}})=g([\mathbf{s^{B}_{i:k}};%
\mathbf{s^{C}_{k+1:j}};v(A);v(B)]\mathbf{W})" display="block"><mrow><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1122">A</mi><mo>,</mo><mi id="XM1123">B</mi><mo>,</mo><mi id="XM1124">C</mi><mo>,</mo><msubsup id="XM1125"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>,</mo><msubsup id="XM1126"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1145"><mrow><mo stretchy="false">[</mo><msubsup id="XM1141"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>;</mo><msubsup id="XM1142"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo>;</mo><mrow id="XM1143"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1127">A</mi><mo stretchy="false">)</mo></mrow></mrow><mo>;</mo><mrow id="XM1144"><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1128">B</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">]</mo></mrow><mo>⁢</mo><mi>𝐖</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S12.SS1.p10" class="ltx_para ltx_noindent">
<p class="ltx_p">(here, <math id="S12.SS1.p10.m1" class="ltx_Math" alttext="\mathbf{W}\in\mathbb{R}^{2d+2d_{nt}\times d}" display="inline"><mrow><mi>𝐖</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mrow><mn>2</mn><mo>⁢</mo><mi>d</mi></mrow><mo>+</mo><mrow><mrow><mn>2</mn><mo>⁢</mo><msub><mi>d</mi><mrow><mi>n</mi><mo>⁢</mo><mi>t</mi></mrow></msub></mrow><mo>×</mo><mi>d</mi></mrow></mrow></msup></mrow></math>). Such approach is
taken by <cite class="ltx_cite">[]</cite>.
An alternative approach, due to <cite class="ltx_cite">[]</cite> is to untie the weights
according to the non-terminals, using a different composition matrix for each
<math id="S12.SS1.p10.m2" class="ltx_Math" alttext="B,C" display="inline"><mrow><mi id="XM1146">B</mi><mo>,</mo><mi id="XM1147">C</mi></mrow></math> pair of symbols:<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">39</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">39</sup>While not explored in the literature, a trivial
extension would condition the transformation matrix also on <math id="S12.SS1.p10.m3" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math>.</span></span></span></p>
</div>
<div id="S12.SS1.p11" class="ltx_para">
<table id="S12.Ex84" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"></td>
<td class="ltx_align_center"><math id="S12.Ex84.m1" class="ltx_Math" alttext="R(A,B,C,\mathbf{s^{B}_{i:k}},\mathbf{s^{C}_{k+1:j}})=g([\mathbf{s^{B}_{i:k}};%
\mathbf{s^{C}_{k+1:j}}]\mathbf{W^{BC}})" display="block"><mrow><mrow><mi>R</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi id="XM1148">A</mi><mo>,</mo><mi id="XM1149">B</mi><mo>,</mo><mi id="XM1150">C</mi><mo>,</mo><msubsup id="XM1151"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>,</mo><msubsup id="XM1152"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow id="XM1161"><mrow><mo stretchy="false">[</mo><msubsup id="XM1159"><mi>𝐬</mi><mrow><mi>𝐢</mi><mo>:</mo><mi>𝐤</mi></mrow><mi>𝐁</mi></msubsup><mo>;</mo><msubsup id="XM1160"><mi>𝐬</mi><mrow><mrow><mi>𝐤</mi><mo>+</mo><mn>𝟏</mn></mrow><mo>:</mo><mi>𝐣</mi></mrow><mi>𝐂</mi></msubsup><mo stretchy="false">]</mo></mrow><mo>⁢</mo><msup><mi>𝐖</mi><mi>𝐁𝐂</mi></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div id="S12.SS1.p12" class="ltx_para ltx_noindent">
<p class="ltx_p">This formulation is useful when the number of non-terminal symbols (or
the number of possible symbol combinations) is relatively small, as is usually
the case with phrase-structure parse trees. A similar model was also used by
<cite class="ltx_cite">[]</cite> to encode subtrees in semantic-relation
classification task.
</p>
</div>
</section>
<section id="S12.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">12.2 </span>Extensions and Variations</h3>

<div id="S12.SS2.p1" class="ltx_para">
<p class="ltx_p">As all of the definitions of <math id="S12.SS2.p1.m1" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> above suffer from the vanishing gradients
problem of the Simple RNN, several authors sought to replace it with functions
inspired by the Long Short-Term Memory (LSTM) gated architecture, resulting in
Tree-shaped LSTMs <cite class="ltx_cite">[]</cite>.
The question of optimal tree representation is still very much an open research
question, and the vast space of possible combination functions <math id="S12.SS2.p1.m2" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> is yet to be
explored.
Other proposed variants on tree-structured RNNs includes a
<em class="ltx_emph">recursive matrix-vector model</em> <cite class="ltx_cite">[]</cite>
and <em class="ltx_emph">recursive neural tensor network</em> <cite class="ltx_cite">[]</cite>.
In the first variant, each word is
represented as a combination of a vector and a matrix, where the vector defines
the word’s static semantic content as before, while the matrix acts as a learned
“operator” for the word, allowing more subtle semantic compositions than the
addition and weighted averaging implied by the concatenation followed by linear
transformation function. In the second variant, words are associated with
vectors as usual, but the composition
function becomes more expressive by basing it on tensor instead of matrix operations.</p>
</div>
</section>
<section id="S12.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">12.3 </span>Training Recursive Neural Networks</h3>

<div id="S12.SS3.p1" class="ltx_para">
<p class="ltx_p">The training procedure for a recursive neural network follows the same recipe as
training other forms of networks: define a loss, spell out the computation graph, compute
gradients using backpropagation<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">40</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">40</sup>Before the introduction of the
computation graph abstraction, the specific backpropagation procedure for
computing the gradients in a RecNN as defined above was referred to as the
Back-propagation trough Structure (BPTS) algorithm <cite class="ltx_cite">[]</cite>.</span></span></span>, and train the parameters using SGD.</p>
</div>
<div id="S12.SS3.p2" class="ltx_para">
<p class="ltx_p">With regard to the loss function, similar to the sequence RNN one can associate
a loss either with the root of the tree, with any given node, or with a set of
nodes, in which case the individual node’s losses are combined, usually by
summation. The loss function is based on the labeled training data which
associates a label or other quantity with different tree nodes.</p>
</div>
<div id="S12.SS3.p3" class="ltx_para">
<p class="ltx_p">Additionally, one can treat the RecNN as an Encoder, whereas the inside-vector
associated with a node is taken to be an encoding of the tree rooted at that
node. The encoding can potentially be sensitive to arbitrary properties of
the structure. The vector is then passed as input to another network.</p>
</div>
<div id="S12.SS3.p4" class="ltx_para">
<p class="ltx_p">For further discussion on recursive neural networks and
their use in natural language tasks, refer to the PhD thesis of Richard Socher
<span class="ltx_ERROR undefined">\citeyear</span>socher2014recursive.</p>
</div>
<div class="ltx_pagination ltx_role_newpage"></div>
</section>
</section>
<section id="S13" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">13 </span>Conclusions</h2>

<div id="S13.p1" class="ltx_para">
<p class="ltx_p">Neural networks are powerful learners, providing opportunities
ranging from non-linear classification to non-Markovian modeling of sequences
and trees.
We hope that this exposition
help NLP researchers to incorporate neural network models in
their work and take advantage of their power.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul id="L1" class="ltx_biblist">
</ul>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Sat Oct 10 10:33:19 2015 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
